     1                                  ; ------------------------------------------------------------------
     2                                  ; MichalOS Kernel
     3                                  ; ------------------------------------------------------------------
     4                                  
     5                                  	BITS 16
     6                                  	ORG 32768
     7                                  	%include "include/kernel.inc"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; Include file for MichalOS kernel development
     3                              <1> ; ------------------------------------------------------------------
     4                              <1> 
     5                              <1> 	%include "include/constants.asm"
     1                              <2> ; ------------------------------------------------------------------
     2                              <2> ; Include file for MichalOS kernel/program development - constants & macros
     3                              <2> ; ------------------------------------------------------------------
     4                              <2> 
     5                              <2> ; ------------------------------------------------------------------
     6                              <2> ; COLOURS (eg for os_draw_background and os_draw_block)
     7                              <2> 
     8                              <2> %DEFINE BLACK_ON_WHITE		11110000b
     9                              <2> %DEFINE WHITE_ON_BLACK		00001111b
    10                              <2> 
    11                              <2> ; ------------------------------------------------------------------
    12                              <2> ; KEYS
    13                              <2> 
    14                              <2> %DEFINE KEY_UP		72
    15                              <2> %DEFINE KEY_DOWN	80
    16                              <2> %DEFINE KEY_LEFT	75
    17                              <2> %DEFINE KEY_RIGHT	77
    18                              <2> 
    19                              <2> %DEFINE KEY_ESC		27
    20                              <2> %DEFINE KEY_ENTER	13
    21                              <2> 
    22                              <2> ; ------------------------------------------------------------------
    23                              <2> ; MACROS
    24                              <2> 
    25                              <2> %macro syscall 1
    26                              <2> 	mov bp, %1
    27                              <2> 	call os_syscall
    28                              <2> %endmacro
    29                              <2> 
    30                              <2> %macro clr 1
    31                              <2> 	xor %1, %1
    32                              <2> %endmacro
    33                              <2> 
    34                              <2> %macro mov16 3
    35                              <2> 	mov %1, (%2 + %3 * 256)
    36                              <2> %endmacro
    37                              <2> 
    38                              <2> %macro movs 2
    39                              <2> 	push %2
    40                              <2> 	pop %1
    41                              <2> %endmacro
    42                              <2> 
    43                              <2> ; ------------------------------------------------------------------
    44                              <2> ; MEMORY LOCATIONS
    45                              <2> 
    46                              <2> %define ADLIB_BUFFER 0500h
    47                              <2> %define DESKTOP_BACKGROUND 0600h
    48                              <2> %define SYSTEM_FONT 1600h
    49                              <2> %define FILE_MANAGER 2600h
    50                              <2> %define DISK_PARAMS 2E00h
    51                              <2> 
    52                              <2> %define DISK_BUFFER 0E000h
    53                              <2> %define CONFIG_FILE 57000
    54                              <2> %define CONFIG_FILE_SIZE 83
    55                              <2> 
    56                              <2> ; ------------------------------------------------------------------
    57                              <2> ; CONFIG FILE LOCATIONS
    58                              <2> 
    59                              <2> %define CONFIG(x) (CONFIG_FILE + x)
    60                              <2> 
    61                              <2> ; 0 = Desktop background color (BYTE)
    62                              <2> %define CONFIG_DESKTOP_BG_COLOR CONFIG(0)
    63                              <2> 
    64                              <2> ; 1 = Window background color (BYTE)
    65                              <2> %define CONFIG_WINDOW_BG_COLOR CONFIG(1)
    66                              <2> 
    67                              <2> ; 2 = Password enabled (BYTE)
    68                              <2> %define CONFIG_PASSWORD_ENABLED CONFIG(2)
    69                              <2> 
    70                              <2> ; 3 - 35 = Password data (STRING, 32 chars + '\0')
    71                              <2> %define CONFIG_PASSWORD CONFIG(3)
    72                              <2> %define CFG_PASSWORD_MAX_INPUT_LENGTH 32
    73                              <2> %define CFG_PASSWORD_MAX_LENGTH 33
    74                              <2> 
    75                              <2> ; 36 - 68 = Username (STRING, 32 chars + '\0')
    76                              <2> %define CONFIG_USERNAME CONFIG(36)
    77                              <2> %define CFG_USERNAME_MAX_INPUT_LENGTH 32
    78                              <2> %define CFG_USERNAME_MAX_LENGTH 33
    79                              <2> 
    80                              <2> ; 69 - Sound enabled on startup (BYTE)
    81                              <2> %define CONFIG_SOUND_ENABLED CONFIG(69)
    82                              <2> 
    83                              <2> ; 70 - Adlib driver number
    84                              <2> %define CONFIG_ADLIB_DRIVER CONFIG(70)
    85                              <2> %define CFG_ADLIB_STD_DRIVER 0
    86                              <2> %define CFG_ADLIB_PWM_DRIVER 1
    87                              <2> %define CFG_ADLIB_PWM_LOUD_DRIVER 2
    88                              <2> 
    89                              <2> ; 71 - Menu screen dimming enabled (BYTE)
    90                              <2> %define CONFIG_MENU_DIMMING CONFIG(71)
    91                              <2> 
    92                              <2> ; 72 - Menu color (BYTE)
    93                              <2> %define CONFIG_MENU_BG_COLOR CONFIG(72)
    94                              <2> 
    95                              <2> ; 73 - "DOS" font enabled (BYTE)
    96                              <2> %define CONFIG_FONT CONFIG(73)
    97                              <2> %define CFG_FONT_MICHALOS 0
    98                              <2> %define CFG_FONT_BIOS 1
    99                              <2> 
   100                              <2> ; 74 - Minutes to wait for screensaver (BYTE)
   101                              <2> %define CONFIG_SCREENSAVER_MINUTES CONFIG(74)
   102                              <2> 
   103                              <2> ; 75 - System stack size in 16-byte blocks (WORD)
   104                              <2> %define CONFIG_STACKSGMT_SIZE CONFIG(75)
   105                              <2> 
   106                              <2> ; 77 - 80 - Unused *******************************
   107                              <2> 
   108                              <2> ; 81 - Minute time offset (WORD)
   109                              <2> %define CONFIG_TIMEZONE_OFFSET CONFIG(81)
   110                              <2> 
   111                              <2> ; ------------------------------------------------------------------
   112                              <2> ; MUSICAL NOTE FREQUENCY LIST
   113                              <2> 
   114                              <2> A2		equ 110
   115                              <2> AS2		equ 117
   116                              <2> B2		equ 124
   117                              <2> C3		equ 131
   118                              <2> CS3		equ 139
   119                              <2> D3		equ 147
   120                              <2> DS3		equ 156
   121                              <2> E3		equ 165
   122                              <2> F3		equ 175
   123                              <2> FS3		equ 185
   124                              <2> G3		equ 196
   125                              <2> GS3		equ 208
   126                              <2> A3		equ 220
   127                              <2> AS3		equ 233
   128                              <2> B3		equ 247
   129                              <2> C4		equ 262
   130                              <2> CS4		equ 277
   131                              <2> D4		equ 294
   132                              <2> DS4		equ 311
   133                              <2> E4		equ 330
   134                              <2> F4		equ 349
   135                              <2> FS4		equ 370
   136                              <2> G4		equ 392
   137                              <2> GS4		equ 415
   138                              <2> A4		equ 440
   139                              <2> AS4		equ 466
   140                              <2> B4		equ 494
   141                              <2> C5		equ 523
   142                              <2> CS5		equ 554
   143                              <2> D5		equ 587
   144                              <2> DS5		equ 622
   145                              <2> E5		equ 659
   146                              <2> F5		equ 698
   147                              <2> FS5		equ 740
   148                              <2> G5		equ 784
   149                              <2> GS5		equ 831
   150                              <2> A5		equ 880
   151                              <2> AS5		equ 932
   152                              <2> B5		equ 988
   153                              <2> C6		equ 1046
   154                              <2> CS6		equ 1109
   155                              <2> D6		equ 1175
   156                              <2> DS6		equ 1245
   157                              <2> E6		equ 1319
   158                              <2> F6		equ 1397
   159                              <2> FS6		equ 1480
   160                              <2> G6		equ 1568
   161                              <2> GS6		equ 1661
   162                              <2> A6		equ 1760
   163                              <2> AS6		equ 1865
   164                              <2> B6		equ 1976
   165                              <2> C7		equ 2093
   166                              <2> CS7		equ 2217
   167                              <2> D7		equ 2349
   168                              <2> DS7		equ 2489
   169                              <2> E7		equ 2637
   170                              <2> F7		equ 2794
   171                              <2> FS7		equ 2960
   172                              <2> G7		equ 3136
   173                              <2> GS7		equ 3322
   174                              <2> A7		equ 3520
   175                              <2> AS7		equ 3729
   176                              <2> B7		equ 3951
   177                              <2> C8		equ 4186
   178                              <2> CS8		equ 4435
   179                              <2> D8		equ 4699
   180                              <2> DS8		equ 4978
   181                              <2> E8		equ 5274
   182                              <2> F8		equ 5588
   183                              <2> FS8		equ 5920
   184                              <2> G8		equ 6272
   185                              <2> GS8		equ 6645
   186                              <2> A8		equ 7040
   187                              <2> AS8		equ 7459
   188                              <2> B8		equ 7902
     6                              <1> 
     7                              <1> ; -----------------------------------------------------------------
     8                                  
     9                                  ; ------------------------------------------------------------------
    10                                  ; MichalOS memory map:
    11                                  ; Segment 0000h:
    12                                  ;   - 0000h - 03FFh = Interrupt vector table
    13                                  ;   - 0400h - 04FFh = BIOS data area
    14                                  ;   - 0500h - 05FFh = AdLib register buffer
    15                                  ;   - 0600h - 15FFh = Desktop background (BG.ASC)
    16                                  ;   - 1600h - 25FFh = System font (FONT.SYS)
    17                                  ;   - 2600h - 2DFFh = File manager (FILEMAN.APP)
    18                                  ;   - 2E00h - 35FFh = Disk parameter table
    19                                  ; Segment 0360h:
    20                                  ;   - 0000h - 00FFh = System variables
    21                                  ;      - 0000h = RET instruction
    22                                  ;      - 00E0h - 00EFh - parameters for an app (eg. a file to open when an app launches)
    23                                  ;      - 00F0h - 00FFh - temporary buffer for storing apps' filenames
    24                                  ;   - 0100h - 7FFFh = Application
    25                                  ;   - 8000h - DEA7h = MichalOS kernel
    26                                  ;   - DEA8h - DFFFh = Configuration file (SYSTEM.CFG)
    27                                  ;      - config file map described in include/constants.asm
    28                                  ;   - E000h - FFFFh = Disk buffer
    29                                  ; End of memory: 4k-64k bytes stack
    30                                  ; ------------------------------------------------------------------
    31                                  
    32                                  ; ------------------------------------------------------------------
    33                                  ; OS CALL VECTORS
    34                                  
    35                                  os_call_vectors:
    36 00000000 E97A01                  	jmp os_main
    37 00000003 E9E416                  	jmp os_print_string
    38 00000006 E94F17                  	jmp os_move_cursor
    39 00000009 E93117                  	jmp os_clear_screen
    40 0000000C E9B413                  	jmp os_exit
    41 0000000F E9401E                  	jmp os_print_newline
    42 00000012 E97011                  	jmp os_wait_for_key
    43 00000015 E91412                  	jmp os_check_for_key
    44 00000018 E9BF28                  	jmp os_int_to_string
    45 0000001B E99023                  	jmp os_speaker_tone
    46 0000001E E9EF23                  	jmp os_speaker_off
    47 00000021 E9F30A                  	jmp os_load_file
    48 00000024 E90146                  	jmp os_pause
    49 00000027 E9AA1D                  	jmp os_draw_background
    50 0000002A E93E27                  	jmp os_string_length
    51 0000002D E98627                  	jmp os_string_uppercase
    52 00000030 E9A027                  	jmp os_string_lowercase
    53 00000033 E91F20                  	jmp os_input_string
    54 00000036 E9B727                  	jmp os_string_copy
    55 00000039 E9181F                  	jmp os_dialog_box
    56 0000003C E9BA27                  	jmp os_string_join
    57 0000003F E9170A                  	jmp os_get_file_list
    58 00000042 E90828                  	jmp os_string_compare
    59 00000045 E9C727                  	jmp os_string_chomp
    60 00000048 E95928                  	jmp os_string_to_hex
    61 0000004B E97C24                  	jmp os_adlib_regwrite
    62 0000004E E98812                  	jmp os_bcd_to_int
    63 00000051 E9CB28                  	jmp os_get_time_string
    64 00000054 E97C22                  	jmp os_draw_logo
    65 00000057 E94317                  	jmp os_file_selector
    66 0000005A E90D29                  	jmp os_get_date_string
    67 0000005D E94C16                  	jmp os_send_via_serial
    68 00000060 E95D16                  	jmp os_get_via_serial
    69 00000063 E93727                  	jmp os_find_char_in_string
    70 00000066 E9F816                  	jmp os_get_cursor_pos
    71 00000069 E9901F                  	jmp os_print_space
    72 0000006C E9BC22                  	jmp os_option_menu
    73 0000006F E9901F                  	jmp os_print_digit
    74 00000072 E99B1F                  	jmp os_print_1hex
    75 00000075 E99D1F                  	jmp os_print_2hex
    76 00000078 E9A51F                  	jmp os_print_4hex
    77 0000007B E9E945                  	jmp os_set_timer_speed
    78 0000007E E98B09                  	jmp os_report_free_space
    79 00000081 E9D426                  	jmp os_string_add
    80 00000084 E97B23                  	jmp os_speaker_note_length
    81 00000087 E9E616                  	jmp os_show_cursor
    82 0000008A E9EE16                  	jmp os_hide_cursor
    83 0000008D E9CD1D                  	jmp os_dump_registers
    84 00000090 E9C219                  	jmp os_list_dialog_tooltip
    85 00000093 E9740B                  	jmp os_write_file
    86 00000096 E92D0D                  	jmp os_file_exists
    87 00000099 E9390D                  	jmp os_create_file
    88 0000009C E9130E                  	jmp os_remove_file
    89 0000009F E98E0E                  	jmp os_rename_file
    90 000000A2 E9BD0E                  	jmp os_get_file_size
    91 000000A5 E9541E                  	jmp os_input_dialog
    92 000000A8 E9FC19                  	jmp os_list_dialog
    93 000000AB E9CF26                  	jmp os_string_reverse
    94 000000AE E9F027                  	jmp os_string_to_int
    95 000000B1 E9D116                  	jmp os_draw_block
    96 000000B4 E9FB11                  	jmp os_get_random
    97 000000B7 E98C1F                  	jmp os_print_32int
    98 000000BA E9DB15                  	jmp os_serial_port_enable
    99 000000BD E94D28                  	jmp os_sint_to_string
   100 000000C0 E9A127                  	jmp os_string_parse
   101 000000C3 E9052A                  	jmp os_run_basic
   102 000000C6 E9D025                  	jmp os_adlib_calcfreq
   103 000000C9 E96945                  	jmp os_attach_app_timer
   104 000000CC E9E328                  	jmp os_string_tokenize
   105 000000CF E90013                  	jmp os_clear_registers
   106 000000D2 E93716                  	jmp os_format_string
   107 000000D5 E9FB15                  	jmp os_putchar
   108 000000D8 E95423                  	jmp os_start_adlib
   109 000000DB E97445                  	jmp os_return_app_timer
   110 000000DE E9D221                  	jmp os_reset_font
   111 000000E1 E90D16                  	jmp os_print_string_box
   112 000000E4 E9F615                  	jmp os_put_chars
   113 000000E7 E9D946                  	jmp os_draw_line
   114 000000EA E9DD48                  	jmp os_draw_polygon
   115 000000ED E95949                  	jmp os_draw_circle
   116 000000F0 E94A49                  	jmp os_clear_graphics
   117 000000F3 E9970E                  	jmp os_get_file_datetime
   118 000000F6 E93626                  	jmp os_string_encrypt
   119 000000F9 E9AD46                  	jmp os_set_pixel
   120 000000FC E97546                  	jmp os_init_graphics_mode
   121 000000FF E9E921                  	jmp os_draw_icon
   122 00000102 E98323                  	jmp os_stop_adlib
   123 00000105 E90126                  	jmp os_adlib_noteoff
   124 00000108 E97E14                  	jmp os_int_1Ah
   125 0000010B E9E011                  	jmp os_int_to_bcd
   126 0000010E E9114A                  	jmp os_decompress_zx7
   127 00000111 E9ED1D                  	jmp os_password_dialog
   128 00000114 E97324                  	jmp os_adlib_mute
   129 00000117 E91F48                  	jmp os_draw_rectangle
   130 0000011A E94C14                  	jmp os_get_memory
   131 0000011D E9DA1F                  	jmp os_color_selector
   132 00000120 E9E344                  	jmp os_modify_int_handler
   133 00000123 E93C29                  	jmp os_32int_to_string
   134 00000126 E95510                  	jmp os_get_boot_disk
   135 00000129 E9FE1E                  	jmp os_print_8hex
   136 0000012C E96429                  	jmp os_string_to_32int
   137 0000012F E9D011                  	jmp os_math_power
   138 00000132 E90B12                  	jmp os_math_root
   139 00000135 E9241F                  	jmp os_input_password
   140 00000138 E9DD44                  	jmp os_get_int_handler
   141 0000013B E9D212                  	jmp os_get_os_name
   142 0000013E E97A20                  	jmp os_temp_box
   143 00000141 E96F24                  	jmp os_adlib_unmute
   144 00000144 E93D4B                  	jmp os_disk_read_sector
   145 00000147 E94446                  	jmp os_init_text_mode
   146 0000014A E9664B                  	jmp os_disk_write_sector
   147 0000014D E9E91E                  	jmp os_print_int
   148 00000150 E9484B                  	jmp os_disk_read_multiple_sectors
   149 00000153 E98B22                  	jmp os_speaker_raw_period
   150 00000156 E9661A                  	jmp os_select_list
   151 00000159 E99719                  	jmp os_list_dialog_ex
   152 0000015C E96D4B                  	jmp os_disk_write_multiple_sectors
   153 0000015F E9061F                  	jmp os_input_string_ex
   154 00000162 E93D16                  	jmp os_file_selector_filtered
   155 00000165 E9C022                  	jmp os_speaker_muted
   156 00000168 E96028                  	jmp os_string_callback_tokenizer
   157 0000016B E9F51E                  	jmp os_set_max_input_length
   158 0000016E E92312                  	jmp os_read_config_byte
   159 00000171 E92612                  	jmp os_read_config_word
   160 00000174 E92912                  	jmp os_write_config_byte
   161 00000177 E92C12                  	jmp os_write_config_word
   162 0000017A E92F12                  	jmp os_save_config
   163                                  
   164                                  ; ------------------------------------------------------------------
   165                                  ; START OF MAIN KERNEL CODE
   166                                  
   167                                  os_main:
   168 0000017D CD12                    	int 12h						; Get RAM size
   169 0000017F 48                      	dec ax						; Some BIOSes round up, so we have to sacrifice 1 kB :(
   170 00000180 C1E006                  	shl ax, 6					; Convert kB to segments
   171                                  
   172 00000183 BB0001                  	mov bx, 256					; Set up a 4 kB stack - good enough for now
   173                                  
   174 00000186 BE[8C01]                	mov si, first_init_stack_done
   175 00000189 E9FA14                  	jmp int_set_stack
   176                                  
   177                                  first_init_stack_done:
   178 0000018C 8CC8                    	mov ax, cs					; Set all segments to match where kernel is loaded
   179 0000018E 8ED8                    	mov ds, ax
   180 00000190 8EC0                    	mov es, ax
   181 00000192 6A00                    	push word 0
   182 00000194 0FA1                    	pop fs
   183 00000196 050010                  	add ax, 1000h
   184 00000199 8EE8                    	mov gs, ax
   185                                  	
   186 0000019B 8816[8411]              	mov [bootdev], dl			; Save boot device number
   187                                  
   188 0000019F B90080                  	mov cx, 0x8000
   189                                  	clr di
    31 000001A2 31FF                <1>  xor %1, %1
   190                                  	clr al
    31 000001A4 30C0                <1>  xor %1, %1
   191 000001A6 F3AA                    	rep stosb
   192                                  
   193 000001A8 C6060000C3              	mov byte [0000h], 0xC3
   194                                  ;	mov byte [00E0h], 0
   195                                  
   196                                  	; Clear the disk params table
   197                                  
   198 000001AD 06                      	push es
   199                                  	movs es, fs
    39 000001AE 0FA0                <1>  push %2
    40 000001B0 07                  <1>  pop %1
   200 000001B1 BF002E                  	mov di, DISK_PARAMS
   201 000001B4 B0FF                    	mov al, 0FFh
   202 000001B6 B90008                  	mov cx, 8 * 256
   203 000001B9 F3AA                    	rep stosb
   204 000001BB 07                      	pop es
   205                                  
   206                                  	; Load the files
   207                                  	
   208 000001BC C606F1DE01              	mov byte [CONFIG_FONT], CFG_FONT_BIOS		; If a fatal error occurs, use the default BIOS font
   209                                  
   210 000001C1 06                      	push es
   211                                  	movs es, fs
    39 000001C2 0FA0                <1>  push %2
    40 000001C4 07                  <1>  pop %1
   212                                  	
   213 000001C5 B8[C103]                	mov ax, fileman_name
   214 000001C8 B90026                  	mov cx, FILE_MANAGER
   215 000001CB E84909                  	call os_load_file
   216                                  	
   217 000001CE 0F82BE01                	jc systemfilemissing
   218                                  
   219 000001D2 B8[EE03]                	mov ax, bg_name
   220 000001D5 B90006                  	mov cx, DESKTOP_BACKGROUND
   221 000001D8 E83C09                  	call os_load_file
   222 000001DB 7305                    	jnc .background_ok
   223                                  	
   224 000001DD C606000600              	mov byte [DESKTOP_BACKGROUND], 0
   225                                  	
   226                                  .background_ok:	
   227 000001E2 B8[E503]                	mov ax, font_name
   228 000001E5 B90016                  	mov cx, SYSTEM_FONT
   229 000001E8 E82C09                  	call os_load_file
   230                                  
   231 000001EB 0F82A101                	jc systemfilemissing
   232 000001EF 07                      	pop es
   233                                  	
   234 000001F0 B8[DA03]                	mov ax, system_cfg			; Try to load SYSTEM.CFG
   235 000001F3 B9A8DE                  	mov cx, CONFIG_FILE
   236 000001F6 E81E09                  	call os_load_file
   237                                  
   238 000001F9 9C                      	pushf
   239                                  
   240 000001FA FA                      	cli
   241                                  
   242 000001FB 8CCF                    	mov di, cs
   243                                  
   244                                  	clr cl						; Divide by 0 error handler
    31 000001FD 30C9                <1>  xor %1, %1
   245 000001FF BE[9746]                	mov si, os_compat_int00
   246 00000202 E80144                  	call os_modify_int_handler
   247                                  
   248 00000205 B106                    	mov cl, 06h					; Bad instruction error handler
   249 00000207 BE[B946]                	mov si, os_compat_int06
   250 0000020A E8F943                  	call os_modify_int_handler
   251                                  
   252 0000020D B107                    	mov cl, 07h					; Processor extension error handler
   253 0000020F BE[D346]                	mov si, os_compat_int07
   254 00000212 E8F143                  	call os_modify_int_handler
   255                                  
   256 00000215 B140                    	mov cl, 40h					; Far API call handler
   257 00000217 BE[5347]                	mov si, os_farcall_handler
   258 0000021A E8E943                  	call os_modify_int_handler
   259                                  
   260 0000021D FB                      	sti
   261                                  	
   262 0000021E E83144                  	call os_return_app_timer	; Also sets up RTC handler
   263                                  	clr cx
    31 00000221 31C9                <1>  xor %1, %1
   264 00000223 E84144                  	call os_set_timer_speed
   265                                  	
   266 00000226 B80503                  	mov ax, 0305h
   267 00000229 BB0401                  	mov bx, 0104h
   268 0000022C CD16                    	int 16h
   269                                  	
   270 0000022E A0EDDE                  	mov al, [CONFIG_SOUND_ENABLED]				; Copy the default sound volume (on/off)
   271 00000231 A2[E023]                	mov [speaker_unmuted], al
   272                                  	
   273 00000234 9D                      	popf
   274 00000235 730E                    	jnc no_load_demotour		; If loading SYSTEM.CFG failed, it doesn't exist, so the system was started for the first time
   275                                  	
   276 00000237 C606[E023]01            	mov byte [speaker_unmuted], 1
   277 0000023C B8[CD03]                	mov ax, demotour_name
   278 0000023F E88600                  	call load_program_file
   279 00000242 E8AB00                  	call run_binary_program
   280                                  
   281                                  no_load_demotour:
   282 00000245 E84645                  	call os_init_text_mode
   283                                  
   284 00000248 CD12                    	int 12h						; Get RAM size
   285 0000024A 48                      	dec ax						; Some BIOSes round up, so we have to sacrifice 1 kB :(
   286 0000024B C1E006                  	shl ax, 6					; Convert kB to segments
   287                                  
   288 0000024E 8B1EF3DE                	mov bx, [CONFIG_STACKSGMT_SIZE]				; Set up the proper stack according to the config file
   289                                  
   290 00000252 81FB0001                	cmp bx, 256
   291 00000256 720C                    	jb second_init_stack_done
   292                                  
   293 00000258 81FB0010                	cmp bx, 4096
   294 0000025C 7706                    	ja second_init_stack_done
   295                                  
   296 0000025E BE[6402]                	mov si, second_init_stack_done
   297 00000261 E92214                  	jmp int_set_stack
   298                                  
   299                                  second_init_stack_done:
   300                                  	clr ax
    31 00000264 31C0                <1>  xor %1, %1
   301                                  
   302                                  start_desktop:
   303 00000266 BE[0904]                	mov si, desktop_data		; Start the desktop!
   304 00000269 E81911                  	call os_run_zx7_module
   305                                  
   306                                  	; Possible return values: AX = 0 for starting the file manager, AX = (valid ptr) for starting an application
   307                                  
   308 0000026C 85C0                    	test ax, ax
   309 0000026E 0F840901                	jz load_fileman
   310                                  
   311                                  launch_program:
   312 00000272 85C0                    	test ax, ax				; If an application returns a non-valid ptr, ignore it
   313 00000274 0F84FD00                	jz checkformenu
   314                                  
   315 00000278 60                      	pusha
   316 00000279 89C6                    	mov si, ax
   317 0000027B E8ED24                  	call os_string_length
   318 0000027E 01C6                    	add si, ax				; SI now points to end of filename
   319 00000280 B90300                  	mov cx, 3
   320 00000283 29CE                    	sub si, cx
   321 00000285 BF[B903]                	mov di, app_ext
   322 00000288 F3A6                    	rep cmpsb				; Are final 3 chars 'APP'?
   323 0000028A 750A                    	jne launch_basic		; If not, try 'BAS'
   324 0000028C 61                      	popa
   325                                  	
   326 0000028D E83800                  	call load_program_file
   327 00000290 E85D00                  	call run_binary_program
   328                                  
   329 00000293 E9DF00                  	jmp checkformenu
   330                                  
   331                                  launch_basic:
   332 00000296 61                      	popa
   333 00000297 60                      	pusha
   334 00000298 89C6                    	mov si, ax
   335 0000029A E8CE24                  	call os_string_length
   336 0000029D 01C6                    	add si, ax				; SI now points to end of filename
   337 0000029F B90300                  	mov cx, 3
   338 000002A2 29CE                    	sub si, cx
   339 000002A4 BF[BD03]                	mov di, bas_ext
   340 000002A7 F3A6                    	rep cmpsb				; Are final 3 chars 'BAS'?
   341 000002A9 0F85C100                	jne program_error		; If not, error out
   342 000002AD 61                      	popa
   343                                  
   344 000002AE E81700                  	call load_program_file
   345 000002B1 E8BC14                  	call os_show_cursor
   346                                  
   347 000002B4 B80001                  	mov ax, 100h
   348                                  	clr si
    31 000002B7 31F6                <1>  xor %1, %1
   349 000002B9 E80F28                  	call os_run_basic
   350                                  
   351 000002BC BE[F503]                	mov si, basic_finished_msg
   352 000002BF E82814                  	call os_print_string
   353 000002C2 E8C00E                  	call os_wait_for_key
   354                                  
   355 000002C5 E9AD00                  	jmp checkformenu
   356                                  
   357                                  load_program_file:
   358 000002C8 B90001                  	mov cx, 100h			; Where to load the program file
   359 000002CB E84908                  	call os_load_file		; Load filename pointed to by AX
   360                                  
   361 000002CE 0F82BE00                	jc systemfilemissing
   362                                  
   363 000002D2 60                      	pusha
   364 000002D3 B9FD7E                  	mov cx, 7EFDh
   365 000002D6 29D9                    	sub cx, bx
   366 000002D8 BF0001                  	mov di, 100h
   367 000002DB 01DF                    	add di, bx
   368                                  	clr al
    31 000002DD 30C0                <1>  xor %1, %1
   369 000002DF F3AA                    	rep stosb
   370 000002E1 61                      	popa
   371 000002E2 C3                      	ret
   372                                  
   373                                  return_to_app:
   374 000002E3 B8F000                  	mov ax, 00F0h
   375 000002E6 B90001                  	mov cx, 100h			; Where to load the program file
   376 000002E9 E82B08                  	call os_load_file		; Load filename pointed to by AX
   377                                  
   378 000002EC 0F82A000                	jc systemfilemissing	
   379                                  
   380                                  run_binary_program:
   381                                  	; Detect binary header version
   382                                  	
   383 000002F0 803E0001C3              	cmp byte [100h], 0xC3	; Old headerless binaries
   384 000002F5 751C                    	jne start_binary
   385                                  
   386 000002F7 66813E01014D694F53      	cmp dword [101h], 'MiOS'; File magic
   387 00000300 7511                    	jne start_binary
   388                                  
   389                                  	; MichalOS version 1 executable was loaded
   390                                  
   391 00000302 8B0E0601                	mov cx, [106h]			; File size
   392 00000306 BE0801                  	mov si, 108h
   393                                  
   394 00000309 0FBA26050100            	bt word [105h], 0		; Was it compressed?
   395 0000030F 7345                    	jnc load_binary_no_compression
   396 00000311 724A                    	jc load_binary_decompress
   397                                  
   398                                  start_binary:
   399 00000313 E82714                  	call os_clear_screen	; Clear the screen before running
   400                                  	
   401 00000316 C606[6809]01            	mov byte [app_running], 1
   402 0000031B C606[D113]00            	mov byte [app_exit_special], 0
   403                                  
   404 00000320 8926[6609]              	mov [origstack], sp
   405                                  	
   406 00000324 E8AB10                  	call os_clear_registers
   407                                  	
   408 00000327 E8(0001)                	call 100h	
   409                                  	
   410                                  finish:
   411 0000032A C606[6809]00            	mov byte [app_running], 0
   412                                  	
   413 0000032F E85621                  	call os_stop_adlib		; Reset everything (in case the app crashed or something)
   414 00000332 E81D43                  	call os_return_app_timer
   415 00000335 E8D820                  	call os_speaker_off
   416                                  
   417 00000338 FB                      	sti
   418                                  
   419 00000339 60                      	pusha
   420 0000033A 8CC8                    	mov ax, cs
   421 0000033C 8ED8                    	mov ds, ax
   422 0000033E 8EC0                    	mov es, ax
   423                                  
   424 00000340 B40F                    	mov ah, 0Fh				; Get the current video mode
   425 00000342 CD10                    	int 10h
   426                                  	
   427 00000344 3C03                    	cmp al, 3
   428 00000346 7403                    	je .skip_gfx
   429                                  	
   430 00000348 E84344                  	call os_init_text_mode
   431                                  
   432                                  .skip_gfx:
   433 0000034B 61                      	popa
   434                                  	
   435 0000034C 803E[D113]01            	cmp byte [app_exit_special], 1
   436 00000351 0F841DFF                	je launch_program
   437 00000355 C3                      	ret
   438                                  
   439                                  load_binary_no_compression:
   440 00000356 BF0001                  	mov di, 100h
   441 00000359 F3A4                    	rep movsb
   442 0000035B EBB6                    	jmp start_binary
   443                                  
   444                                  load_binary_decompress:
   445 0000035D BF0080                  	mov di, 8000h
   446 00000360 29CF                    	sub di, cx
   447                                  
   448 00000362 57                      	push di
   449 00000363 F3A4                    	rep movsb
   450 00000365 5E                      	pop si
   451                                  
   452 00000366 BF0001                  	mov di, 100h
   453 00000369 E8B647                  	call os_decompress_zx7
   454                                  
   455 0000036C EBA5                    	jmp start_binary
   456                                  
   457                                  program_error:
   458 0000036E 61                      	popa
   459 0000036F B80200                  	mov ax, 2
   460 00000372 E9F1FE                  	jmp start_desktop
   461                                  	
   462                                  checkformenu:
   463 00000375 B80100                  	mov ax, 1
   464 00000378 E9EBFE                  	jmp start_desktop
   465                                  
   466                                  load_fileman:
   467 0000037B 1E                      	push ds
   468                                  	movs ds, fs
    39 0000037C 0FA0                <1>  push %2
    40 0000037E 1F                  <1>  pop %1
   469 0000037F BE0026                  	mov si, FILE_MANAGER
   470 00000382 BF0001                  	mov di, 0100h
   471 00000385 B90010                  	mov cx, 1000h
   472 00000388 F3A4                    	rep movsb
   473 0000038A 1F                      	pop ds
   474 0000038B E862FF                  	call run_binary_program
   475 0000038E EBE5                    	jmp checkformenu
   476                                  
   477                                  systemfilemissing:
   478                                  	movs es, cs
    39 00000390 0E                  <1>  push %2
    40 00000391 07                  <1>  pop %1
   479 00000392 BB[A003]                	mov bx, noprogerror
   480 00000395 B90040                  	mov cx, 4000h
   481 00000398 E85E24                  	call os_string_join
   482                                  
   483 0000039B 89C8                    	mov ax, cx
   484 0000039D E88710                  	call os_fatal_error
   485                                  	
   486                                  	; And now data for the above code...
   487                                  
   488 000003A0 202D2053797374656D-     	noprogerror				db ' - System file not found', 0
   488 000003A9 2066696C65206E6F74-
   488 000003B2 20666F756E6400     
   489                                  	
   490 000003B9 41505000                	app_ext					db 'APP', 0
   491 000003BD 42415300                	bas_ext					db 'BAS', 0
   492                                  
   493 000003C1 46494C454D414E2E41-     	fileman_name			db 'FILEMAN.APP', 0
   493 000003CA 505000             
   494 000003CD 44454D4F544F55522E-     	demotour_name			db 'DEMOTOUR.APP', 0
   494 000003D6 41505000           
   495 000003DA 53595354454D2E4346-     	system_cfg				db 'SYSTEM.CFG', 0
   495 000003E3 4700               
   496 000003E5 464F4E542E53595300      	font_name				db 'FONT.SYS', 0
   497 000003EE 42472E53595300          	bg_name					db 'BG.SYS', 0
   498                                  	
   499 000003F5 42415349432070726F-     	basic_finished_msg		db 'BASIC program ended', 0
   499 000003FE 6772616D20656E6465-
   499 00000407 6400               
   500                                  
   501 00000409 <bin 55Dh>              	desktop_data incbin "sub_desktop.zx7"
   502                                  
   503                                  ; ------------------------------------------------------------------
   504                                  ; SYSTEM VARIABLES -- Settings for programs and system calls
   505                                  
   506                                  	; System runtime variables
   507                                  								
   508 00000966 0000                    	origstack		dw 0		; SP before launching a program
   509                                  
   510 00000968 00                      	app_running		db 0		; Is a program running?
   511                                  	
   512 00000969 00                      	system_ui_state	db 0		; 0 if a GUI application is running
   513                                  								; 1 if a non-GUI application is running (no header/footer)
   514                                  
   515                                  ;	program_drawn	db 0		; Is the program already drawn by os_draw_background?
   516                                  	
   517                                  ; ------------------------------------------------------------------
   518                                  ; FEATURES -- Code to pull into the kernel
   519                                  
   520                                  	%INCLUDE "features/icons.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Icons
     3                              <1> ; ==================================================================
     4                              <1> 
     5 0000096A 0408                <1> 	filelogo	db 4, 8
     6 0000096C 0EAAD000            <1> 				db 00001110b, 10101010b, 11010000b, 00000000b
     7 00000970 0C00C900            <1> 				db 00001100b, 00000000b, 11001001b, 00000000b
     8 00000974 0C00AAC0            <1> 				db 00001100b, 00000000b, 10101010b, 11000000b
     9 00000978 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
    10 0000097C 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
    11 00000980 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
    12 00000984 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
    13 00000988 0D5555C0            <1> 				db 00001101b, 01010101b, 01010101b, 11000000b
    14                              <1> 	
    15 0000098C 1207                <1> 	logo		db 18, 7
    16 0000098E 00000EEAAAAC400400- <1> 				db 00000000b, 00000000b, 00001110b, 11101010b, 10101010b, 10101100b, 01000000b, 00000100b, 00000000b, 00000000b, 01000000b, 00000000b, 	00000000b, 00010011b, 11101010b, 10111111b, 10101010b, 10110000b
    16 00000997 0040000013EABFAAB0  <1>
    17 000009A0 00000CEAAAECE46C00- <1> 				db 00000000b, 00000000b, 00001100b, 11101010b, 10101010b, 11101100b, 11100100b, 01101100b, 00000000b, 00000000b, 11000000b, 00000000b, 00000000b, 00110011b, 00111111b, 11001100b, 11111111b, 11110000b
    17 000009A9 00C00000333FCCFFF0  <1>
    18 000009B2 00000CC000CCC20C80- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000010b, 00001100b, 10000000b, 00000000b, 11000000b, 00000000b, 00000000b, 00110011b, 00111111b, 11001100b, 11111111b, 11110000b
    18 000009BB 00C00000333FCCFFF0  <1>
    19 000009C4 00000CC000CCC00CC6- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000000b, 00001100b, 11000110b, 10101000b, 11011010b, 10010010b, 10101001b, 00110011b, 00111111b, 11001111b, 01010101b, 10110000b
    19 000009CD A8DA92A9333FCF55B0  <1>
    20 000009D6 00000CC000CCC00CCC- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000000b, 00001100b, 11001100b, 00000000b, 11000000b, 00110001b, 10101011b, 00110011b, 00111111b, 11001111b, 11111111b, 00110000b
    20 000009DF 00C031AB333FCFFF30  <1>
    21 000009E8 00000EAAAACCC00CC9- <1> 				db 00000000b, 00000000b, 00001110b, 10101010b, 10101010b, 11001100b, 11000000b, 00001100b, 11001001b, 01010100b, 11000000b, 00110010b, 01010110b, 00110011b, 01101010b, 10011110b, 10101010b, 01110000b
    21 000009F1 54C03256336A9EAA70  <1>
    22 000009FA 00000AAAAAA8000000- <1> 				db 00000000b, 00000000b, 00001010b, 10101010b, 10101010b, 10101000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000010b, 10101010b, 10101010b, 10101010b, 10100000b
    22 00000A03 0000000002AAAAAAA0  <1>
    23                              <1> 			
    24                              <1> ; ==================================================================
   521                                   	%INCLUDE "features/disk.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Disk access functions
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; os_report_free_space -- Returns the amount of free space on disk
     7                              <1> ; IN: None
     8                              <1> ; OUT: AX = Number of sectors free
     9                              <1> 
    10                              <1> os_report_free_space:
    11 00000A0C 60                  <1> 	pusha
    12 00000A0D C706[550A]0000      <1> 	mov word [.counter], 0
    13 00000A13 C706[570A]0000      <1> 	mov word [.sectors_read], 0
    14                              <1> 	
    15 00000A19 E8F606              <1> 	call int_read_fat				; Read the FAT into memory
    16 00000A1C BE00E0              <1> 	mov si, DISK_BUFFER
    17                              <1> 	
    18                              <1> .loop:
    19                              <1> 	; 0 = nothing, 1 = 1st nibble, 2 = 2nd nibble, 3 = 3rd nibble, G = data we don't care about
    20                              <1> 
    21 00000A1F 8B04                <1> 	mov ax, [si]					; AX = 3333GGGG11112222
    22 00000A21 8A7C01              <1> 	mov bh, [si + 1]				; BX = GGGG111122223333
    23 00000A24 8A5C02              <1> 	mov bl, [si + 2]
    24                              <1> 	
    25 00000A27 C1C004              <1> 	rol ax, 4						; AX = GGGG111122223333
    26                              <1> 	
    27 00000A2A 80E40F              <1> 	and ah, 0Fh						; AX = 0000111122223333
    28 00000A2D 80E70F              <1> 	and bh, 0Fh						; BX = 0000111122223333
    29                              <1> 		
    30 00000A30 85C0                <1> 	test ax, ax
    31 00000A32 7504                <1> 	jnz .no_increment_1
    32                              <1> 	
    33 00000A34 FF06[550A]          <1> 	inc word [.counter]
    34                              <1> 	
    35                              <1> .no_increment_1:
    36 00000A38 85DB                <1> 	test bx, bx
    37 00000A3A 7504                <1> 	jnz .no_increment_2
    38                              <1> 	
    39 00000A3C FF06[550A]          <1> 	inc word [.counter]
    40                              <1> 	
    41                              <1> .no_increment_2:
    42 00000A40 83C603              <1> 	add si, 3						; Increment the pointer
    43 00000A43 8306[570A]02        <1> 	add word [.sectors_read], 2		; Increment the counter of sectors
    44                              <1> 	
    45 00000A48 813E[570A]1F0B      <1> 	cmp word [.sectors_read], 2847	; Are we done? (33 of the sectors are the bootloader, FAT and root dir)
    46 00000A4E 7CCF                <1> 	jl .loop
    47                              <1> 	
    48 00000A50 61                  <1> 	popa
    49 00000A51 A1[550A]            <1> 	mov ax, [.counter]
    50                              <1> 
    51 00000A54 C3                  <1> 	ret
    52                              <1> 	
    53 00000A55 0000                <1> 	.counter		dw 0
    54 00000A57 0000                <1> 	.sectors_read	dw 0
    55                              <1> 
    56                              <1> ; ------------------------------------------------------------------
    57                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
    58                              <1> ; IN/OUT: AX = location to store zero-terminated filename string
    59                              <1> 
    60                              <1> os_get_file_list:
    61 00000A59 60                  <1> 	pusha
    62                              <1> 
    63 00000A5A C606[E20A]00        <1> 	mov byte [.num_entries], 0
    64 00000A5F 891E[E30A]          <1> 	mov [.extension_list], bx
    65                              <1> 	
    66 00000A63 E88617              <1> 	call int_save_footer
    67 00000A66 7206                <1> 	jc .no_msg
    68                              <1> 
    69 00000A68 BE[E70A]            <1> 	mov si, .msg_load
    70 00000A6B E87C0C              <1> 	call os_print_string
    71                              <1> 
    72                              <1> .no_msg:
    73 00000A6E A3[E50A]            <1> 	mov word [.file_list_tmp], ax
    74                              <1> 
    75 00000A71 E8D406              <1> 	call int_read_root_dir
    76 00000A74 7306                <1> 	jnc .show_dir_init		; No errors, continue
    77                              <1> 
    78 00000A76 B8[050B]            <1> 	mov ax, floppyreseterror
    79 00000A79 E8AB09              <1> 	call os_fatal_error
    80                              <1> 	
    81                              <1> .show_dir_init:
    82                              <1> 	clr ax
    31 00000A7C 31C0                <2>  xor %1, %1
    83 00000A7E BE00E0              <1> 	mov si, DISK_BUFFER		; Data reader from start of filenames
    84                              <1> 
    85 00000A81 8B3E[E50A]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
    86                              <1> 
    87                              <1> 
    88                              <1> .start_entry:
    89 00000A85 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
    90 00000A88 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
    91 00000A8A 7440                <1> 	je .skip
    92                              <1> 
    93 00000A8C A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
    94 00000A8E 753C                <1> 	jnz .skip			; Yes, ignore it
    95                              <1> 
    96 00000A90 8A04                <1> 	mov al, [si]
    97 00000A92 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
    98 00000A94 7436                <1> 	je .skip
    99                              <1> 
   100 00000A96 84C0                <1> 	test al, al			; 1st byte = entry never used
   101 00000A98 7437                <1> 	jz .done
   102                              <1> 	
   103 00000A9A B90100              <1> 	mov cx, 1			; Set char counter
   104 00000A9D 89F2                <1> 	mov dx, si			; Beginning of possible entry
   105                              <1> 
   106                              <1> .testdirentry:
   107 00000A9F 46                  <1> 	inc si
   108 00000AA0 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   109 00000AA2 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   110 00000AA4 7C24                <1> 	jl .nxtdirentry
   111 00000AA6 3C7E                <1> 	cmp al, '~'
   112 00000AA8 7720                <1> 	ja .nxtdirentry
   113                              <1> 
   114 00000AAA 41                  <1> 	inc cx
   115 00000AAB 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
   116 00000AAE 7402                <1> 	je .gotfilename
   117 00000AB0 EBED                <1> 	jmp .testdirentry
   118                              <1> 
   119                              <1> 
   120                              <1> .gotfilename:				; Got a filename that passes testing
   121 00000AB2 89D0                <1> 	mov ax, dx			; DX = where getting string
   122 00000AB4 E80805              <1> 	call int_filename_deconvert
   123                              <1> 
   124 00000AB7 89C6                <1> 	mov si, ax
   125 00000AB9 E8341D              <1> 	call os_string_copy
   126 00000ABC E8AC1C              <1> 	call os_string_length
   127 00000ABF 01C7                <1> 	add di, ax
   128                              <1> 
   129 00000AC1 26C6052C            <1> 	mov byte [es:di], ','		; Use comma to separate filenames
   130 00000AC5 47                  <1> 	inc di
   131 00000AC6 FE06[E20A]          <1> 	inc byte [.num_entries]
   132                              <1> 	
   133                              <1> .nxtdirentry:
   134 00000ACA 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
   135                              <1> 
   136                              <1> .skip:
   137 00000ACC 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
   138 00000ACF EBB4                <1> 	jmp .start_entry
   139                              <1> 
   140                              <1> 
   141                              <1> .done:
   142 00000AD1 803E[E20A]00        <1> 	cmp byte [.num_entries], 0
   143 00000AD6 7401                <1> 	je .no_dec
   144                              <1> 	
   145 00000AD8 4F                  <1> 	dec di
   146                              <1> 
   147                              <1> .no_dec:
   148 00000AD9 26C60500            <1> 	mov byte [es:di], 0		; Zero-terminate string (gets rid of final comma)
   149                              <1> 
   150 00000ADD E85417              <1> 	call int_restore_footer
   151                              <1> 
   152 00000AE0 61                  <1> 	popa
   153                              <1> 
   154 00000AE1 C3                  <1> 	ret
   155                              <1> 
   156 00000AE2 00                  <1> 	.num_entries		db 0
   157 00000AE3 0000                <1> 	.extension_list		dw 0
   158 00000AE5 0000                <1> 	.file_list_tmp		dw 0
   159 00000AE7 52656164696E672064- <1> 	.msg_load			db 'Reading directory contents...', 0
   159 00000AF0 69726563746F727920- <1>
   159 00000AF9 636F6E74656E74732E- <1>
   159 00000B02 2E2E00              <1>
   160 00000B05 466C6F707079207265- <1> 	floppyreseterror	db 'Floppy reset fail', 0
   160 00000B0E 736574206661696C00  <1>
   161                              <1> 	
   162                              <1> ; ------------------------------------------------------------------
   163                              <1> ; os_load_file -- Load a file into RAM
   164                              <1> ; IN: AX = location of filename, ES:CX = location in RAM to load file
   165                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
   166                              <1> 
   167                              <1> os_load_file:
   168 00000B17 6660                <1> 	pushad
   169 00000B19 06                  <1> 	push es
   170 00000B1A 8C06[FF0B]          <1> 	mov [.old_segment], es
   171                              <1> 
   172                              <1> 	movs es, cs
    39 00000B1E 0E                  <2>  push %2
    40 00000B1F 07                  <2>  pop %1
   173                              <1> 	
   174 00000B20 E8931C              <1> 	call os_string_uppercase
   175                              <1> 
   176 00000B23 E8C616              <1> 	call int_save_footer			; Message display routine
   177 00000B26 720B                <1> 	jc .no_msg
   178                              <1> 
   179 00000B28 BE[010C]            <1> 	mov si, .msg_load
   180 00000B2B E8BC0B              <1> 	call os_print_string
   181 00000B2E 89C6                <1> 	mov si, ax
   182 00000B30 E8B70B              <1> 	call os_print_string
   183                              <1> 
   184                              <1> .no_msg:
   185 00000B33 E8F104              <1> 	call int_filename_convert
   186                              <1> 
   187 00000B36 A3[F70B]            <1> 	mov [.filename_loc], ax		; Store filename location
   188 00000B39 890E[F90B]          <1> 	mov [.load_position], cx	; And where to load the file!
   189                              <1> 
   190 00000B3D E80806              <1> 	call int_read_root_dir
   191 00000B40 7237                <1> 	jc .root_problem
   192                              <1> 
   193                              <1> .search_root_dir:
   194 00000B42 B9E000              <1> 	mov cx, 224		; Search all entries in root dir
   195 00000B45 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
   196                              <1> 
   197                              <1> .next_root_entry:
   198 00000B48 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
   199 00000B4B BF00E0              <1> 	mov di, DISK_BUFFER		; Point root dir at next entry
   200 00000B4E 01DF                <1> 	add di, bx
   201                              <1> 
   202 00000B50 8A05                <1> 	mov al, [di]			; First character of name
   203                              <1> 
   204 00000B52 84C0                <1> 	test al, al			; Last file name already checked?
   205 00000B54 7423                <1> 	jz .root_problem
   206                              <1> 
   207 00000B56 3CE5                <1> 	cmp al, 229			; Was this file deleted?
   208 00000B58 74EE                <1> 	je .next_root_entry		; If yes, skip it
   209                              <1> 
   210 00000B5A 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
   211                              <1> 
   212 00000B5D 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
   213 00000B5F 74E7                <1> 	je .next_root_entry
   214                              <1> 
   215 00000B61 A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   216 00000B63 75E3                <1> 	jnz .next_root_entry
   217                              <1> 
   218 00000B65 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
   219                              <1> 
   220 00000B69 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
   221 00000B6B E8481C              <1> 	call os_string_uppercase
   222                              <1> 
   223 00000B6E 8B36[F70B]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
   224                              <1> 
   225 00000B72 E8D81C              <1> 	call os_string_compare		; Current entry same as requested?
   226 00000B75 720C                <1> 	jc .found_file_to_load
   227                              <1> 
   228 00000B77 E2CF                <1> 	loop .next_root_entry
   229                              <1> 
   230                              <1> .root_problem:
   231 00000B79 07                  <1> 	pop es
   232 00000B7A 6661                <1> 	popad
   233                              <1> 	clr bx			; If file not found or major disk error,
    31 00000B7C 31DB                <2>  xor %1, %1
   234                              <1> 
   235 00000B7E E8B316              <1> 	call int_restore_footer
   236                              <1> 
   237 00000B81 F9                  <1> 	stc				; return with size = 0 and carry set
   238 00000B82 C3                  <1> 	ret
   239                              <1> 
   240                              <1> 
   241                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
   242 00000B83 668B451C            <1> 	mov eax, [di+28]			; Store file size to return to calling routine
   243 00000B87 66A3[FB0B]          <1> 	mov [.file_size], eax
   244                              <1> 
   245 00000B8B 6685C0              <1> 	test eax, eax			; If the file size is zero, don't bother trying
   246 00000B8E 7458                <1> 	jz .end				; to read more clusters
   247                              <1> 
   248 00000B90 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
   249 00000B93 A3[F50B]            <1> 	mov word [.cluster], ax
   250                              <1> 
   251 00000B96 E87905              <1> 	call int_read_fat
   252 00000B99 72DE                <1> 	jc .root_problem
   253                              <1> 
   254                              <1> .load_file_sector:
   255 00000B9B 660FB706[F50B]      <1> 	movzx eax, word [.cluster]		; Convert sector to logical
   256 00000BA1 6683C01F            <1> 	add eax, 31
   257                              <1> 
   258 00000BA5 8B36[F90B]          <1> 	mov si, [.load_position]
   259 00000BA9 8E06[FF0B]          <1> 	mov es, [.old_segment]
   260 00000BAD 8A16[8411]          <1> 	mov dl, [bootdev]
   261                              <1> 
   262 00000BB1 E8D040              <1> 	call os_disk_read_sector
   263                              <1> 
   264                              <1> 	movs es, cs
    39 00000BB4 0E                  <2>  push %2
    40 00000BB5 07                  <2>  pop %1
   265                              <1> 	
   266 00000BB6 72C1                <1> 	jc .root_problem
   267                              <1> 
   268                              <1> 
   269                              <1> .calculate_next_cluster:
   270 00000BB8 A1[F50B]            <1> 	mov ax, [.cluster]
   271 00000BBB BB0300              <1> 	mov bx, 3
   272 00000BBE F7E3                <1> 	mul bx
   273 00000BC0 BB0200              <1> 	mov bx, 2
   274 00000BC3 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
   275 00000BC5 BE00E0              <1> 	mov si, DISK_BUFFER		; AX = word in FAT for the 12 bits
   276 00000BC8 01C6                <1> 	add si, ax
   277 00000BCA 3E8B04              <1> 	mov ax, word [ds:si]
   278                              <1> 
   279 00000BCD 85D2                <1> 	test dx, dx			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
   280 00000BCF 7405                <1> 	jz .even			; If [CLUSTER] = even, drop last 4 bits of word
   281                              <1> 					; with next cluster; if odd, drop first 4 bits
   282                              <1> 
   283                              <1> .odd:
   284 00000BD1 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
   285 00000BD4 EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   286                              <1> 
   287                              <1> .even:
   288 00000BD6 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
   289                              <1> 
   290                              <1> .calculate_cluster_cont:
   291 00000BD9 A3[F50B]            <1> 	mov word [.cluster], ax		; Store cluster
   292                              <1> 
   293 00000BDC 3DF80F              <1> 	cmp ax, 0FF8h
   294 00000BDF 7D07                <1> 	jge .end
   295                              <1> 
   296 00000BE1 8306[FF0B]20        <1> 	add word [.old_segment], 512 / 16
   297 00000BE6 EBB3                <1> 	jmp .load_file_sector		; Onto next sector!
   298                              <1> 
   299                              <1> 
   300                              <1> .end:
   301 00000BE8 07                  <1> 	pop es
   302 00000BE9 6661                <1> 	popad
   303                              <1> 
   304 00000BEB 668B1E[FB0B]        <1> 	mov ebx, [.file_size]		; Get file size to pass back in BX
   305 00000BF0 E84116              <1> 	call int_restore_footer
   306                              <1> 
   307 00000BF3 F8                  <1> 	clc				; Carry clear = good load
   308 00000BF4 C3                  <1> 	ret
   309                              <1> 
   310                              <1> 
   311 00000BF5 0000                <1> 	.cluster				dw 0 		; Cluster of the file we want to load
   312                              <1> 
   313 00000BF7 0000                <1> 	.filename_loc			dw 0		; Temporary store of filename location
   314 00000BF9 0000                <1> 	.load_position			dw 0		; Where we'll load the file
   315 00000BFB 00000000            <1> 	.file_size				dd 0		; Size of the file
   316                              <1> 
   317 00000BFF 0000                <1> 	.old_segment			dw 0
   318                              <1> 	
   319 00000C01 4C6F6164696E672000  <1> 	.msg_load				db 'Loading ', 0
   320                              <1> 	
   321                              <1> ; --------------------------------------------------------------------------
   322                              <1> ; os_write_file -- Save (max 64K) file to disk
   323                              <1> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
   324                              <1> ; OUT: Carry clear if OK, set if failure
   325                              <1> 
   326                              <1> os_write_file:
   327 00000C0A 6660                <1> 	pushad
   328                              <1> 	
   329 00000C0C 8C06[BC0D]          <1> 	mov [.old_segment], es
   330                              <1> 	
   331                              <1> 	movs es, cs
    39 00000C10 0E                  <2>  push %2
    40 00000C11 07                  <2>  pop %1
   332                              <1> 		
   333 00000C12 E8D715              <1> 	call int_save_footer			; Message display routine
   334 00000C15 720B                <1> 	jc .no_msg
   335                              <1> 
   336 00000C17 BE[BE0D]            <1> 	mov si, .msg_save
   337 00000C1A E8CD0A              <1> 	call os_print_string
   338 00000C1D 89C6                <1> 	mov si, ax
   339 00000C1F E8C80A              <1> 	call os_print_string
   340                              <1> 
   341                              <1> .no_msg:
   342 00000C22 890E[B00D]          <1> 	mov word [.filesize], cx
   343 00000C26 891E[B60D]          <1> 	mov word [.location], bx
   344 00000C2A A3[BA0D]            <1> 	mov word [.filename], ax
   345                              <1> 
   346                              <1> 	; First, zero out the .free_clusters list from any previous execution
   347 00000C2D 60                  <1> 	pusha
   348                              <1> 
   349 00000C2E BF00FF              <1> 	mov di, .free_clusters
   350 00000C31 B98000              <1> 	mov cx, 128
   351                              <1> .clean_free_loop:
   352 00000C34 C7050000            <1> 	mov word [di], 0
   353 00000C38 47                  <1> 	inc di
   354 00000C39 47                  <1> 	inc di
   355 00000C3A E2F8                <1> 	loop .clean_free_loop
   356                              <1> 
   357 00000C3C 61                  <1> 	popa
   358                              <1> 
   359                              <1> 
   360                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
   361                              <1> 
   362 00000C3D 89C8                <1> 	mov ax, cx
   363 00000C3F 31D2                <1> 	xor dx, dx
   364 00000C41 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
   365 00000C44 F7F3                <1> 	div bx
   366 00000C46 83FA00              <1> 	cmp dx, 0
   367 00000C49 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
   368 00000C4B EB03                <1> 	jmp .carry_on
   369                              <1> 
   370                              <1> .add_a_bit:
   371 00000C4D 83C001              <1> 	add ax, 1
   372                              <1> .carry_on:
   373                              <1> 
   374 00000C50 A3[B80D]            <1> 	mov word [.clusters_needed], ax
   375                              <1> 
   376 00000C53 A1[BA0D]            <1> 	mov word ax, [.filename]	; Get filename back
   377                              <1> 
   378 00000C56 E87C01              <1> 	call os_create_file		; Create empty root dir entry for this file
   379 00000C59 0F824801            <1> 	jc .failure		; If we can't write to the media, jump out
   380                              <1> 
   381 00000C5D 8B1E[B00D]          <1> 	mov word bx, [.filesize]
   382 00000C61 85DB                <1> 	test bx, bx
   383 00000C63 0F843301            <1> 	jz .finished
   384                              <1> 
   385 00000C67 E8A804              <1> 	call int_read_fat		; Get FAT copy into RAM
   386 00000C6A BE03E0              <1> 	mov si, DISK_BUFFER + 3		; And point SI at it (skipping first two clusters)
   387                              <1> 
   388 00000C6D BB0200              <1> 	mov bx, 2			; Current cluster counter
   389 00000C70 8B0E[B80D]          <1> 	mov word cx, [.clusters_needed]
   390 00000C74 31D2                <1> 	xor dx, dx			; Offset in .free_clusters list
   391                              <1> 
   392                              <1> .find_free_cluster:
   393 00000C76 AD                  <1> 	lodsw				; Get a word
   394 00000C77 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
   395 00000C7A 740D                <1> 	jz .found_free_even		; Free entry?
   396                              <1> 
   397                              <1> .more_odd:
   398 00000C7C 43                  <1> 	inc bx				; If not, bump our counter
   399 00000C7D 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
   400                              <1> 
   401 00000C7E AD                  <1> 	lodsw				; Get word
   402 00000C7F C1E804              <1> 	shr ax, 4			; Shift for odd
   403 00000C82 09C0                <1> 	or ax, ax			; Free entry?
   404 00000C84 7413                <1> 	jz .found_free_odd
   405                              <1> 
   406                              <1> .more_even:
   407 00000C86 43                  <1> 	inc bx				; If not, keep going
   408 00000C87 EBED                <1> 	jmp .find_free_cluster
   409                              <1> 
   410                              <1> 
   411                              <1> .found_free_even:
   412 00000C89 56                  <1> 	push si
   413 00000C8A BE00FF              <1> 	mov si, .free_clusters		; Store cluster
   414 00000C8D 01D6                <1> 	add si, dx
   415 00000C8F 891C                <1> 	mov word [si], bx
   416 00000C91 5E                  <1> 	pop si
   417                              <1> 
   418 00000C92 49                  <1> 	dec cx				; Got all the clusters we need?
   419 00000C93 E314                <1> 	jcxz .finished_list
   420                              <1> 
   421 00000C95 42                  <1> 	inc dx				; Next word in our list
   422 00000C96 42                  <1> 	inc dx
   423 00000C97 EBE3                <1> 	jmp .more_odd
   424                              <1> 
   425                              <1> .found_free_odd:
   426 00000C99 56                  <1> 	push si
   427 00000C9A BE00FF              <1> 	mov si, .free_clusters		; Store cluster
   428 00000C9D 01D6                <1> 	add si, dx
   429 00000C9F 891C                <1> 	mov word [si], bx
   430 00000CA1 5E                  <1> 	pop si
   431                              <1> 
   432 00000CA2 49                  <1> 	dec cx
   433 00000CA3 E304                <1> 	jcxz .finished_list
   434                              <1> 
   435 00000CA5 42                  <1> 	inc dx				; Next word in our list
   436 00000CA6 42                  <1> 	inc dx
   437 00000CA7 EBDD                <1> 	jmp .more_even
   438                              <1> 
   439                              <1> 
   440                              <1> 
   441                              <1> .finished_list:
   442                              <1> 
   443                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
   444                              <1> 	; that correspond to free clusters on the disk; the next job is to
   445                              <1> 	; create a cluster chain in the FAT for our file
   446                              <1> 
   447 00000CA9 31C9                <1> 	xor cx, cx			; .free_clusters offset counter
   448 00000CAB C706[B40D]0100      <1> 	mov word [.count], 1		; General cluster counter
   449                              <1> 
   450                              <1> .chain_loop:
   451 00000CB1 A1[B40D]            <1> 	mov word ax, [.count]		; Is this the last cluster?
   452 00000CB4 3B06[B80D]          <1> 	cmp word ax, [.clusters_needed]
   453 00000CB8 7454                <1> 	je .last_cluster
   454                              <1> 
   455 00000CBA BF00FF              <1> 	mov di, .free_clusters
   456                              <1> 
   457 00000CBD 01CF                <1> 	add di, cx
   458 00000CBF 8B1D                <1> 	mov word bx, [di]		; Get cluster
   459                              <1> 
   460 00000CC1 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
   461 00000CC3 31D2                <1> 	xor dx, dx
   462 00000CC5 BB0300              <1> 	mov bx, 3
   463 00000CC8 F7E3                <1> 	mul bx
   464 00000CCA BB0200              <1> 	mov bx, 2
   465 00000CCD F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   466 00000CCF BE00E0              <1> 	mov si, DISK_BUFFER
   467 00000CD2 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   468 00000CD4 3E8B04              <1> 	mov ax, word [ds:si]
   469                              <1> 
   470 00000CD7 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   471 00000CD9 741B                <1> 	jz .even
   472                              <1> 
   473                              <1> .odd:
   474 00000CDB 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
   475 00000CDE BF00FF              <1> 	mov di, .free_clusters
   476 00000CE1 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   477 00000CE3 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
   478 00000CE6 C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
   479 00000CE9 01D8                <1> 	add ax, bx
   480                              <1> 
   481 00000CEB 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   482                              <1> 
   483 00000CEE FF06[B40D]          <1> 	inc word [.count]
   484 00000CF2 41                  <1> 	inc cx				; Move on a word in .free_clusters
   485 00000CF3 41                  <1> 	inc cx
   486                              <1> 
   487 00000CF4 EBBB                <1> 	jmp .chain_loop
   488                              <1> 
   489                              <1> .even:
   490 00000CF6 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
   491 00000CF9 BF00FF              <1> 	mov di, .free_clusters
   492 00000CFC 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   493 00000CFE 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
   494                              <1> 
   495 00000D01 01D8                <1> 	add ax, bx
   496                              <1> 
   497 00000D03 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   498                              <1> 
   499 00000D06 FF06[B40D]          <1> 	inc word [.count]
   500 00000D0A 41                  <1> 	inc cx				; Move on a word in .free_clusters
   501 00000D0B 41                  <1> 	inc cx
   502                              <1> 
   503 00000D0C EBA3                <1> 	jmp .chain_loop
   504                              <1> 
   505                              <1> 
   506                              <1> 
   507                              <1> .last_cluster:
   508 00000D0E BF00FF              <1> 	mov di, .free_clusters
   509 00000D11 01CF                <1> 	add di, cx
   510 00000D13 8B1D                <1> 	mov word bx, [di]		; Get cluster
   511                              <1> 
   512 00000D15 89D8                <1> 	mov ax, bx
   513                              <1> 
   514 00000D17 31D2                <1> 	xor dx, dx
   515 00000D19 BB0300              <1> 	mov bx, 3
   516 00000D1C F7E3                <1> 	mul bx
   517 00000D1E BB0200              <1> 	mov bx, 2
   518 00000D21 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   519 00000D23 BE00E0              <1> 	mov si, DISK_BUFFER
   520 00000D26 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   521 00000D28 3E8B04              <1> 	mov ax, word [ds:si]
   522                              <1> 
   523 00000D2B 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   524 00000D2D 7408                <1> 	jz .even_last
   525                              <1> 
   526                              <1> .odd_last:
   527 00000D2F 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
   528 00000D32 83C080              <1> 	add ax, 0FF80h
   529 00000D35 EB06                <1> 	jmp .finito
   530                              <1> 
   531                              <1> .even_last:
   532 00000D37 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
   533 00000D3A 05F80F              <1> 	add ax, 0FF8h
   534                              <1> 
   535                              <1> 
   536                              <1> .finito:
   537 00000D3D 3E8904              <1> 	mov word [ds:si], ax
   538                              <1> 
   539 00000D40 E8EA03              <1> 	call int_write_fat		; Save our FAT back to disk
   540                              <1> 
   541                              <1> 
   542                              <1> 	; Now it's time to save the sectors to disk!
   543                              <1> 
   544 00000D43 31C9                <1> 	xor cx, cx
   545                              <1> 
   546                              <1> .save_loop:
   547 00000D45 BF00FF              <1> 	mov di, .free_clusters
   548 00000D48 01CF                <1> 	add di, cx
   549 00000D4A 660FB705            <1> 	movzx eax, word [di]
   550                              <1> 
   551 00000D4E 6685C0              <1> 	test eax, eax
   552 00000D51 7423                <1> 	jz .write_root_entry
   553                              <1> 
   554 00000D53 6660                <1> 	pushad
   555                              <1> 
   556 00000D55 6683C01F            <1> 	add eax, 31
   557 00000D59 8B36[B60D]          <1> 	mov si, [.location]
   558 00000D5D 8E06[BC0D]          <1> 	mov es, [.old_segment]
   559 00000D61 8A16[8411]          <1> 	mov dl, [bootdev]
   560                              <1> 	
   561 00000D65 E84B3F              <1> 	call os_disk_write_sector
   562                              <1> 
   563                              <1> 	movs es, cs
    39 00000D68 0E                  <2>  push %2
    40 00000D69 07                  <2>  pop %1
   564                              <1> 		
   565 00000D6A 6661                <1> 	popad
   566                              <1> 
   567 00000D6C 8106[B60D]0002      <1> 	add word [.location], 512
   568 00000D72 41                  <1> 	inc cx
   569 00000D73 41                  <1> 	inc cx
   570 00000D74 EBCF                <1> 	jmp .save_loop
   571                              <1> 
   572                              <1> 
   573                              <1> .write_root_entry:
   574                              <1> 
   575                              <1> 	; Now it's time to head back to the root directory, find our
   576                              <1> 	; entry and update it with the cluster in use and file size
   577                              <1> 
   578 00000D76 E8CF03              <1> 	call int_read_root_dir
   579                              <1> 
   580 00000D79 A1[BA0D]            <1> 	mov word ax, [.filename]
   581 00000D7C E8A802              <1> 	call int_filename_convert
   582 00000D7F E86503              <1> 	call int_get_root_entry
   583                              <1> 
   584 00000D82 A100FF              <1> 	mov word ax, [.free_clusters]	; Get first free cluster
   585                              <1> 
   586 00000D85 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
   587                              <1> 
   588 00000D88 8B0E[B00D]          <1> 	mov word cx, [.filesize]
   589 00000D8C 894D1C              <1> 	mov word [di+28], cx
   590                              <1> 
   591 00000D8F C6451E00            <1> 	mov byte [di+30], 0		; File size
   592 00000D93 C6451F00            <1> 	mov byte [di+31], 0
   593                              <1> 
   594 00000D97 E8C903              <1> 	call int_write_root_dir
   595                              <1> 
   596                              <1> .finished:
   597 00000D9A E89714              <1> 	call int_restore_footer
   598 00000D9D 6661                <1> 	popad
   599 00000D9F 8E06[BC0D]          <1> 	mov es, [.old_segment]
   600                              <1> 
   601 00000DA3 F8                  <1> 	clc
   602 00000DA4 C3                  <1> 	ret
   603                              <1> 
   604                              <1> .failure:
   605 00000DA5 E88C14              <1> 	call int_restore_footer
   606 00000DA8 6661                <1> 	popad
   607 00000DAA 8E06[BC0D]          <1> 	mov es, [.old_segment]
   608                              <1> 
   609 00000DAE F9                  <1> 	stc				; Couldn't write!
   610 00000DAF C3                  <1> 	ret
   611                              <1> 
   612                              <1> 
   613 00000DB0 0000                <1> 	.filesize				dw 0
   614 00000DB2 0000                <1> 	.cluster				dw 0
   615 00000DB4 0000                <1> 	.count					dw 0
   616 00000DB6 0000                <1> 	.location				dw 0
   617                              <1> 
   618 00000DB8 0000                <1> 	.clusters_needed		dw 0
   619                              <1> 
   620 00000DBA 0000                <1> 	.filename				dw 0
   621                              <1> 
   622                              <1> 	.free_clusters			equ DISK_BUFFER + 7936 ; THIS IS A KLUDGE!!!
   623                              <1> 
   624 00000DBC 0000                <1> 	.old_segment			dw 0
   625                              <1> 
   626 00000DBE 536176696E672000    <1> 	.msg_save				db 'Saving ', 0
   627                              <1> 	
   628                              <1> ; --------------------------------------------------------------------------
   629                              <1> ; os_file_exists -- Check for presence of file on the floppy
   630                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
   631                              <1> 
   632                              <1> os_file_exists:
   633 00000DC6 E8ED19              <1> 	call os_string_uppercase
   634                              <1> 
   635 00000DC9 50                  <1> 	push ax
   636 00000DCA E87B03              <1> 	call int_read_root_dir
   637 00000DCD E85702              <1> 	call int_filename_convert	; Make FAT12-style filename
   638 00000DD0 E81403              <1> 	call int_get_root_entry	; Set or clear carry flag
   639 00000DD3 58                  <1> 	pop ax
   640 00000DD4 C3                  <1> 	ret
   641                              <1> 
   642                              <1> 
   643                              <1> ; --------------------------------------------------------------------------
   644                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
   645                              <1> ; IN: AX = location of filename
   646                              <1> ; OUT: None, registers preserved
   647                              <1> 
   648                              <1> os_create_file:
   649 00000DD5 F8                  <1> 	clc
   650                              <1> 
   651 00000DD6 E8EDFF              <1> 	call os_file_exists		; Does the file already exist?
   652 00000DD9 7323                <1> 	jnc .exists_error
   653                              <1> 
   654 00000DDB 60                  <1> 	pusha
   655                              <1> 
   656 00000DDC E8D719              <1> 	call os_string_uppercase
   657 00000DDF E84502              <1> 	call int_filename_convert	; Make FAT12-style filename
   658 00000DE2 50                  <1> 	push ax				; Save filename for now
   659                              <1> 
   660                              <1> 
   661                              <1> 
   662                              <1> 	; Root dir already read into DISK_BUFFER by os_file_exists
   663                              <1> 
   664 00000DE3 BF00E0              <1> 	mov di, DISK_BUFFER		; So point DI at it!
   665                              <1> 
   666 00000DE6 B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
   667                              <1> .next_entry:
   668 00000DE9 8A05                <1> 	mov byte al, [di]
   669 00000DEB 84C0                <1> 	test al, al			; Is this a free entry?
   670 00000DED 7411                <1> 	jz .found_free_entry
   671 00000DEF 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
   672 00000DF1 740D                <1> 	je .found_free_entry
   673 00000DF3 83C720              <1> 	add di, 32			; If not, go onto next entry
   674 00000DF6 E2F1                <1> 	loop .next_entry
   675                              <1> 	
   676 00000DF8 B8[940E]            <1> 	mov ax, .err_msg		; Is the root directory full?
   677 00000DFB E82906              <1> 	call os_fatal_error
   678                              <1> 
   679                              <1> .exists_error:				; We also get here if above loop finds nothing
   680 00000DFE F9                  <1> 	stc
   681 00000DFF C3                  <1> 	ret
   682                              <1> 
   683                              <1> .found_free_entry:
   684 00000E00 5E                  <1> 	pop si				; Get filename back
   685 00000E01 B90B00              <1> 	mov cx, 11
   686 00000E04 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
   687                              <1> 
   688                              <1> 	; Get the time information
   689                              <1> 	
   690 00000E06 60                  <1> 	pusha
   691 00000E07 B402                <1> 	mov ah, 2
   692 00000E09 E87D07              <1> 	call os_int_1Ah
   693                              <1> 
   694 00000E0C 88E8                <1> 	mov al, ch			; Hours
   695 00000E0E E8C804              <1> 	call os_bcd_to_int
   696 00000E11 89C3                <1> 	mov bx, ax
   697 00000E13 C1E306              <1> 	shl bx, 6
   698                              <1> 	
   699 00000E16 88C8                <1> 	mov al, cl			; Minutes
   700 00000E18 E8BE04              <1> 	call os_bcd_to_int
   701 00000E1B 09C3                <1> 	or bx, ax
   702 00000E1D C1E305              <1> 	shl bx, 5
   703                              <1> 	
   704 00000E20 D0EE                <1> 	shr dh, 1			; Seconds (they're stored as "doubleseconds")
   705 00000E22 88F0                <1> 	mov al, dh
   706 00000E24 E8B204              <1> 	call os_bcd_to_int
   707 00000E27 09C3                <1> 	or bx, ax
   708                              <1> 	
   709 00000E29 891E[820E]          <1> 	mov [.creation_time], bx
   710 00000E2D 891E[8A0E]          <1> 	mov [.write_time], bx
   711                              <1> 
   712                              <1> 	; Get date information
   713                              <1> 	
   714 00000E31 B404                <1> 	mov ah, 4
   715 00000E33 E85307              <1> 	call os_int_1Ah
   716                              <1> 
   717 00000E36 52                  <1> 	push dx
   718 00000E37 88E8                <1> 	mov al, ch			; Century
   719 00000E39 E89D04              <1> 	call os_bcd_to_int
   720 00000E3C BB6400              <1> 	mov bx, 100
   721 00000E3F F7E3                <1> 	mul bx
   722 00000E41 89C3                <1> 	mov bx, ax
   723                              <1> 	
   724 00000E43 88C8                <1> 	mov al, cl			; Years
   725 00000E45 E89104              <1> 	call os_bcd_to_int
   726 00000E48 01C3                <1> 	add bx, ax
   727                              <1> 	
   728 00000E4A 81EBBC07            <1> 	sub bx, 1980		; Years are stored as "years past 1980"
   729                              <1> 	
   730 00000E4E C1E304              <1> 	shl bx, 4
   731 00000E51 5A                  <1> 	pop dx
   732                              <1> 	
   733 00000E52 88F0                <1> 	mov al, dh			; Months
   734 00000E54 E88204              <1> 	call os_bcd_to_int
   735 00000E57 09C3                <1> 	or bx, ax
   736 00000E59 C1E305              <1> 	shl bx, 5
   737                              <1> 	
   738 00000E5C 88D0                <1> 	mov al, dl			; Days
   739 00000E5E E87804              <1> 	call os_bcd_to_int
   740 00000E61 09C3                <1> 	or bx, ax
   741                              <1> 	
   742 00000E63 891E[840E]          <1> 	mov [.creation_date], bx
   743 00000E67 891E[8C0E]          <1> 	mov [.write_date], bx
   744 00000E6B 61                  <1> 	popa
   745                              <1> 	
   746 00000E6C BE[7F0E]            <1> 	mov si, .table		; Copy over all the attributes
   747 00000E6F B91500              <1> 	mov cx, 21
   748 00000E72 F3A4                <1> 	rep movsb
   749                              <1> 	
   750 00000E74 E8EC02              <1> 	call int_write_root_dir
   751 00000E77 7203                <1> 	jc .failure
   752                              <1> 
   753 00000E79 61                  <1> 	popa
   754                              <1> 
   755 00000E7A F8                  <1> 	clc				; Clear carry for success
   756 00000E7B C3                  <1> 	ret
   757                              <1> 
   758                              <1> .failure:
   759 00000E7C 61                  <1> 	popa
   760                              <1> 
   761 00000E7D F9                  <1> 	stc
   762 00000E7E C3                  <1> 	ret
   763                              <1> 
   764                              <1> ;	.table			db 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0, 0 
   765                              <1> 	.table:
   766 00000E7F 00                  <1> 		.atttribute		db 0
   767 00000E80 00<rep 2h>          <1> 		.reserved		times 2 db 0
   768 00000E82 0000                <1> 		.creation_time	dw 0
   769 00000E84 0000                <1> 		.creation_date	dw 0
   770 00000E86 00<rep 4h>          <1> 		.reserved2		times 4 db 0
   771 00000E8A 0000                <1> 		.write_time		dw 0
   772 00000E8C 0000                <1> 		.write_date		dw 0
   773 00000E8E 00<rep 6h>          <1> 		.reserved3		times 6 db 0
   774 00000E94 4E6F7420656E6F7567- <1> 	.err_msg		db 'Not enough space in directory', 0
   774 00000E9D 682073706163652069- <1>
   774 00000EA6 6E206469726563746F- <1>
   774 00000EAF 727900              <1>
   775                              <1> 
   776                              <1> ; --------------------------------------------------------------------------
   777                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
   778                              <1> ; IN: AX = location of filename to remove
   779                              <1> 
   780                              <1> os_remove_file:
   781 00000EB2 60                  <1> 	pusha
   782 00000EB3 E80019              <1> 	call os_string_uppercase
   783 00000EB6 E86E01              <1> 	call int_filename_convert	; Make filename FAT12-style
   784 00000EB9 50                  <1> 	push ax				; Save filename
   785                              <1> 
   786 00000EBA F8                  <1> 	clc
   787                              <1> 
   788 00000EBB E88A02              <1> 	call int_read_root_dir		; Get root dir into DISK_BUFFER
   789                              <1> 
   790 00000EBE 58                  <1> 	pop ax				; Get chosen filename back
   791                              <1> 
   792 00000EBF E82502              <1> 	call int_get_root_entry	; Entry will be returned in DI
   793 00000EC2 7267                <1> 	jc .failure			; If entry can't be found
   794                              <1> 
   795                              <1> 
   796 00000EC4 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
   797 00000EC8 A3[2E0F]            <1> 	mov word [.cluster], ax		; And save it
   798                              <1> 
   799 00000ECB C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
   800                              <1> 
   801 00000ECE 47                  <1> 	inc di
   802                              <1> 
   803 00000ECF 31C9                <1> 	xor cx, cx			; Set rest of data in root dir entry to zeros
   804                              <1> .clean_loop:
   805 00000ED1 C60500              <1> 	mov byte [di], 0
   806 00000ED4 47                  <1> 	inc di
   807 00000ED5 41                  <1> 	inc cx
   808 00000ED6 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
   809 00000ED9 7CF6                <1> 	jl .clean_loop
   810                              <1> 
   811 00000EDB E88502              <1> 	call int_write_root_dir	; Save back the root directory from RAM
   812                              <1> 
   813                              <1> 
   814 00000EDE E83102              <1> 	call int_read_fat		; Now FAT is in DISK_BUFFER
   815 00000EE1 BF00E0              <1> 	mov di, DISK_BUFFER		; And DI points to it
   816                              <1> 
   817                              <1> 
   818                              <1> .more_clusters:
   819 00000EE4 A1[2E0F]            <1> 	mov word ax, [.cluster]		; Get cluster contents
   820                              <1> 
   821 00000EE7 85C0                <1> 	test ax, ax			; If it's zero, this was an empty file
   822 00000EE9 743D                <1> 	jz .nothing_to_do
   823                              <1> 
   824 00000EEB BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
   825 00000EEE F7E3                <1> 	mul bx
   826 00000EF0 BB0200              <1> 	mov bx, 2
   827 00000EF3 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
   828 00000EF5 BE00E0              <1> 	mov si, DISK_BUFFER		; AX = word in FAT for the 12 bits
   829 00000EF8 01C6                <1> 	add si, ax
   830 00000EFA 3E8B04              <1> 	mov ax, word [ds:si]
   831                              <1> 
   832 00000EFD 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
   833                              <1> 
   834 00000EFF 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
   835                              <1> 					; with next cluster; if odd, drop first 4 bits
   836                              <1> .odd:
   837 00000F01 50                  <1> 	push ax
   838 00000F02 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
   839 00000F05 3E8904              <1> 	mov word [ds:si], ax
   840 00000F08 58                  <1> 	pop ax
   841                              <1> 
   842 00000F09 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
   843 00000F0C EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   844                              <1> 
   845                              <1> .even:
   846 00000F0E 50                  <1> 	push ax
   847 00000F0F 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
   848 00000F12 3E8904              <1> 	mov word [ds:si], ax
   849 00000F15 58                  <1> 	pop ax
   850                              <1> 
   851 00000F16 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
   852                              <1> 
   853                              <1> .calculate_cluster_cont:
   854 00000F19 A3[2E0F]            <1> 	mov word [.cluster], ax		; Store cluster
   855                              <1> 
   856 00000F1C 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
   857 00000F1F 7302                <1> 	jae .end
   858                              <1> 
   859 00000F21 EBC1                <1> 	jmp .more_clusters		; If not, grab more
   860                              <1> 
   861                              <1> .end:
   862 00000F23 E80702              <1> 	call int_write_fat
   863 00000F26 7203                <1> 	jc .failure
   864                              <1> 
   865                              <1> .nothing_to_do:
   866 00000F28 61                  <1> 	popa
   867                              <1> 
   868 00000F29 F8                  <1> 	clc
   869 00000F2A C3                  <1> 	ret
   870                              <1> 
   871                              <1> .failure:
   872 00000F2B 61                  <1> 	popa
   873                              <1> 
   874 00000F2C F9                  <1> 	stc
   875 00000F2D C3                  <1> 	ret
   876                              <1> 
   877                              <1> 
   878 00000F2E 0000                <1> 	.cluster dw 0
   879                              <1> 
   880                              <1> 
   881                              <1> ; --------------------------------------------------------------------------
   882                              <1> ; os_rename_file -- Change the name of a file on the disk
   883                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
   884                              <1> ; OUT: carry set on error
   885                              <1> 
   886                              <1> os_rename_file:
   887 00000F30 53                  <1> 	push bx
   888 00000F31 50                  <1> 	push ax
   889                              <1> 
   890 00000F32 F8                  <1> 	clc
   891                              <1> 
   892 00000F33 E81202              <1> 	call int_read_root_dir		; Get root dir into DISK_BUFFER
   893                              <1> 
   894 00000F36 58                  <1> 	pop ax				; Get chosen filename back
   895                              <1> 
   896 00000F37 E87C18              <1> 	call os_string_uppercase
   897 00000F3A E8EA00              <1> 	call int_filename_convert
   898 00000F3D 721E                <1> 	jc .fail_read
   899                              <1> 	
   900 00000F3F E8A501              <1> 	call int_get_root_entry	; Entry will be returned in DI
   901 00000F42 7219                <1> 	jc .fail_read			; Quit out if file not found
   902                              <1> 
   903 00000F44 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
   904                              <1> 
   905 00000F45 89D8                <1> 	mov ax, bx
   906                              <1> 
   907 00000F47 E86C18              <1> 	call os_string_uppercase
   908 00000F4A E8DA00              <1> 	call int_filename_convert
   909 00000F4D 7211                <1> 	jc .fail_write
   910                              <1> 	
   911 00000F4F 89C6                <1> 	mov si, ax
   912                              <1> 
   913 00000F51 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in DISK_BUFFER
   914 00000F54 F3A4                <1> 	rep movsb
   915                              <1> 
   916 00000F56 E80A02              <1> 	call int_write_root_dir	; Save root dir to disk
   917 00000F59 7205                <1> 	jc .fail_write
   918                              <1> 
   919                              <1> 
   920 00000F5B F8                  <1> 	clc
   921 00000F5C C3                  <1> 	ret
   922                              <1> 
   923                              <1> .fail_read:
   924 00000F5D 58                  <1> 	pop ax
   925                              <1> 
   926 00000F5E F9                  <1> 	stc
   927 00000F5F C3                  <1> 	ret
   928                              <1> 
   929                              <1> .fail_write:
   930                              <1> 
   931 00000F60 F9                  <1> 	stc
   932 00000F61 C3                  <1> 	ret
   933                              <1> 
   934                              <1> 
   935                              <1> ; --------------------------------------------------------------------------
   936                              <1> ; os_get_file_size -- Get file size information for specified file
   937                              <1> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
   938                              <1> ; or carry set if file not found
   939                              <1> 
   940                              <1> os_get_file_size:
   941 00000F62 60                  <1> 	pusha
   942                              <1> 
   943 00000F63 E85018              <1> 	call os_string_uppercase
   944 00000F66 E8BE00              <1> 	call int_filename_convert
   945                              <1> 
   946 00000F69 F8                  <1> 	clc
   947                              <1> 
   948 00000F6A 50                  <1> 	push ax
   949                              <1> 
   950 00000F6B E8DA01              <1> 	call int_read_root_dir
   951 00000F6E 7216                <1> 	jc .failure
   952                              <1> 
   953 00000F70 58                  <1> 	pop ax
   954                              <1> 
   955 00000F71 E87301              <1> 	call int_get_root_entry
   956 00000F74 7210                <1> 	jc .failure
   957                              <1> 
   958 00000F76 668B5D1C            <1> 	mov ebx, [di+28]
   959                              <1> 
   960 00000F7A 66891E[890F]        <1> 	mov [.tmp], ebx
   961                              <1> 
   962 00000F7F 61                  <1> 	popa
   963                              <1> 
   964 00000F80 668B1E[890F]        <1> 	mov ebx, [.tmp]
   965                              <1> 
   966                              <1> 
   967 00000F85 C3                  <1> 	ret
   968                              <1> 
   969                              <1> .failure:
   970 00000F86 61                  <1> 	popa
   971 00000F87 F9                  <1> 	stc
   972                              <1> 
   973 00000F88 C3                  <1> 	ret
   974                              <1> 
   975                              <1> 
   976 00000F89 00000000            <1> 	.tmp	dd 0
   977                              <1> 
   978                              <1> ; --------------------------------------------------------------------------
   979                              <1> ; os_get_file_datetime -- Get file write time/date information for specified file
   980                              <1> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
   981                              <1> ; or carry set if file not found
   982                              <1> 
   983                              <1> os_get_file_datetime:
   984 00000F8D 60                  <1> 	pusha
   985                              <1> 
   986 00000F8E E82518              <1> 	call os_string_uppercase
   987 00000F91 E89300              <1> 	call int_filename_convert
   988                              <1> 
   989 00000F94 F8                  <1> 	clc
   990                              <1> 
   991 00000F95 50                  <1> 	push ax
   992                              <1> 
   993 00000F96 E8AF01              <1> 	call int_read_root_dir
   994 00000F99 721D                <1> 	jc .failure
   995                              <1> 
   996 00000F9B 58                  <1> 	pop ax
   997                              <1> 
   998 00000F9C E84801              <1> 	call int_get_root_entry
   999 00000F9F 7217                <1> 	jc .failure
  1000                              <1> 
  1001 00000FA1 8B4516              <1> 	mov ax, [di+22]
  1002 00000FA4 8B5D18              <1> 	mov bx, [di+24]
  1003                              <1> 
  1004 00000FA7 A3[BB0F]            <1> 	mov [.tmp], ax
  1005 00000FAA 891E[BD0F]          <1> 	mov [.tmp + 2], bx
  1006                              <1> 
  1007 00000FAE 61                  <1> 	popa
  1008                              <1> 
  1009 00000FAF 8B1E[BB0F]          <1> 	mov bx, [.tmp]
  1010 00000FB3 8B0E[BD0F]          <1> 	mov cx, [.tmp + 2]
  1011                              <1> 
  1012                              <1> 
  1013 00000FB7 C3                  <1> 	ret
  1014                              <1> 
  1015                              <1> .failure:
  1016 00000FB8 61                  <1> 	popa
  1017 00000FB9 F9                  <1> 	stc
  1018                              <1> 
  1019 00000FBA C3                  <1> 	ret
  1020                              <1> 
  1021                              <1> 
  1022 00000FBB 00000000            <1> 	.tmp	dd 0
  1023                              <1> 
  1024                              <1> 
  1025                              <1> ; ==================================================================
  1026                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  1027                              <1> 
  1028                              <1> ; ------------------------------------------------------------------
  1029                              <1> ; int_filename_deconvert -- Change 'TEST    BIN' into 'TEST.BIN' as per FAT12
  1030                              <1> ; IN: DS:AX = filename string
  1031                              <1> ; OUT: ES:AX = location of converted string
  1032                              <1> 
  1033                              <1> int_filename_deconvert:
  1034 00000FBF 60                  <1> 	pusha
  1035                              <1> 	movs es, cs
    39 00000FC0 0E                  <2>  push %2
    40 00000FC1 07                  <2>  pop %1
  1036                              <1> 
  1037 00000FC2 89C6                <1> 	mov si, ax
  1038 00000FC4 BF[DA10]            <1> 	mov di, int_filename
  1039                              <1> 
  1040 00000FC7 803C20              <1> 	cmp byte [si], ' '		; Special case - filename starts with a space
  1041 00000FCA 7449                <1> 	je .error
  1042                              <1> 
  1043 00000FCC B90000              <1> 	mov cx, 0
  1044                              <1> 
  1045                              <1> .basename_loop:
  1046 00000FCF AC                  <1> 	lodsb
  1047                              <1> 
  1048 00000FD0 41                  <1> 	inc cx
  1049                              <1> 
  1050 00000FD1 3C20                <1> 	cmp al, ' '				; If there's a space, skip forward
  1051 00000FD3 7426                <1> 	je .basename_skip
  1052                              <1> 
  1053 00000FD5 E8C300              <1> 	call int_filename_convert.check_valid_char
  1054 00000FD8 723B                <1> 	jc .error
  1055                              <1> 
  1056 00000FDA AA                  <1> 	stosb
  1057                              <1> 
  1058 00000FDB 83F908              <1> 	cmp cx, 8
  1059 00000FDE 75EF                <1> 	jne .basename_loop
  1060                              <1> 
  1061                              <1> .basename_finish:
  1062 00000FE0 803C20              <1> 	cmp byte [si], ' '		; Check if the extension is empty
  1063 00000FE3 7423                <1> 	je .extension_skip
  1064                              <1> 
  1065 00000FE5 B02E                <1> 	mov al, '.'				; Otherwise add the period and parse the extension
  1066 00000FE7 AA                  <1> 	stosb
  1067                              <1> 
  1068                              <1> .extension_loop:
  1069 00000FE8 AC                  <1> 	lodsb
  1070                              <1> 
  1071 00000FE9 41                  <1> 	inc cx
  1072                              <1> 
  1073 00000FEA 3C20                <1> 	cmp al, ' '
  1074 00000FEC 741A                <1> 	je .extension_skip
  1075                              <1> 
  1076 00000FEE E8AA00              <1> 	call int_filename_convert.check_valid_char
  1077 00000FF1 7222                <1> 	jc .error
  1078                              <1> 
  1079 00000FF3 AA                  <1> 	stosb
  1080                              <1> 
  1081 00000FF4 83F90B              <1> 	cmp cx, 11
  1082 00000FF7 75EF                <1> 	jne .extension_loop
  1083                              <1> 
  1084                              <1> .extension_finish:
  1085 00000FF9 EB72                <1> 	jmp int_filename_convert.exit
  1086                              <1> 
  1087                              <1> .basename_skip:
  1088 00000FFB 83F908              <1> 	cmp cx, 8
  1089 00000FFE 7DE0                <1> 	jge .basename_finish
  1090                              <1> 
  1091 00001000 AC                  <1> 	lodsb
  1092                              <1> 
  1093 00001001 3C20                <1> 	cmp al, ' '
  1094 00001003 7510                <1> 	jne .error
  1095                              <1> 
  1096 00001005 41                  <1> 	inc cx
  1097 00001006 EBF3                <1> 	jmp .basename_skip
  1098                              <1> 
  1099                              <1> .extension_skip:
  1100 00001008 83F90B              <1> 	cmp cx, 11
  1101 0000100B 7DEC                <1> 	jge .extension_finish
  1102                              <1> 
  1103 0000100D AC                  <1> 	lodsb
  1104                              <1> 
  1105 0000100E 3C20                <1> 	cmp al, ' '
  1106 00001010 7503                <1> 	jne .error
  1107                              <1> 
  1108 00001012 41                  <1> 	inc cx
  1109 00001013 EBF3                <1> 	jmp .extension_skip
  1110                              <1> 
  1111                              <1> .error:
  1112 00001015 61                  <1> 	popa
  1113 00001016 B8[1A10]            <1> 	mov ax, .invalid
  1114 00001019 C3                  <1> 	ret
  1115                              <1> 
  1116 0000101A 5B4E414D4520455252- <1> 	.invalid		db "[NAME ERROR]", 0
  1116 00001023 4F525D00            <1>
  1117                              <1> 
  1118                              <1> ; ------------------------------------------------------------------
  1119                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  1120                              <1> ; IN: DS:AX = filename string
  1121                              <1> ; OUT: ES:AX = location of converted string
  1122                              <1> 
  1123                              <1> int_filename_convert:
  1124 00001027 60                  <1> 	pusha
  1125                              <1> 	movs es, cs
    39 00001028 0E                  <2>  push %2
    40 00001029 07                  <2>  pop %1
  1126                              <1> 
  1127 0000102A 89C6                <1> 	mov si, ax
  1128 0000102C BF[DA10]            <1> 	mov di, int_filename
  1129                              <1> 
  1130                              <1> 	clr cx
    31 0000102F 31C9                <2>  xor %1, %1
  1131                              <1> 
  1132                              <1> .copy_loop:
  1133 00001031 AC                  <1> 	lodsb
  1134                              <1> 
  1135 00001032 3C2E                <1> 	cmp al, '.'
  1136 00001034 7410                <1> 	je .extension_found
  1137                              <1> 
  1138 00001036 3C00                <1> 	cmp al, 0
  1139 00001038 742A                <1> 	je .finish
  1140                              <1> 
  1141                              <1> 	; Check against allowed special characters
  1142                              <1> 
  1143 0000103A E85E00              <1> 	call .check_valid_char
  1144 0000103D 72F2                <1> 	jc .copy_loop
  1145                              <1> 
  1146 0000103F AA                  <1> 	stosb
  1147                              <1> 
  1148 00001040 41                  <1> 	inc cx				; Go to the next character
  1149 00001041 83F908              <1> 	cmp cx, 8			; If the basename's full, go to the extension
  1150 00001044 7CEB                <1> 	jl .copy_loop
  1151                              <1> 
  1152                              <1> .extension_found:
  1153 00001046 85C9                <1> 	test cx, cx			; Special case: filename starts with period
  1154 00001048 74E7                <1> 	jz .copy_loop
  1155                              <1> 
  1156 0000104A 83F908              <1> 	cmp cx, 8			; If the basename was less than 8 chars, pad it out
  1157 0000104D 7C26                <1> 	jl .basename_pad
  1158                              <1> 
  1159 0000104F 3C2E                <1> 	cmp al, '.'			; If the basename is larger than 8 chars, skip forward
  1160 00001051 752D                <1> 	jne .basename_skip
  1161                              <1> 
  1162                              <1> .extension_loop:
  1163 00001053 AC                  <1> 	lodsb
  1164                              <1> 
  1165 00001054 3C00                <1> 	cmp al, 0
  1166 00001056 740C                <1> 	je .finish
  1167                              <1> 
  1168                              <1> 	; Check against allowed special characters
  1169                              <1> 
  1170 00001058 E84000              <1> 	call .check_valid_char
  1171 0000105B 72F6                <1> 	jc .extension_loop
  1172                              <1> 
  1173 0000105D AA                  <1> 	stosb
  1174                              <1> 
  1175 0000105E 41                  <1> 	inc cx				; Go to the next character
  1176 0000105F 83F90B              <1> 	cmp cx, 11			; If the extension's full, finish
  1177 00001062 7CEF                <1> 	jl .extension_loop
  1178                              <1> 
  1179                              <1> .finish:
  1180 00001064 85C9                <1> 	test cx, cx			; Special case if the file name was empty or full of gibberish
  1181 00001066 742E                <1> 	jz .do_unnamed
  1182                              <1> 
  1183 00001068 83F90B              <1> 	cmp cx, 11
  1184 0000106B 7C1E                <1> 	jl .extension_pad
  1185                              <1> 
  1186                              <1> .exit:
  1187 0000106D B000                <1> 	mov al, 0				; Zero-terminate the string
  1188 0000106F AA                  <1> 	stosb
  1189                              <1> 
  1190 00001070 61                  <1> 	popa
  1191 00001071 B8[DA10]            <1> 	mov ax, int_filename
  1192 00001074 C3                  <1> 	ret
  1193                              <1> 
  1194                              <1> .basename_pad:
  1195 00001075 B020                <1> 	mov al, ' '
  1196                              <1> 
  1197                              <1> .basename_pad_loop:
  1198 00001077 AA                  <1> 	stosb
  1199 00001078 41                  <1> 	inc cx
  1200 00001079 83F908              <1> 	cmp cx, 8
  1201 0000107C 7CF9                <1> 	jl .basename_pad_loop
  1202                              <1> 
  1203 0000107E EBD3                <1> 	jmp .extension_loop
  1204                              <1> 
  1205                              <1> .basename_skip:
  1206 00001080 AC                  <1> 	lodsb
  1207                              <1> 
  1208 00001081 3C2E                <1> 	cmp al, '.'
  1209 00001083 74CE                <1> 	je .extension_loop
  1210                              <1> 
  1211 00001085 3C00                <1> 	cmp al, 0
  1212 00001087 75F7                <1> 	jne .basename_skip
  1213                              <1> 
  1214 00001089 EBD9                <1> 	jmp .finish
  1215                              <1> 
  1216                              <1> .extension_pad:
  1217 0000108B B020                <1> 	mov al, ' '
  1218                              <1> 
  1219                              <1> .extension_pad_loop:
  1220 0000108D AA                  <1> 	stosb
  1221 0000108E 41                  <1> 	inc cx
  1222 0000108F 83F90B              <1> 	cmp cx, 11
  1223 00001092 7CF9                <1> 	jl .extension_pad_loop
  1224                              <1> 
  1225 00001094 EBD7                <1> 	jmp .exit
  1226                              <1> 
  1227                              <1> .do_unnamed:
  1228 00001096 61                  <1> 	popa
  1229 00001097 B8[CE10]            <1> 	mov ax, .unnamed
  1230 0000109A C3                  <1> 	ret
  1231                              <1> 
  1232                              <1> .check_valid_char:
  1233                              <1> 	; Is the character within ASCII range?
  1234                              <1> 
  1235 0000109B 3C21                <1> 	cmp al, 0x21
  1236 0000109D 721C                <1> 	jb .check_valid_char_fail
  1237                              <1> 
  1238 0000109F 3C7E                <1> 	cmp al, 0x7E
  1239 000010A1 7714                <1> 	ja .check_valid_char_pass
  1240                              <1> 
  1241                              <1> 	; There are certain blocked characters, so mask those off as well
  1242                              <1> 	; (https://www.win.tue.nl/~aeb/linux/fs/fat/fat-1.html)
  1243                              <1> 
  1244 000010A3 60                  <1> 	pusha
  1245 000010A4 1E                  <1> 	push ds
  1246                              <1> 	movs ds, cs
    39 000010A5 0E                  <2>  push %2
    40 000010A6 1F                  <2>  pop %1
  1247 000010A7 88C3                <1> 	mov bl, al
  1248 000010A9 BE[BD10]            <1> 	mov si, .banlist
  1249                              <1> 
  1250                              <1> .check_valid_char_loop:
  1251 000010AC AC                  <1> 	lodsb
  1252 000010AD 38D8                <1> 	cmp al, bl
  1253 000010AF 7408                <1> 	je .check_valid_char_fail_pop
  1254                              <1> 
  1255 000010B1 3C00                <1> 	cmp al, 0
  1256 000010B3 75F7                <1> 	jne .check_valid_char_loop
  1257 000010B5 1F                  <1> 	pop ds
  1258 000010B6 61                  <1> 	popa
  1259                              <1> 	
  1260                              <1> .check_valid_char_pass:
  1261 000010B7 F8                  <1> 	clc
  1262 000010B8 C3                  <1> 	ret
  1263                              <1> 
  1264                              <1> .check_valid_char_fail_pop:
  1265 000010B9 1F                  <1> 	pop ds
  1266 000010BA 61                  <1> 	popa
  1267                              <1> 
  1268                              <1> .check_valid_char_fail:
  1269 000010BB F9                  <1> 	stc
  1270 000010BC C3                  <1> 	ret
  1271                              <1> 
  1272 000010BD 222A2B2C2E2F3A3B3C- <1> 	.banlist		db 0x22, "*+,./:;<=>?[\]|", 0
  1272 000010C6 3D3E3F5B5C5D7C00    <1>
  1273 000010CE 554E4E414D45442020- <1> 	.unnamed		db "UNNAMED    ", 0
  1273 000010D7 202000              <1>
  1274                              <1> 
  1275 000010DA 00<rep Dh>          <1> 	int_filename	times 13 db 0
  1276                              <1> 
  1277                              <1> ; --------------------------------------------------------------------------
  1278                              <1> ; int_get_root_entry -- Search RAM copy of root dir for file entry
  1279                              <1> ; IN: DS:AX = filename; OUT: ES:DI = location in DISK_BUFFER of root dir entry,
  1280                              <1> ; or carry set if file not found
  1281                              <1> 
  1282                              <1> int_get_root_entry:
  1283 000010E7 60                  <1> 	pusha
  1284                              <1> 	movs es, cs
    39 000010E8 0E                  <2>  push %2
    40 000010E9 07                  <2>  pop %1
  1285                              <1> 
  1286 000010EA 89C6                <1> 	mov si, ax
  1287                              <1> 
  1288 000010EC B9E000              <1> 	mov cx, 224			; Search all (224) entries
  1289 000010EF BF00E0              <1> 	mov di, DISK_BUFFER	; Point to next root dir entry
  1290                              <1> 
  1291                              <1> .to_next_root_entry:
  1292 000010F2 60                  <1> 	pusha
  1293 000010F3 B90B00              <1> 	mov cx, 11
  1294 000010F6 F3A6                <1> 	rep cmpsb
  1295 000010F8 61                  <1> 	popa
  1296 000010F9 7408                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  1297                              <1> 
  1298 000010FB 83C720              <1> 	add di, 32			; Bump searched entries by 1 (32 bytes/entry)
  1299 000010FE E2F2                <1> 	loop .to_next_root_entry
  1300                              <1> 
  1301 00001100 61                  <1> 	popa
  1302 00001101 F9                  <1> 	stc				; Set carry if entry not found
  1303 00001102 C3                  <1> 	ret
  1304                              <1> 
  1305                              <1> .found_file:
  1306 00001103 2E893E[1011]        <1> 	mov word [cs:.tmp], di	; Restore all registers except for DI
  1307 00001108 61                  <1> 	popa
  1308 00001109 2E8B3E[1011]        <1> 	mov word di, [cs:.tmp]
  1309 0000110E F8                  <1> 	clc
  1310 0000110F C3                  <1> 	ret
  1311                              <1> 
  1312 00001110 0000                <1> 	.tmp		dw 0
  1313                              <1> 
  1314                              <1> 
  1315                              <1> ; --------------------------------------------------------------------------
  1316                              <1> ; int_read_fat -- Read FAT entry from floppy into DISK_BUFFER
  1317                              <1> ; IN: None
  1318                              <1> ; OUT: carry set if failure
  1319                              <1> 
  1320                              <1> int_read_fat:
  1321 00001112 6660                <1> 	pushad
  1322 00001114 06                  <1> 	push es
  1323                              <1> 	
  1324                              <1> 	movs es, cs
    39 00001115 0E                  <2>  push %2
    40 00001116 07                  <2>  pop %1
  1325 00001117 66B801000000        <1> 	mov eax, 1
  1326 0000111D B90900              <1> 	mov cx, 9
  1327 00001120 BE00E0              <1> 	mov si, DISK_BUFFER
  1328 00001123 E85800              <1> 	call os_get_boot_disk
  1329 00001126 E8723B              <1> 	call os_disk_read_multiple_sectors		; Read sectors, error status in CF
  1330                              <1> 
  1331 00001129 07                  <1> 	pop es
  1332 0000112A 6661                <1> 	popad
  1333 0000112C C3                  <1> 	ret
  1334                              <1> 
  1335                              <1> 
  1336                              <1> ; --------------------------------------------------------------------------
  1337                              <1> ; int_write_fat -- Save FAT contents from DISK_BUFFER in RAM to disk
  1338                              <1> ; IN: FAT in DISK_BUFFER; OUT: carry set if failure
  1339                              <1> 
  1340                              <1> int_write_fat:
  1341 0000112D 6660                <1> 	pushad
  1342 0000112F 06                  <1> 	push es
  1343                              <1> 	
  1344                              <1> 	movs es, cs
    39 00001130 0E                  <2>  push %2
    40 00001131 07                  <2>  pop %1
  1345 00001132 66B801000000        <1> 	mov eax, 1
  1346 00001138 B90900              <1> 	mov cx, 9
  1347 0000113B BE00E0              <1> 	mov si, DISK_BUFFER
  1348 0000113E E83D00              <1> 	call os_get_boot_disk
  1349 00001141 E8883B              <1> 	call os_disk_write_multiple_sectors		; Write sectors, error status in CF
  1350                              <1> 
  1351 00001144 07                  <1> 	pop es
  1352 00001145 6661                <1> 	popad
  1353 00001147 C3                  <1> 	ret
  1354                              <1> 
  1355                              <1> 
  1356                              <1> ; --------------------------------------------------------------------------
  1357                              <1> ; int_read_root_dir -- Get the root directory contents
  1358                              <1> ; IN: None
  1359                              <1> ; OUT: root directory contents in DISK_BUFFER, carry set if error
  1360                              <1> 
  1361                              <1> int_read_root_dir:
  1362 00001148 6660                <1> 	pushad
  1363 0000114A 06                  <1> 	push es
  1364                              <1> 	
  1365                              <1> 	movs es, cs
    39 0000114B 0E                  <2>  push %2
    40 0000114C 07                  <2>  pop %1
  1366 0000114D 66B813000000        <1> 	mov eax, 19
  1367 00001153 B90E00              <1> 	mov cx, 14
  1368 00001156 BE00E0              <1> 	mov si, DISK_BUFFER
  1369 00001159 E82200              <1> 	call os_get_boot_disk
  1370 0000115C E83C3B              <1> 	call os_disk_read_multiple_sectors		; Read sectors, error status in CF
  1371                              <1> 
  1372 0000115F 07                  <1> 	pop es
  1373 00001160 6661                <1> 	popad
  1374 00001162 C3                  <1> 	ret
  1375                              <1> 
  1376                              <1> 
  1377                              <1> ; --------------------------------------------------------------------------
  1378                              <1> ; int_write_root_dir -- Write root directory contents from DISK_BUFFER to disk
  1379                              <1> ; IN: root dir copy in DISK_BUFFER; OUT: carry set if error
  1380                              <1> 
  1381                              <1> int_write_root_dir:
  1382 00001163 6660                <1> 	pushad
  1383 00001165 06                  <1> 	push es
  1384                              <1> 	
  1385                              <1> 	movs es, cs
    39 00001166 0E                  <2>  push %2
    40 00001167 07                  <2>  pop %1
  1386 00001168 66B813000000        <1> 	mov eax, 19
  1387 0000116E B90E00              <1> 	mov cx, 14
  1388 00001171 BE00E0              <1> 	mov si, DISK_BUFFER
  1389 00001174 E80700              <1> 	call os_get_boot_disk
  1390 00001177 E8523B              <1> 	call os_disk_write_multiple_sectors		; Write sectors, error status in CF
  1391                              <1> 
  1392 0000117A 07                  <1> 	pop es
  1393 0000117B 6661                <1> 	popad
  1394 0000117D C3                  <1> 	ret
  1395                              <1> 
  1396                              <1> 
  1397                              <1> ; --------------------------------------------------------------------------
  1398                              <1> ; os_get_boot_disk -- Returns the boot disk number.
  1399                              <1> ; IN: None
  1400                              <1> ; OUT: DL = boot disk number for use in INT 13h calls
  1401                              <1> 
  1402                              <1> os_get_boot_disk:
  1403 0000117E 2E8A16[8411]        <1> 	mov dl, [cs:bootdev]
  1404 00001183 C3                  <1> 	ret
  1405                              <1> 	
  1406 00001184 00                  <1> 	bootdev db 0			; Boot device number
  1407                              <1> 
  1408                              <1> ; ==================================================================
   522                                  	%INCLUDE "features/keyboard.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Keyboard input handling functions
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; os_wait_for_key -- Waits for keypress and returns key
     7                              <1> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
     8                              <1> ; IN: None
     9                              <1> ; OUT: AX = key pressed, other regs preserved
    10                              <1> 
    11                              <1> os_wait_for_key:
    12 00001185 1E                  <1> 	push ds
    13 00001186 60                  <1> 	pusha
    14                              <1> 	movs ds, cs
    39 00001187 0E                  <2>  push %2
    40 00001188 1F                  <2>  pop %1
    15                              <1> 	
    16                              <1> .try_again:
    17                              <1> 	clr bh
    31 00001189 30FF                <2>  xor %1, %1
    18 0000118B E88500              <1> 	call .screen_power
    19                              <1> 
    20                              <1> 	; Reset the screensaver tick
    21 0000118E 660FB606F2DE        <1> 	movzx eax, byte [CONFIG_SCREENSAVER_MINUTES]
    22 00001194 668B1E[6A47]        <1> 	mov ebx, [current_timer_freq]	; Multiply by the number of ticks per minute
    23 00001199 66F7E3              <1> 	mul ebx
    24 0000119C 66A3[6E47]          <1> 	mov [screensaver_timer], eax	; See "int.asm"
    25                              <1> 	
    26 000011A0 C606[2A12]00        <1> 	mov byte [.scrn_active], 0	; Reset all the screensaver variables
    27                              <1> 
    28 000011A5 A0[6909]            <1> 	mov al, [system_ui_state]				; Save the current screen state, for later
    29 000011A8 A2[2712]            <1> 	mov [.gfx_state], al
    30 000011AB B403                <1> 	mov ah, 03h
    31                              <1> 	clr bh
    31 000011AD 30FF                <2>  xor %1, %1
    32 000011AF CD10                <1> 	int 10h
    33 000011B1 890E[2812]          <1> 	mov [.orig_crsr], cx		; Get the shape of the cursor
    34                              <1> 	
    35                              <1> .loop:
    36 000011B5 F4                  <1> 	hlt							; Halt the CPU for 1/18.2 seconds, to save the CPU usage
    37 000011B6 E82900              <1> 	call .screensaver
    38 000011B9 E87000              <1> 	call os_check_for_key
    39                              <1> 	
    40 000011BC 85C0                <1> 	test ax, ax
    41 000011BE 74F5                <1> 	jz .loop
    42                              <1> 
    43 000011C0 60                  <1> 	pusha
    44 000011C1 B80005              <1> 	mov ax, 0500h
    45 000011C4 CD10                <1> 	int 10h
    46                              <1> 	
    47 000011C6 A0[2712]            <1> 	mov al, [.gfx_state]
    48 000011C9 A2[6909]            <1> 	mov [system_ui_state], al
    49 000011CC 8B0E[2812]          <1> 	mov cx, [.orig_crsr]
    50 000011D0 B401                <1> 	mov ah, 01h
    51 000011D2 CD10                <1> 	int 10h
    52 000011D4 61                  <1> 	popa
    53                              <1> 	
    54 000011D5 803E[2A12]01        <1> 	cmp byte [.scrn_active], 1
    55 000011DA 74AD                <1> 	je .try_again
    56                              <1> 	
    57 000011DC 61                  <1> 	popa
    58 000011DD A1[4B12]            <1> 	mov ax, [os_check_for_key.tmp_buf]
    59 000011E0 1F                  <1> 	pop ds
    60 000011E1 C3                  <1> 	ret
    61                              <1> 	
    62                              <1> .screensaver:
    63 000011E2 66833E[6E47]00      <1> 	cmp dword [screensaver_timer], 0
    64 000011E8 7528                <1> 	jne .good
    65                              <1> 	
    66 000011EA 803EF2DE00          <1> 	cmp byte [CONFIG_SCREENSAVER_MINUTES], 0
    67 000011EF 7421                <1> 	je .good
    68                              <1> 	
    69 000011F1 B40F                <1> 	mov ah, 0Fh
    70 000011F3 CD10                <1> 	int 10h
    71                              <1> 	
    72 000011F5 3C03                <1> 	cmp al, 3
    73 000011F7 7519                <1> 	jne .good
    74                              <1> 	
    75 000011F9 60                  <1> 	pusha
    76 000011FA C606[6909]01        <1> 	mov byte [system_ui_state], 1
    77 000011FF B80105              <1> 	mov ax, 0501h
    78 00001202 CD10                <1> 	int 10h
    79 00001204 E87405              <1> 	call os_hide_cursor
    80 00001207 C606[2A12]01        <1> 	mov byte [.scrn_active], 1
    81                              <1> 
    82 0000120C B704                <1> 	mov bh, 4
    83 0000120E E80200              <1> 	call .screen_power
    84 00001211 61                  <1> 	popa
    85                              <1> 
    86                              <1> .good:
    87 00001212 C3                  <1> 	ret
    88                              <1> 	
    89                              <1> .screen_power:
    90 00001213 3A3E[2B12]          <1> 	cmp bh, [.scrn_power]
    91 00001217 74F9                <1> 	je .good
    92                              <1> 
    93 00001219 60                  <1> 	pusha
    94 0000121A B8104F              <1> 	mov ax, 4F10h
    95 0000121D B301                <1> 	mov bl, 1
    96 0000121F 883E[2B12]          <1> 	mov [.scrn_power], bh
    97 00001223 CD10                <1> 	int 10h
    98 00001225 61                  <1> 	popa
    99 00001226 C3                  <1> 	ret
   100                              <1> 	
   101 00001227 00                  <1> 	.gfx_state		db 0
   102 00001228 0000                <1> 	.orig_crsr		dw 0
   103 0000122A 00                  <1> 	.scrn_active	db 0
   104 0000122B 00                  <1> 	.scrn_power		db 0
   105                              <1> 	
   106                              <1> ; ------------------------------------------------------------------
   107                              <1> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   108                              <1> ; Also handles special keyboard shortcuts.
   109                              <1> ; IN: None
   110                              <1> ; OUT: AX = 0 if no key pressed, otherwise scan code
   111                              <1> 
   112                              <1> os_check_for_key:
   113 0000122C 1E                  <1> 	push ds
   114 0000122D 60                  <1> 	pusha
   115                              <1> 	movs ds, cs
    39 0000122E 0E                  <2>  push %2
    40 0000122F 1F                  <2>  pop %1
   116                              <1> 
   117 00001230 B411                <1> 	mov ah, 11h			; BIOS call to check for key
   118                              <1> 	
   119 00001232 CD16                <1> 	int 16h
   120                              <1> 		
   121 00001234 7410                <1> 	jz .nokey			; If no key, skip to end
   122                              <1> 
   123 00001236 B410                <1> 	mov ah, 10h			; Otherwise get it from buffer
   124 00001238 CD16                <1> 	int 16h
   125                              <1> 
   126 0000123A E81000              <1> 	call int_special_keys
   127                              <1> 
   128 0000123D A3[4B12]            <1> 	mov [.tmp_buf], ax		; Store resulting keypress
   129 00001240 61                  <1> 	popa				; But restore all other regs
   130 00001241 A1[4B12]            <1> 	mov ax, [.tmp_buf]
   131 00001244 1F                  <1> 	pop ds
   132 00001245 C3                  <1> 	ret
   133                              <1> 
   134                              <1> .nokey:
   135 00001246 61                  <1> 	popa
   136 00001247 1F                  <1> 	pop ds
   137                              <1> 	clr ax			; Zero result if no key pressed
    31 00001248 31C0                <2>  xor %1, %1
   138 0000124A C3                  <1> 	ret
   139                              <1> 
   140 0000124B 0000                <1> 	.tmp_buf	dw 0
   141                              <1> 
   142                              <1> 
   143                              <1> ; ==================================================================
   144                              <1> 
   145                              <1> ; ------------------------------------------------------------------
   146                              <1> ; int_special_keys -- Checks for special keys and performs their action.
   147                              <1> ; IN: AX = key
   148                              <1> ; OUT: None, registers preserved
   149                              <1> 
   150                              <1> int_special_keys:
   151 0000124D 60                  <1> 	pusha
   152 0000124E 80FC69              <1> 	cmp ah, 105
   153 00001251 742E                <1> 	je .disable_sound
   154 00001253 80FC6A              <1> 	cmp ah, 106
   155 00001256 7417                <1> 	je .enable_sound
   156 00001258 80FC6B              <1> 	cmp ah, 107
   157 0000125B 7402                <1> 	je .exit_app
   158 0000125D 61                  <1> 	popa
   159 0000125E C3                  <1> 	ret
   160                              <1> 	
   161                              <1> .exit_app:
   162 0000125F 803E[6809]00        <1> 	cmp byte [app_running], 0
   163 00001264 7407                <1> 	je .no_exit
   164                              <1> 	
   165 00001266 8B26[6609]          <1> 	mov sp, [origstack]
   166 0000126A E9BDF0              <1> 	jmp finish
   167                              <1> 	
   168                              <1> .no_exit:
   169 0000126D 61                  <1> 	popa
   170 0000126E C3                  <1> 	ret
   171                              <1> 		
   172                              <1> .enable_sound:
   173 0000126F C606[E023]01        <1> 	mov byte [speaker_unmuted], 1
   174                              <1> 
   175 00001274 A1[DE23]            <1> 	mov ax, [speaker_period]
   176                              <1> 
   177 00001277 83F801              <1> 	cmp ax, 1
   178 0000127A 7403                <1> 	je .no_play_note
   179                              <1> 	
   180 0000127C E86211              <1> 	call os_speaker_raw_period
   181                              <1> 
   182                              <1> .no_play_note:
   183 0000127F EB08                <1> 	jmp .display_speaker
   184                              <1> 	
   185                              <1> .disable_sound:
   186 00001281 C606[E023]00        <1> 	mov byte [speaker_unmuted], 0
   187 00001286 E88711              <1> 	call os_speaker_off
   188                              <1> 
   189                              <1> .display_speaker:
   190 00001289 803E[6909]01        <1> 	cmp byte [system_ui_state], 1
   191 0000128E 741E                <1> 	je .no_display_spkr
   192                              <1> 
   193 00001290 E8CE04              <1> 	call os_get_cursor_pos
   194 00001293 52                  <1> 	push dx
   195 00001294 BA4F00              <1> 	mov dx, 79			; Print the little speaker icon
   196 00001297 E8BE04              <1> 	call os_move_cursor
   197                              <1> 	
   198 0000129A B8170E              <1> 	mov ax, 0E17h
   199                              <1> 	clr bh
    31 0000129D 30FF                <2>  xor %1, %1
   200 0000129F 803E[E023]00        <1> 	cmp byte [speaker_unmuted], 0
   201 000012A4 7402                <1> 	je .no_crossed_spkr
   202                              <1> 	
   203 000012A6 FEC8                <1> 	dec al
   204                              <1> 	
   205                              <1> .no_crossed_spkr:
   206 000012A8 CD10                <1> 	int 10h
   207 000012AA 5A                  <1> 	pop dx
   208 000012AB E8AA04              <1> 	call os_move_cursor
   209                              <1> 	
   210                              <1> .no_display_spkr:
   211 000012AE 61                  <1> 	popa
   212                              <1> 	clr ax
    31 000012AF 31C0                <2>  xor %1, %1
   213 000012B1 C3                  <1> 	ret
   214                              <1> 	
   215                              <1> ; ==================================================================
   216                              <1> 
   523                                  	%INCLUDE "features/math.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Math functions
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; os_get_random -- Return a random integer between low and high (inclusive)
     7                              <1> ; IN: AX = low integer, BX = high integer
     8                              <1> ; OUT: CX = random integer
     9                              <1> 
    10                              <1> os_get_random:
    11 000012B2 52                  <1> 	push dx
    12 000012B3 53                  <1> 	push bx
    13 000012B4 50                  <1> 	push ax
    14                              <1> 
    15 000012B5 29C3                <1> 	sub bx, ax			; We want a number between 0 and (high-low)
    16 000012B7 E80D00              <1> 	call .generate_random
    17 000012BA 89DA                <1> 	mov dx, bx
    18 000012BC 42                  <1> 	inc dx
    19 000012BD F7E2                <1> 	mul dx
    20 000012BF 89D1                <1> 	mov cx, dx
    21                              <1> 
    22 000012C1 58                  <1> 	pop ax
    23 000012C2 5B                  <1> 	pop bx
    24 000012C3 5A                  <1> 	pop dx
    25 000012C4 01C1                <1> 	add cx, ax			; Add the low offset back
    26 000012C6 C3                  <1> 	ret
    27                              <1> 
    28                              <1> .generate_random:
    29 000012C7 52                  <1> 	push dx
    30                              <1> 
    31 000012C8 2EA1[D712]          <1> 	mov ax, [cs:os_random_seed]
    32 000012CC BA8373              <1> 	mov dx, 0x7383			; The magic number (random.org)
    33 000012CF F7E2                <1> 	mul dx				; DX:AX = AX * DX
    34 000012D1 2EA3[D712]          <1> 	mov [cs:os_random_seed], ax
    35                              <1> 
    36 000012D5 5A                  <1>  	pop dx
    37 000012D6 C3                  <1> 	ret
    38                              <1> 
    39 000012D7 8473                <1> 	os_random_seed	dw 0x7384
    40                              <1> 
    41                              <1> ; ------------------------------------------------------------------
    42                              <1> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
    43                              <1> ; IN: AL = BCD number
    44                              <1> ; OUT: AX = integer value
    45                              <1> 
    46                              <1> os_bcd_to_int:
    47 000012D9 51                  <1> 	push cx
    48 000012DA 53                  <1> 	push bx
    49                              <1> 
    50 000012DB 88C3                <1> 	mov bl, al			; Store entire number for now
    51                              <1> 
    52 000012DD 83E00F              <1> 	and ax, 0Fh			; Zero-out high bits
    53 000012E0 89C1                <1> 	mov cx, ax			; CH/CL = lower BCD number, zero extended
    54                              <1> 
    55 000012E2 C0EB04              <1> 	shr bl, 4			; Move higher BCD number into lower bits, zero fill msb
    56 000012E5 B00A                <1> 	mov al, 10
    57 000012E7 F6E3                <1> 	mul bl				; AX = 10 * BL
    58                              <1> 
    59 000012E9 01C8                <1> 	add ax, cx			; Add lower BCD to 10*higher
    60                              <1> 
    61 000012EB 5B                  <1> 	pop bx
    62 000012EC 59                  <1> 	pop cx
    63 000012ED C3                  <1> 	ret
    64                              <1> 
    65                              <1> 
    66                              <1> ; ------------------------------------------------------------------
    67                              <1> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
    68                              <1> ; IN: AL = integer value
    69                              <1> ; OUT: AL = BCD number
    70                              <1> 
    71                              <1> os_int_to_bcd:
    72 000012EE 53                  <1> 	push bx
    73 000012EF 52                  <1> 	push dx
    74                              <1> 
    75 000012F0 0FB6C0              <1> 	movzx ax, al
    76 000012F3 31D2                <1> 	xor dx, dx
    77                              <1> 	
    78 000012F5 BB0A00              <1> 	mov bx, 10
    79 000012F8 F7F3                <1> 	div bx
    80                              <1> 	
    81 000012FA C0E004              <1> 	shl al, 4
    82 000012FD 00D0                <1> 	add al, dl
    83                              <1> 	
    84 000012FF 5A                  <1> 	pop dx
    85 00001300 5B                  <1> 	pop bx
    86 00001301 C3                  <1> 	ret
    87                              <1> 
    88                              <1> 
    89                              <1> ; ------------------------------------------------------------------
    90                              <1> ; os_math_power -- Calculates EAX^EBX.
    91                              <1> ; IN: EAX^EBX = input
    92                              <1> ; OUT: EAX = result
    93                              <1> 
    94                              <1> os_math_power:
    95 00001302 6660                <1> 	pushad
    96 00001304 6683FB01            <1> 	cmp ebx, 1
    97 00001308 7416                <1> 	je .power_end
    98                              <1> 
    99 0000130A 6685DB              <1> 	test ebx, ebx
   100 0000130D 7421                <1> 	jz .zero
   101                              <1> 
   102 0000130F 6689D9              <1> 	mov ecx, ebx				; Prepare the data
   103 00001312 6689C3              <1> 	mov ebx, eax
   104                              <1> 
   105                              <1> .power_loop:
   106 00001315 66F7E3              <1> 	mul ebx
   107 00001318 6649                <1> 	dec ecx
   108                              <1> 
   109 0000131A 6683F901            <1> 	cmp ecx, 1
   110 0000131E 7FF5                <1> 	jnle .power_loop
   111                              <1> 
   112                              <1> .power_end:
   113 00001320 2E66A3[3C13]        <1> 	mov [cs:.tmp_dword], eax
   114 00001325 6661                <1> 	popad
   115 00001327 2E66A1[3C13]        <1> 	mov eax, [cs:.tmp_dword]
   116 0000132C 6631D2              <1> 	xor edx, edx
   117 0000132F C3                  <1> 	ret
   118                              <1> 
   119                              <1> .zero:
   120 00001330 6661                <1> 	popad
   121 00001332 66B801000000        <1> 	mov eax, 1
   122 00001338 6631D2              <1> 	xor edx, edx
   123 0000133B C3                  <1> 	ret
   124                              <1> 	
   125 0000133C 00000000            <1> 	.tmp_dword		dd 0
   126                              <1> 	
   127                              <1> ; ------------------------------------------------------------------
   128                              <1> ; os_math_root -- Approximates the EBXth root of EAX.
   129                              <1> ; IN: EAX = input, EBX = root
   130                              <1> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   131                              <1> 
   132                              <1> os_math_root:
   133 00001340 6660                <1> 	pushad
   134 00001342 6689C1              <1> 	mov ecx, eax				; Prepare the data
   135 00001345 66BE02000000        <1> 	mov esi, 2
   136                              <1> 
   137                              <1> .root_loop:
   138 0000134B 6689F0              <1> 	mov eax, esi
   139 0000134E E8B1FF              <1> 	call os_math_power
   140                              <1> 
   141 00001351 6639C8              <1> 	cmp eax, ecx
   142 00001354 7406                <1> 	je .root_exact
   143 00001356 7F15                <1> 	jg .root_range
   144                              <1> 	
   145 00001358 6646                <1> 	inc esi
   146 0000135A EBEF                <1> 	jmp .root_loop
   147                              <1> 
   148                              <1> .root_exact:
   149 0000135C 2E668936[8113]      <1> 	mov [cs:.tmp_dword], esi
   150 00001362 6661                <1> 	popad
   151 00001364 2E66A1[8113]        <1> 	mov eax, [cs:.tmp_dword]
   152 00001369 6631D2              <1> 	xor edx, edx
   153 0000136C C3                  <1> 	ret
   154                              <1> 
   155                              <1> .root_range:
   156 0000136D 2E668936[8113]      <1> 	mov [cs:.tmp_dword], esi
   157 00001373 6661                <1> 	popad
   158 00001375 2E668B16[8113]      <1> 	mov edx, [cs:.tmp_dword]
   159 0000137B 6689D0              <1> 	mov eax, edx
   160 0000137E 6648                <1> 	dec eax
   161 00001380 C3                  <1> 	ret
   162                              <1> 	
   163 00001381 00000000            <1> 	.tmp_dword		dd 0
   164                              <1> 
   165                              <1> ; ==================================================================
   524                                  	%INCLUDE "features/misc.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Miscellaneous functions
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; os_run_zx7_module -- Decompresses a kernel module and runs it
     7                              <1> ; IN: DS:SI = compressed data
     8                              <1> ; OUT: Whatever the module returns
     9                              <1> 
    10                              <1> os_run_zx7_module:
    11 00001385 60                  <1> 	pusha
    12 00001386 06                  <1> 	push es
    13                              <1> 
    14                              <1> 	movs es, cs
    39 00001387 0E                  <2>  push %2
    40 00001388 07                  <2>  pop %1
    15 00001389 BF0001              <1> 	mov di, 100h
    16 0000138C E89337              <1> 	call os_decompress_zx7
    17                              <1> 	
    18 0000138F 07                  <1> 	pop es
    19 00001390 61                  <1> 	popa
    20 00001391 E9(0001)            <1> 	jmp 100h
    21                              <1> 
    22                              <1> ; ------------------------------------------------------------------
    23                              <1> ; os_read_config_byte -- Reads a byte from the config
    24                              <1> ; IN: BX = offset
    25                              <1> ; OUT: AL = value
    26                              <1> 
    27                              <1> os_read_config_byte:
    28 00001394 2E8A87A8DE          <1> 	mov al, [cs:CONFIG_FILE + bx]
    29 00001399 C3                  <1> 	ret
    30                              <1> 
    31                              <1> ; ------------------------------------------------------------------
    32                              <1> ; os_read_config_word -- Reads a word from the config
    33                              <1> ; IN: BX = offset
    34                              <1> ; OUT: AX = value
    35                              <1> 
    36                              <1> os_read_config_word:
    37 0000139A 2E8B87A8DE          <1> 	mov ax, [cs:CONFIG_FILE + bx]
    38 0000139F C3                  <1> 	ret
    39                              <1> 
    40                              <1> ; ------------------------------------------------------------------
    41                              <1> ; os_write_config_byte -- Writes a byte to the config
    42                              <1> ; NOTE: This will only affect the config in memory,
    43                              <1> ; run os_save_config to save the changes to disk!
    44                              <1> ; IN: BX = offset, AL = value
    45                              <1> ; OUT: None, registers preserved
    46                              <1> 
    47                              <1> os_write_config_byte:
    48 000013A0 2E8887A8DE          <1> 	mov [cs:CONFIG_FILE + bx], al
    49 000013A5 C3                  <1> 	ret
    50                              <1> 
    51                              <1> ; ------------------------------------------------------------------
    52                              <1> ; os_write_config_word -- Writes a byte to the config
    53                              <1> ; NOTE: This will only affect the config in memory,
    54                              <1> ; run os_save_config to save the changes to disk!
    55                              <1> ; IN: BX = offset, AX = value
    56                              <1> ; OUT: None, registers preserved
    57                              <1> 
    58                              <1> os_write_config_word:
    59 000013A6 2E8987A8DE          <1> 	mov [cs:CONFIG_FILE + bx], ax
    60 000013AB C3                  <1> 	ret
    61                              <1> 
    62                              <1> ; ------------------------------------------------------------------
    63                              <1> ; os_save_config -- Saves the current config to disk
    64                              <1> ; OUT: Carry set if error
    65                              <1> 
    66                              <1> os_save_config:
    67 000013AC 60                  <1> 	pusha
    68 000013AD 1E                  <1> 	push ds
    69 000013AE 06                  <1> 	push es
    70                              <1> 	movs ds, cs
    39 000013AF 0E                  <2>  push %2
    40 000013B0 1F                  <2>  pop %1
    71                              <1> 	movs es, cs
    39 000013B1 0E                  <2>  push %2
    40 000013B2 07                  <2>  pop %1
    72                              <1> 
    73 000013B3 B8[DA03]            <1> 	mov ax, system_cfg
    74 000013B6 BBA8DE              <1> 	mov bx, CONFIG_FILE
    75 000013B9 B95300              <1> 	mov cx, CONFIG_FILE_SIZE
    76 000013BC E84BF8              <1> 	call os_write_file
    77                              <1> 
    78 000013BF 07                  <1> 	pop es
    79 000013C0 1F                  <1> 	pop ds
    80 000013C1 61                  <1> 	popa
    81 000013C2 C3                  <1> 	ret
    82                              <1> 
    83                              <1> ; ------------------------------------------------------------------
    84                              <1> ; os_exit -- Exits the application, launches another one (if possible)
    85                              <1> ; IN: AX = if not 0, then ptr to filename of application to be launched,
    86                              <1> ;     BX = 1 if the application calling os_exit should be re-launched after
    87                              <1> ;     the requested application exits
    88                              <1> ; OUT: None, register preserved
    89                              <1> 
    90                              <1> os_exit:
    91                              <1> 	; Mark special exit
    92                              <1> 
    93 000013C3 2EC606[D113]01      <1> 	mov byte [cs:app_exit_special], 1
    94                              <1> 
    95                              <1> 	; Exit the application
    96                              <1> 
    97 000013C9 2E8B26[6609]        <1> 	mov sp, [cs:origstack]
    98 000013CE E959EF              <1> 	jmp finish
    99                              <1> 
   100 000013D1 00                  <1> 	app_exit_special	db 0
   101                              <1> 
   102                              <1> ; ------------------------------------------------------------------
   103                              <1> ; os_clear_registers -- Clear all registers
   104                              <1> ; IN: None
   105                              <1> ; OUT: Cleared registers
   106                              <1> 
   107                              <1> os_clear_registers:
   108 000013D2 6631C0              <1> 	xor eax, eax
   109 000013D5 6631DB              <1> 	xor ebx, ebx
   110 000013D8 6631C9              <1> 	xor ecx, ecx
   111 000013DB 6631D2              <1> 	xor edx, edx
   112 000013DE 6631F6              <1> 	xor esi, esi
   113 000013E1 6631FF              <1> 	xor edi, edi
   114 000013E4 C3                  <1> 	ret
   115                              <1> 
   116                              <1> os_illegal_call:
   117 000013E5 B8[EA13]            <1> 	mov ax, .msg
   118 000013E8 EB3D                <1> 	jmp os_fatal_error
   119                              <1> 	
   120 000013EA 43616C6C6564206120- <1> 	.msg db 'Called a non-existent system function', 0
   120 000013F3 6E6F6E2D6578697374- <1>
   120 000013FC 656E74207379737465- <1>
   120 00001405 6D2066756E6374696F- <1>
   120 0000140E 6E00                <1>
   121                              <1> 	
   122                              <1> ; ------------------------------------------------------------------
   123                              <1> ; os_get_os_name -- Get the OS name string
   124                              <1> ; IN: None
   125                              <1> ; OUT: DS:SI = OS name string, zero-terminated
   126                              <1> 
   127                              <1> os_get_os_name:
   128                              <1> 	movs ds, cs
    39 00001410 0E                  <2>  push %2
    40 00001411 1F                  <2>  pop %1
   129 00001412 BE[1614]            <1> 	mov si, osname
   130 00001415 C3                  <1> 	ret
   131                              <1> 
   132 00001416 4D696368616C4F5320- <1> 	osname	db 'MichalOS ', VERMAJ, '.', VERMIN, 0
   132 0000141F 332E302E32383200    <1>
   133                              <1> 
   134                              <1> ; ------------------------------------------------------------------
   135                              <1> ; os_fatal_error -- Display error message and halt execution
   136                              <1> ; IN: AX = error message string location
   137                              <1> ; OUT: None, as it does not return
   138                              <1> 
   139                              <1> os_fatal_error:
   140                              <1> 	movs ds, cs
    39 00001427 0E                  <2>  push %2
    40 00001428 1F                  <2>  pop %1
   141 00001429 BE[2F14]            <1> 	mov si, .sub_fatalerr_data
   142 0000142C E956FF              <1> 	jmp os_run_zx7_module
   143                              <1> 
   144                              <1> .sub_fatalerr_data:
   145 0000142F <bin 13Ah>          <1> 	incbin "sub_fatalerr.zx7"
   146                              <1> 
   147                              <1> ; ------------------------------------------------------------------
   148                              <1> ; os_get_memory -- Gets the amount of system RAM.
   149                              <1> ; IN: None
   150                              <1> ; OUT: AX = conventional memory (in kB), BX = high memory (in kB)
   151                              <1> 
   152                              <1> os_get_memory:
   153 00001569 60                  <1> 	pusha
   154 0000156A 31C9                <1> 	xor cx, cx
   155 0000156C CD12                <1> 	int 12h					; Get the conventional memory size...
   156 0000156E 2EA3[8515]          <1> 	mov [cs:.conv_mem], ax	; ...and store it
   157                              <1> 	
   158 00001572 B488                <1> 	mov ah, 88h				; Also get the high memory (>1MB)...
   159 00001574 CD15                <1> 	int 15h
   160 00001576 2EA3[8715]          <1> 	mov [cs:.high_mem], ax	; ...and store it too
   161 0000157A 61                  <1> 	popa
   162 0000157B 2EA1[8515]          <1> 	mov ax, [cs:.conv_mem]
   163 0000157F 2E8B1E[8715]        <1> 	mov bx, [cs:.high_mem]
   164 00001584 C3                  <1> 	ret
   165                              <1> 
   166 00001585 0000                <1> 	.conv_mem	dw 0
   167 00001587 0000                <1> 	.high_mem	dw 0
   168                              <1> 
   169                              <1> ; ------------------------------------------------------------------
   170                              <1> ; os_int_1Ah -- Middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
   171                              <1> ; IN/OUT: same as int 1Ah
   172                              <1> 
   173                              <1> os_int_1Ah:
   174 00001589 1E                  <1> 	push ds
   175 0000158A 06                  <1> 	push es
   176 0000158B 60                  <1> 	pusha
   177                              <1> 
   178                              <1> 	movs ds, cs
    39 0000158C 0E                  <2>  push %2
    40 0000158D 1F                  <2>  pop %1
   179                              <1> 	movs es, cs
    39 0000158E 0E                  <2>  push %2
    40 0000158F 07                  <2>  pop %1
   180                              <1> 
   181 00001590 80FC02              <1> 	cmp ah, 2		; Read system time
   182 00001593 741A                <1> 	je .read_time
   183                              <1> 	
   184 00001595 80FC04              <1> 	cmp ah, 4		; Read system date
   185 00001598 7406                <1> 	je .read_date
   186                              <1> 	
   187 0000159A 61                  <1> 	popa
   188 0000159B 07                  <1> 	pop es
   189 0000159C 1F                  <1> 	pop ds
   190 0000159D CD1A                <1> 	int 1Ah
   191 0000159F C3                  <1> 	ret
   192                              <1> 	
   193                              <1> .read_date:
   194 000015A0 E81B00              <1> 	call .update_time
   195                              <1> 
   196 000015A3 61                  <1> 	popa
   197 000015A4 8B16[8216]          <1> 	mov dx, [.days]
   198 000015A8 8B0E[8416]          <1> 	mov cx, [.years]
   199 000015AC 07                  <1> 	pop es
   200 000015AD 1F                  <1> 	pop ds
   201 000015AE C3                  <1> 	ret
   202                              <1> 	
   203                              <1> .read_time:
   204 000015AF E80C00              <1> 	call .update_time
   205                              <1> 	
   206 000015B2 61                  <1> 	popa
   207 000015B3 8A36[7F16]          <1> 	mov dh, [.seconds]
   208 000015B7 8B0E[8016]          <1> 	mov cx, [.minutes]
   209 000015BB 07                  <1> 	pop es
   210 000015BC 1F                  <1> 	pop ds
   211 000015BD C3                  <1> 	ret
   212                              <1> 
   213                              <1> .update_time:
   214 000015BE B404                <1> 	mov ah, 4
   215 000015C0 CD1A                <1> 	int 1Ah
   216 000015C2 8916[8216]          <1> 	mov [.days], dx
   217 000015C6 890E[8416]          <1> 	mov [.years], cx
   218                              <1> 	
   219 000015CA B402                <1> 	mov ah, 2
   220 000015CC CD1A                <1> 	int 1Ah
   221                              <1> 
   222 000015CE 8836[7F16]          <1> 	mov [.seconds], dh
   223 000015D2 890E[8016]          <1> 	mov [.minutes], cx
   224                              <1> 	
   225                              <1> 	; Convert all of these values from BCD to integers
   226                              <1> 	
   227 000015D6 B90700              <1> 	mov cx, 7
   228 000015D9 BE[7F16]            <1> 	mov si, .seconds
   229 000015DC 89F7                <1> 	mov di, si
   230                              <1> 	
   231                              <1> .loop:
   232 000015DE AC                  <1> 	lodsb
   233 000015DF E8F7FC              <1> 	call os_bcd_to_int
   234 000015E2 AA                  <1> 	stosb
   235                              <1> 	
   236 000015E3 E2F9                <1> 	loop .loop
   237                              <1> 	
   238                              <1> 	; Calculate the time with the time offset
   239                              <1> 	
   240 000015E5 A1F9DE              <1> 	mov ax, [CONFIG_TIMEZONE_OFFSET]
   241 000015E8 A90080              <1> 	test ax, 8000h
   242 000015EB 7541                <1> 	jnz .subtract
   243                              <1> 	
   244 000015ED 31D2                <1> 	xor dx, dx
   245 000015EF BB3C00              <1> 	mov bx, 60
   246 000015F2 F7F3                <1> 	div bx
   247                              <1> 	
   248                              <1> 	; DX = value to add to minutes
   249                              <1> 	; AX = value to add to hours
   250                              <1> 	
   251 000015F4 0016[8016]          <1> 	add [.minutes], dl
   252 000015F8 803E[8016]3C        <1> 	cmp byte [.minutes], 60
   253 000015FD 7C19                <1> 	jl .add_minutes_ok
   254                              <1> 	
   255 000015FF 802E[8016]3C        <1> 	sub byte [.minutes], 60
   256 00001604 FE06[8116]          <1> 	inc byte [.hours]
   257 00001608 803E[8116]18        <1> 	cmp byte [.hours], 24
   258 0000160D 7C09                <1> 	jl .add_minutes_ok
   259                              <1> 	
   260 0000160F 802E[8116]18        <1> 	sub byte [.hours], 24
   261 00001614 FE06[8216]          <1> 	inc byte [.days]
   262                              <1> 	
   263                              <1> 	; At this point I don't care
   264                              <1> 	
   265                              <1> .add_minutes_ok:
   266 00001618 0006[8116]          <1> 	add [.hours], al
   267 0000161C 803E[8116]18        <1> 	cmp byte [.hours], 24
   268 00001621 7C4C                <1> 	jl .encodeandexit
   269                              <1> 	
   270 00001623 802E[8116]18        <1> 	sub byte [.hours], 24
   271 00001628 FE06[8216]          <1> 	inc byte [.days]
   272                              <1> 	
   273 0000162C EB41                <1> 	jmp .encodeandexit
   274                              <1> 	
   275                              <1> .subtract:
   276 0000162E F7D8                <1> 	neg ax
   277                              <1> 	
   278 00001630 31D2                <1> 	xor dx, dx
   279 00001632 BB3C00              <1> 	mov bx, 60
   280 00001635 F7F3                <1> 	div bx
   281                              <1> 	
   282                              <1> 	; DX = value to subtract from minutes
   283                              <1> 	; AX = value to subtract from hours
   284                              <1> 
   285 00001637 2816[8016]          <1> 	sub [.minutes], dl
   286 0000163B 803E[8016]00        <1> 	cmp byte [.minutes], 0
   287 00001640 7D19                <1> 	jge .sub_minutes_ok
   288                              <1> 	
   289                              <1> 	
   290 00001642 8006[8016]3C        <1> 	add byte [.minutes], 60
   291 00001647 FE0E[8116]          <1> 	dec byte [.hours]
   292 0000164B 803E[8116]00        <1> 	cmp byte [.hours], 0
   293 00001650 7D09                <1> 	jge .sub_minutes_ok
   294                              <1> 	
   295 00001652 8006[8116]18        <1> 	add byte [.hours], 24
   296 00001657 FE0E[8216]          <1> 	dec byte [.days]
   297                              <1> 	
   298                              <1> 	; At this point I don't care
   299                              <1> 	
   300                              <1> .sub_minutes_ok:
   301 0000165B 2806[8116]          <1> 	sub [.hours], al
   302 0000165F 803E[8116]00        <1> 	cmp byte [.hours], 0
   303 00001664 7D09                <1> 	jge .encodeandexit
   304                              <1> 	
   305 00001666 8006[8116]18        <1> 	add byte [.hours], 24
   306 0000166B FE0E[8216]          <1> 	dec byte [.days]
   307                              <1> 	
   308                              <1> .encodeandexit:
   309 0000166F B90700              <1> 	mov cx, 7
   310 00001672 BE[7F16]            <1> 	mov si, .seconds
   311 00001675 89F7                <1> 	mov di, si
   312                              <1> 	
   313                              <1> .encode_loop:
   314 00001677 AC                  <1> 	lodsb
   315 00001678 E873FC              <1> 	call os_int_to_bcd
   316 0000167B AA                  <1> 	stosb
   317 0000167C E2F9                <1> 	loop .encode_loop
   318                              <1> 
   319 0000167E C3                  <1> 	ret
   320                              <1> 	
   321                              <1> 	
   322 0000167F 00                  <1> 	.seconds	db 0
   323 00001680 00                  <1> 	.minutes	db 0
   324 00001681 00                  <1> 	.hours		db 0
   325 00001682 00                  <1> 	.days		db 0
   326 00001683 00                  <1> 	.months		db 0
   327 00001684 00                  <1> 	.years		db 0
   328 00001685 00                  <1> 	.centuries	db 0
   329                              <1> 
   330                              <1> ; ------------------------------------------------------------------
   331                              <1> ; int_set_stack -- Sets up allocation for the system stack.
   332                              <1> ; IN: SI = return address, AX = RAM top (in 16-byte blocks),
   333                              <1> ;     BX = number of 16-byte blocks to allocate (up to 4096 blocks, 64 kB)
   334                              <1> ; *** DO NOT CALL, USE JMP AND PASS RETURN ADDRESS!!! ***
   335                              <1> 
   336                              <1> int_set_stack:
   337 00001686 FA                  <1> 	cli
   338 00001687 29D8                <1> 	sub ax, bx	; Calculate the stack segment by subtracting the ram top and blocks
   339 00001689 8ED0                <1> 	mov ss, ax
   340                              <1> 
   341 0000168B C1E304              <1> 	shl bx, 4	; Calculate the top stack pointer value
   342 0000168E 83EB02              <1> 	sub bx, 2
   343 00001691 89DC                <1> 	mov sp, bx
   344 00001693 FB                  <1> 	sti
   345 00001694 FFE6                <1> 	jmp si
   346                              <1> 
   347                              <1> ; Generic jump location for function termination
   348                              <1> 
   349                              <1> int_popa_ret:
   350 00001696 61                  <1> 	popa
   351 00001697 C3                  <1> 	ret
   352                              <1> 
   353                              <1> ; ==================================================================
   525                                  	%INCLUDE "features/ports.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Port I/O functions
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; os_serial_port_enable -- Set up the serial port for transmitting data
     7                              <1> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
     8                              <1> ; OUT: None, registers preserved
     9                              <1> 
    10                              <1> os_serial_port_enable:
    11 00001698 60                  <1> 	pusha
    12                              <1> 
    13                              <1> 	; TODO: Access raw ports!
    14                              <1> 
    15                              <1> 	clr dx			; Configure serial port 1
    31 00001699 31D2                <2>  xor %1, %1
    16 0000169B 83F801              <1> 	cmp ax, 1
    17 0000169E 7405                <1> 	je .slow_mode
    18                              <1> 
    19 000016A0 B8E300              <1> 	mov ax, 11100011b		; 9600 baud, no parity, 8 data bits, 1 stop bit
    20 000016A3 EB03                <1> 	jmp .finish
    21                              <1> 
    22                              <1> .slow_mode:
    23 000016A5 B88300              <1> 	mov ax, 10000011b		; 1200 baud, no parity, 8 data bits, 1 stop bit	
    24                              <1> 
    25                              <1> .finish:
    26 000016A8 CD14                <1> 	int 14h
    27                              <1> 
    28 000016AA 61                  <1> 	popa
    29 000016AB C3                  <1> 	ret
    30                              <1> 
    31                              <1> 
    32                              <1> ; ------------------------------------------------------------------
    33                              <1> ; os_send_via_serial -- Send a byte via the serial port
    34                              <1> ; IN: AL = byte to send via serial
    35                              <1> ; OUT: AH = Bit 7 clear on success
    36                              <1> 
    37                              <1> os_send_via_serial:
    38 000016AC 60                  <1> 	pusha
    39                              <1> 
    40                              <1> 	; TODO: Access raw ports!
    41                              <1> 
    42 000016AD B401                <1> 	mov ah, 01h
    43                              <1> 	clr dx			; COM1
    31 000016AF 31D2                <2>  xor %1, %1
    44                              <1> 
    45 000016B1 CD14                <1> 	int 14h
    46                              <1> 
    47 000016B3 2E8826[BF16]        <1> 	mov [cs:.tmp], ah
    48                              <1> 
    49 000016B8 61                  <1> 	popa
    50                              <1> 
    51 000016B9 2E8A26[BF16]        <1> 	mov ah, [cs:.tmp]
    52                              <1> 
    53 000016BE C3                  <1> 	ret
    54                              <1> 
    55 000016BF 00                  <1> 	.tmp db 0
    56                              <1> 
    57                              <1> 
    58                              <1> ; ------------------------------------------------------------------
    59                              <1> ; os_get_via_serial -- Get a byte from the serial port
    60                              <1> ; IN: None
    61                              <1> ; OUT: AL = byte that was received, AH = Bit 7 clear on success
    62                              <1> 
    63                              <1> os_get_via_serial:
    64 000016C0 60                  <1> 	pusha
    65                              <1> 
    66                              <1> 	; TODO: Access raw ports!
    67                              <1> 
    68 000016C1 B402                <1> 	mov ah, 02h
    69                              <1> 	clr dx			; COM1
    31 000016C3 31D2                <2>  xor %1, %1
    70                              <1> 
    71 000016C5 CD14                <1> 	int 14h
    72                              <1> 
    73 000016C7 2EA3[D116]          <1> 	mov [cs:.tmp], ax
    74                              <1> 
    75 000016CB 61                  <1> 	popa
    76                              <1> 
    77 000016CC 2EA1[D116]          <1> 	mov ax, [cs:.tmp]
    78                              <1> 
    79 000016D0 C3                  <1> 	ret
    80                              <1> 
    81                              <1> 
    82 000016D1 0000                <1> 	.tmp dw 0
    83                              <1> 
    84                              <1> ; ==================================================================
   526                                  	%INCLUDE "features/screen.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Text display output functions
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; os_putchar -- Puts a character on the screen
     7                              <1> ; IN: AL = character
     8                              <1> ; OUT: None, registers preserved
     9                              <1> 
    10                              <1> os_putchar:
    11 000016D3 60                  <1> 	pusha
    12                              <1> 
    13                              <1> .no_pusha:
    14 000016D4 B40E                <1> 	mov ah, 0Eh
    15 000016D6 BB0F00              <1> 	mov bx, 15
    16 000016D9 CD10                <1> 	int 10h
    17 000016DB 61                  <1> 	popa
    18 000016DC C3                  <1> 	ret
    19                              <1> 
    20                              <1> ; ------------------------------------------------------------------
    21                              <1> ; os_put_chars -- Puts up to a set amount of characters on the screen
    22                              <1> ; IN: BL = terminator, DS:SI = location, CX = character count
    23                              <1> ; OUT: None, registers preserved
    24                              <1> 
    25                              <1> os_put_chars:
    26 000016DD 60                  <1> 	pusha
    27                              <1> 	
    28                              <1> .no_pusha:
    29                              <1> .loop:
    30 000016DE AC                  <1> 	lodsb
    31 000016DF 38D8                <1> 	cmp al, bl
    32 000016E1 7405                <1> 	je .exit
    33                              <1> 	
    34 000016E3 E8EDFF              <1> 	call os_putchar
    35                              <1> 	
    36 000016E6 E2F6                <1> 	loop .loop
    37                              <1> 
    38                              <1> .exit:
    39 000016E8 61                  <1> 	popa
    40 000016E9 C3                  <1> 	ret
    41                              <1> 
    42                              <1> ; ------------------------------------------------------------------
    43                              <1> ; os_print_string -- Displays text
    44                              <1> ; IN: DS:SI = message location (zero-terminated string)
    45                              <1> ; OUT: None, registers preserved
    46                              <1> 
    47                              <1> os_print_string:
    48 000016EA 60                  <1> 	pusha
    49                              <1> 
    50                              <1> 	clr bl
    31 000016EB 30DB                <2>  xor %1, %1
    51                              <1> 	clr cx
    31 000016ED 31C9                <2>  xor %1, %1
    52                              <1> 
    53 000016EF EBED                <1> 	jmp os_put_chars.no_pusha
    54                              <1> 
    55                              <1> ; ------------------------------------------------------------------
    56                              <1> ; os_print_string_box -- Displays text inside a text-box.
    57                              <1> ; IN: DS:SI = message location (zero-terminated string), DL = left alignment
    58                              <1> ; OUT: None, registers preserved
    59                              <1> 
    60                              <1> os_print_string_box:
    61 000016F1 60                  <1> 	pusha
    62 000016F2 88D1                <1> 	mov cl, dl
    63                              <1> 
    64                              <1> .repeat:
    65 000016F4 AC                  <1> 	lodsb				; Get char from string
    66 000016F5 84C0                <1> 	test al, al
    67 000016F7 749D                <1> 	jz int_popa_ret		; If char is zero, end of string
    68                              <1> 
    69 000016F9 3C0D                <1> 	cmp al, 13
    70 000016FB 7405                <1> 	je .cr
    71                              <1> 	
    72 000016FD E8D3FF              <1> 	call os_putchar
    73 00001700 EBF2                <1> 	jmp .repeat			; And move on to next char
    74                              <1> 
    75                              <1> .cr:
    76 00001702 E85C00              <1> 	call os_get_cursor_pos
    77 00001705 88CA                <1> 	mov dl, cl
    78 00001707 E84E00              <1> 	call os_move_cursor
    79 0000170A EBE8                <1> 	jmp .repeat
    80                              <1> 
    81                              <1> ; ------------------------------------------------------------------
    82                              <1> ; os_format_string -- Displays colored text
    83                              <1> ; IN: DS:SI = message location (zero-terminated string), BL = text color
    84                              <1> ; OUT: None, registers preserved
    85                              <1> 
    86                              <1> os_format_string:
    87 0000170C 60                  <1> 	pusha
    88                              <1> 
    89 0000170D B409                <1> 	mov ah, 09h			; int 09h
    90                              <1> 	clr bh
    31 0000170F 30FF                <2>  xor %1, %1
    91 00001711 B90100              <1> 	mov cx, 1
    92 00001714 E84A00              <1> 	call os_get_cursor_pos
    93                              <1> 	
    94                              <1> .repeat:
    95 00001717 AC                  <1> 	lodsb				; Get char from string
    96 00001718 3C0D                <1> 	cmp al, 13
    97 0000171A 7413                <1> 	je .cr
    98 0000171C 3C0A                <1> 	cmp al, 10
    99 0000171E 7416                <1> 	je .lf
   100 00001720 84C0                <1> 	test al, al
   101 00001722 0F8470FF            <1> 	jz int_popa_ret		; If char is zero, end of string
   102                              <1> 
   103 00001726 CD10                <1> 	int 10h				; Otherwise, print it
   104                              <1> 
   105 00001728 FEC2                <1> 	inc dl
   106 0000172A E82B00              <1> 	call os_move_cursor
   107                              <1> 	
   108 0000172D EBE8                <1> 	jmp .repeat			; And move on to next char
   109                              <1> 	
   110                              <1> .cr:
   111                              <1> 	clr dl
    31 0000172F 30D2                <2>  xor %1, %1
   112 00001731 E82400              <1> 	call os_move_cursor
   113 00001734 EBE1                <1> 	jmp .repeat
   114                              <1> 
   115                              <1> .lf:
   116 00001736 FEC6                <1> 	inc dh
   117 00001738 E81D00              <1> 	call os_move_cursor
   118 0000173B EBDA                <1> 	jmp .repeat
   119                              <1> 	
   120                              <1> 
   121                              <1> ; ------------------------------------------------------------------
   122                              <1> ; os_clear_screen -- Clears the screen to background
   123                              <1> ; IN/OUT: None, registers preserved
   124                              <1> 
   125                              <1> os_clear_screen:
   126 0000173D 60                  <1> 	pusha
   127                              <1> 
   128                              <1> 	clr dx				; Position cursor at top-left
    31 0000173E 31D2                <2>  xor %1, %1
   129 00001740 E81500              <1> 	call os_move_cursor
   130                              <1> 
   131                              <1> 	mov16 ax, 0, 6		; Scroll full-screen
    35 00001743 B80006              <2>  mov %1, (%2 + %3 * 256)
   132 00001746 B707                <1> 	mov bh, 7
   133                              <1> 	mov16 cx, 0, 0		; Top-left
    35 00001748 B90000              <2>  mov %1, (%2 + %3 * 256)
   134                              <1> 	mov16 dx, 79, 24	; Bottom-right
    35 0000174B BA4F18              <2>  mov %1, (%2 + %3 * 256)
   135 0000174E CD10                <1> 	int 10h
   136                              <1> 
   137 00001750 2EC606[6909]01      <1> 	mov byte [cs:system_ui_state], 1	; Assume that an application clearing 
   138                              <1> 										; the screen doesn't want to refresh time		
   139 00001756 61                  <1> 	popa
   140 00001757 C3                  <1> 	ret
   141                              <1> 
   142                              <1> 
   143                              <1> ; ------------------------------------------------------------------
   144                              <1> ; os_move_cursor -- Moves cursor in text mode
   145                              <1> ; IN: DH, DL = row, column
   146                              <1> ; OUT: None, registers preserved
   147                              <1> 
   148                              <1> os_move_cursor:
   149 00001758 60                  <1> 	pusha
   150                              <1> 
   151                              <1> .no_pusha:
   152                              <1> 	clr bh
    31 00001759 30FF                <2>  xor %1, %1
   153 0000175B B402                <1> 	mov ah, 2
   154 0000175D CD10                <1> 	int 10h				; BIOS interrupt to move cursor
   155                              <1> 
   156 0000175F 61                  <1> 	popa
   157 00001760 C3                  <1> 	ret
   158                              <1> 
   159                              <1> 
   160                              <1> ; ------------------------------------------------------------------
   161                              <1> ; os_get_cursor_pos -- Return position of text cursor
   162                              <1> ; IN: None
   163                              <1> ; OUT: DH, DL = row, column
   164                              <1> 
   165                              <1> os_get_cursor_pos:
   166 00001761 60                  <1> 	pusha
   167                              <1> 
   168                              <1> 	clr bh
    31 00001762 30FF                <2>  xor %1, %1
   169 00001764 B403                <1> 	mov ah, 3
   170 00001766 CD10                <1> 	int 10h				; BIOS interrupt to get cursor position
   171                              <1> 
   172 00001768 89E3                <1> 	mov bx, sp
   173 0000176A 3689570A            <1> 	mov [ss:bx + 10], dx
   174 0000176E 61                  <1> 	popa
   175 0000176F C3                  <1> 	ret
   176                              <1> 
   177                              <1> 
   178                              <1> ; ------------------------------------------------------------------
   179                              <1> ; os_show_cursor -- Turns on cursor in text mode
   180                              <1> ; IN/OUT: None, registers preserved
   181                              <1> 
   182                              <1> os_show_cursor:
   183 00001770 60                  <1> 	pusha
   184                              <1> 
   185                              <1> .no_pusha:
   186                              <1> 	mov16 cx, 7, 6
    35 00001771 B90706              <2>  mov %1, (%2 + %3 * 256)
   187                              <1> 	mov16 ax, 3, 1
    35 00001774 B80301              <2>  mov %1, (%2 + %3 * 256)
   188 00001777 CD10                <1> 	int 10h
   189                              <1> 
   190 00001779 61                  <1> 	popa
   191 0000177A C3                  <1> 	ret
   192                              <1> 
   193                              <1> 
   194                              <1> ; ------------------------------------------------------------------
   195                              <1> ; os_hide_cursor -- Turns off cursor in text mode
   196                              <1> ; IN/OUT: None, registers preserved
   197                              <1> 
   198                              <1> os_hide_cursor:
   199 0000177B 60                  <1> 	pusha
   200                              <1> 
   201 0000177C B520                <1> 	mov ch, 32
   202                              <1> 	mov16 ax, 3, 1	; AL must be video mode for buggy BIOSes!
    35 0000177E B80301              <2>  mov %1, (%2 + %3 * 256)
   203 00001781 CD10                <1> 	int 10h
   204                              <1> 
   205 00001783 61                  <1> 	popa
   206 00001784 C3                  <1> 	ret
   207                              <1> 
   208                              <1> 
   209                              <1> ; ------------------------------------------------------------------
   210                              <1> ; os_draw_block -- Render block of specified colour
   211                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   212                              <1> ; OUT: None, registers preserved
   213                              <1> 
   214                              <1> os_draw_block:
   215 00001785 60                  <1> 	pusha
   216                              <1> 
   217                              <1> .more:
   218 00001786 E8CFFF              <1> 	call os_move_cursor		; Move to block starting position
   219                              <1> 
   220                              <1> 	mov16 ax, ' ', 09h			; Draw colour section
    35 00001789 B82009              <2>  mov %1, (%2 + %3 * 256)
   221                              <1> 	clr bh
    31 0000178C 30FF                <2>  xor %1, %1
   222 0000178E 89F1                <1> 	mov cx, si
   223 00001790 CD10                <1> 	int 10h
   224                              <1> 
   225 00001792 FEC6                <1> 	inc dh				; Get ready for next line
   226                              <1> 
   227 00001794 0FB6C6              <1> 	movzx ax, dh		; Get current Y position into DL
   228 00001797 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
   229 00001799 75EB                <1> 	jne .more			; If not, keep drawing
   230                              <1> 
   231 0000179B 61                  <1> 	popa
   232 0000179C C3                  <1> 	ret
   233                              <1> 
   234                              <1> 
   235                              <1> ; ------------------------------------------------------------------
   236                              <1> ; os_file_selector -- Show a file selection dialog
   237                              <1> ; IN: None
   238                              <1> ; OUT: AX = location of filename string (or carry set if Esc pressed)
   239                              <1> 
   240                              <1> os_file_selector:
   241 0000179D 60                  <1> 	pusha
   242                              <1> 	clr bx
    31 0000179E 31DB                <2>  xor %1, %1
   243 000017A0 EB01                <1> 	jmp os_file_selector_filtered.no_pusha
   244                              <1> 
   245                              <1> ; ------------------------------------------------------------------
   246                              <1> ; os_file_selector_filtered -- Show a file selection dialog only 
   247                              <1> ; with files mathing the filter
   248                              <1> ; IN: ES:BX = location of file extension list (0 if none)
   249                              <1> ; OUT: DS:AX = location of filename string (or carry set if Esc pressed)
   250                              <1> 
   251                              <1> os_file_selector_filtered:
   252 000017A2 60                  <1> 	pusha
   253                              <1> 
   254                              <1> .no_pusha:
   255 000017A3 2E8C06[4E1A]        <1> 	mov [cs:.extension_list_sgmt], es
   256                              <1> 
   257 000017A8 06                  <1> 	push es
   258                              <1> 	movs es, cs
    39 000017A9 0E                  <2>  push %2
    40 000017AA 07                  <2>  pop %1
   259                              <1> 	movs ds, cs
    39 000017AB 0E                  <2>  push %2
    40 000017AC 1F                  <2>  pop %1
   260                              <1> 
   261                              <1> 	; Remember the filter list for later
   262                              <1> 
   263 000017AD 891E[4C1A]          <1> 	mov [.extension_list], bx
   264                              <1> 
   265                              <1> 	; Get volume name
   266                              <1> 
   267 000017B1 6660                <1> 	pushad
   268 000017B3 66B800000000        <1> 	mov eax, 0					; Load first disk sector into RAM
   269 000017B9 8A16[8411]          <1> 	mov dl, [bootdev]
   270 000017BD BE00E0              <1> 	mov si, DISK_BUFFER
   271 000017C0 E8C134              <1> 	call os_disk_read_sector
   272                              <1> 
   273 000017C3 BE2BE0              <1> 	mov si, DISK_BUFFER + 2Bh	; Disk label starts here
   274                              <1> 
   275 000017C6 BF[3E1A]            <1> 	mov di, .volname
   276 000017C9 B90B00              <1> 	mov cx, 11					; Copy 11 chars of it
   277 000017CC F3A4                <1> 	rep movsb
   278 000017CE 6661                <1> 	popad
   279                              <1> 	
   280 000017D0 C706[2A1A]0000      <1> 	mov word [.filename], 0		; Terminate string in case user leaves without choosing
   281                              <1> 
   282 000017D6 E833F2              <1> 	call os_report_free_space
   283 000017D9 D1E8                <1> 	shr ax, 1					; Sectors -> kB
   284 000017DB A3[4A1A]            <1> 	mov [.freespace], ax
   285                              <1> 	
   286                              <1> 	; Create the filename index list
   287                              <1> 
   288 000017DE E867F9              <1> 	call int_read_root_dir		; Get the files into the buffer
   289                              <1> 
   290 000017E1 BE00E0              <1> 	mov si, DISK_BUFFER			; Raw directory buffer
   291 000017E4 BF00FC              <1> 	mov di, 64512				; Buffer for indexes
   292                              <1> 	clr cx						; Number of found files
    31 000017E7 31C9                <2>  xor %1, %1
   293                              <1> 
   294                              <1> .index_loop:
   295 000017E9 81FE00FC            <1> 	cmp si, 64512			; Are we done looping through the directory?
   296 000017ED 744D                <1> 	je .done
   297                              <1> 
   298 000017EF 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   299 000017F2 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   300 000017F4 7441                <1> 	je .skip
   301                              <1> 
   302 000017F6 A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
   303 000017F8 753D                <1> 	jnz .skip			; Yes, ignore it
   304                              <1> 
   305 000017FA 8A04                <1> 	mov al, [si]
   306 000017FC 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   307 000017FE 7437                <1> 	je .skip
   308                              <1> 
   309 00001800 84C0                <1> 	test al, al			; 1st byte = entry never used
   310 00001802 7438                <1> 	jz .done
   311                              <1> 
   312 00001804 60                  <1> 	pusha
   313                              <1> 
   314 00001805 06                  <1> 	push es
   315 00001806 8E06[4E1A]          <1> 	mov es, [.extension_list_sgmt]
   316 0000180A 8B1E[4C1A]          <1> 	mov bx, [.extension_list]
   317                              <1> 
   318 0000180E 85DB                <1> 	test bx, bx			; Check if we are supposed to filter the filenames
   319 00001810 741E                <1> 	jz .no_extension_check
   320                              <1> 
   321 00001812 260FB60F            <1> 	movzx cx, byte [es:bx]	; Cycle through all filters
   322                              <1> 
   323 00001816 89DF                <1> 	mov di, bx
   324 00001818 83EF03              <1> 	sub di, 3			; 1 - 4 = -3 (skip header, prepare for addition)
   325                              <1> 
   326 0000181B 83C608              <1> 	add si, 8			; Extension
   327                              <1> 
   328                              <1> .extension_loop:
   329 0000181E 83C704              <1> 	add di, 4
   330                              <1> 
   331 00001821 60                  <1> 	pusha
   332 00001822 B90300              <1> 	mov cx, 3
   333 00001825 F3A6                <1> 	rep cmpsb
   334 00001827 61                  <1> 	popa
   335 00001828 7406                <1> 	je .no_extension_check
   336                              <1> 	
   337 0000182A E2F2                <1> 	loop .extension_loop
   338                              <1> 	
   339 0000182C 07                  <1> 	pop es
   340 0000182D 61                  <1> 	popa
   341 0000182E EB07                <1> 	jmp .skip
   342                              <1> 
   343                              <1> .no_extension_check:
   344 00001830 07                  <1> 	pop es
   345 00001831 61                  <1> 	popa
   346                              <1> 
   347 00001832 41                  <1> 	inc cx				; Increment the number of discovered files
   348 00001833 89F0                <1> 	mov ax, si			; Store the filename pointer into the buffer
   349 00001835 3EAB                <1> 	ds stosw
   350                              <1> 
   351                              <1> .skip:
   352 00001837 83C620              <1> 	add si, 32		; Skip to the next file
   353 0000183A EBAD                <1> 	jmp .index_loop
   354                              <1> 
   355                              <1> .done:
   356                              <1> 	; Let the user select a file
   357                              <1> 
   358 0000183C 89CA                <1> 	mov dx, cx			; Pass the number of files
   359 0000183E 85C9                <1> 	test cx, cx
   360 00001840 7429                <1> 	jz .empty_list
   361                              <1> 
   362 00001842 C706[EB1A][501A]    <1> 	mov word [list_dialog_sample_struct + 00Ch], .history
   363                              <1> 
   364                              <1> 	clr ax
    31 00001848 31C0                <2>  xor %1, %1
   365 0000184A BB[151A]            <1> 	mov bx, .root
   366 0000184D B9[FA19]            <1> 	mov cx, .help_msg2
   367 00001850 BE[C718]            <1> 	mov si, .callback
   368 00001853 BF[9D18]            <1> 	mov di, .print_filename
   369 00001856 E8FC01              <1> 	call os_list_dialog_tooltip
   370                              <1> 
   371 00001859 C706[EB1A]0000      <1> 	mov word [list_dialog_sample_struct + 00Ch], 0
   372                              <1> 
   373 0000185F 7238                <1> 	jc .esc_pressed
   374                              <1> 
   375 00001861 E85000              <1> 	call .get_filename
   376                              <1> 	
   377 00001864 07                  <1> 	pop es
   378 00001865 61                  <1> 	popa
   379 00001866 B8[2A1A]            <1> 	mov ax, .filename
   380 00001869 F8                  <1> 	clc
   381 0000186A C3                  <1> 	ret
   382                              <1> 
   383                              <1> .empty_list:
   384 0000186B B8[7B18]            <1> 	mov ax, .nofilesmsg
   385                              <1> 	clr bx
    31 0000186E 31DB                <2>  xor %1, %1
   386                              <1> 	clr cx
    31 00001870 31C9                <2>  xor %1, %1
   387                              <1> 	clr dx
    31 00001872 31D2                <2>  xor %1, %1
   388 00001874 E8DD06              <1> 	call os_dialog_box
   389                              <1> 
   390 00001877 07                  <1> 	pop es
   391 00001878 61                  <1> 	popa
   392 00001879 F9                  <1> 	stc
   393 0000187A C3                  <1> 	ret
   394                              <1> 
   395 0000187B 546865726520617265- <1> 	.nofilesmsg		db "There are no files available.", 0
   395 00001884 206E6F2066696C6573- <1>
   395 0000188D 20617661696C61626C- <1>
   395 00001896 652E00              <1>
   396                              <1> 
   397                              <1> .esc_pressed:				; Set carry flag if Escape was pressed
   398 00001899 07                  <1> 	pop es
   399 0000189A 61                  <1> 	popa
   400 0000189B F9                  <1> 	stc
   401 0000189C C3                  <1> 	ret
   402                              <1> 
   403                              <1> .print_filename:
   404 0000189D 89C8                <1> 	mov ax, cx
   405 0000189F E81200              <1> 	call .get_filename
   406 000018A2 BE[2A1A]            <1> 	mov si, .filename
   407 000018A5 E842FE              <1> 	call os_print_string
   408 000018A8 C3                  <1> 	ret
   409                              <1> 
   410                              <1> .get_ptr_from_index:
   411 000018A9 48                  <1> 	dec ax				; Result from os_list_dialog starts from 1, but
   412                              <1> 						; for our file list offset we want to start from 0
   413                              <1> 	
   414 000018AA D1E0                <1> 	shl ax, 1
   415 000018AC 0500FC              <1> 	add ax, 64512
   416 000018AF 89C6                <1> 	mov si, ax			; Get the pointer to the string in the index
   417                              <1> 
   418 000018B1 8B34                <1> 	mov si, [si]		; Our resulting pointer
   419 000018B3 C3                  <1> 	ret
   420                              <1> 
   421                              <1> .get_filename:
   422 000018B4 E8F2FF              <1> 	call .get_ptr_from_index
   423                              <1> 	clr cx
    31 000018B7 31C9                <2>  xor %1, %1
   424                              <1> 
   425 000018B9 89F0                <1> 	mov ax, si
   426 000018BB E801F7              <1> 	call int_filename_deconvert
   427 000018BE 89C6                <1> 	mov si, ax
   428 000018C0 BF[2A1A]            <1> 	mov di, .filename
   429 000018C3 E82A0F              <1> 	call os_string_copy
   430 000018C6 C3                  <1> 	ret
   431                              <1> 
   432                              <1> .callback:
   433 000018C7 60                  <1> 	pusha
   434                              <1> 
   435                              <1> 	; Display if there are any filters
   436                              <1> 
   437 000018C8 8B1E[4C1A]          <1> 	mov bx, [.extension_list]
   438                              <1> 
   439 000018CC 85DB                <1> 	test bx, bx
   440 000018CE 742A                <1> 	jz .no_filter
   441                              <1> 
   442                              <1> 	mov16 dx, 3, 4
    35 000018D0 BA0304              <2>  mov %1, (%2 + %3 * 256)
   443 000018D3 E882FE              <1> 	call os_move_cursor
   444                              <1> 	
   445 000018D6 BE[FB19]            <1> 	mov si, .filter_msg
   446 000018D9 E80EFE              <1> 	call os_print_string
   447                              <1> 
   448 000018DC 1E                  <1> 	push ds
   449 000018DD 8E1E[4E1A]          <1> 	mov ds, [.extension_list_sgmt]
   450                              <1> 
   451 000018E1 89DE                <1> 	mov si, bx
   452 000018E3 0FB60C              <1> 	movzx cx, byte [si]
   453 000018E6 46                  <1> 	inc si
   454                              <1> 	
   455                              <1> .filter_loop:
   456 000018E7 51                  <1> 	push cx
   457                              <1> 	clr bl
    31 000018E8 30DB                <2>  xor %1, %1
   458 000018EA B90300              <1> 	mov cx, 3
   459 000018ED E8EDFD              <1> 	call os_put_chars
   460 000018F0 59                  <1> 	pop cx
   461                              <1> 
   462 000018F1 83C604              <1> 	add si, 4
   463                              <1> 
   464 000018F4 E80507              <1> 	call os_print_space
   465                              <1> 
   466 000018F7 E2EE                <1> 	loop .filter_loop
   467                              <1> 	
   468 000018F9 1F                  <1> 	pop ds
   469                              <1> 
   470                              <1> .no_filter:
   471 000018FA 61                  <1> 	popa
   472                              <1> 
   473                              <1> 	; Draw the box on the right
   474 000018FB 8A1EA9DE            <1> 	mov bl, [CONFIG_WINDOW_BG_COLOR]		; Color from RAM
   475                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    35 000018FF BA2902              <2>  mov %1, (%2 + %3 * 256)
   476 00001902 BE2500              <1> 	mov si, 37			; Width
   477 00001905 BF1700              <1> 	mov di, 23			; Finish Y position
   478 00001908 E87AFE              <1> 	call os_draw_block
   479                              <1> 
   480                              <1> 	; Draw the icon's background
   481 0000190B B3F0                <1> 	mov bl, 0F0h
   482                              <1> 	mov16 dx, 50, 3
    35 0000190D BA3203              <2>  mov %1, (%2 + %3 * 256)
   483 00001910 BE1300              <1> 	mov si, 19			; Width
   484 00001913 BF0D00              <1> 	mov di, 13			; Finish Y position
   485 00001916 E86CFE              <1> 	call os_draw_block
   486                              <1> 
   487                              <1> 	; Draw the icon
   488                              <1> 	
   489                              <1> 	mov16 dx, 52, 4
    35 00001919 BA3404              <2>  mov %1, (%2 + %3 * 256)
   490 0000191C E839FE              <1> 	call os_move_cursor
   491                              <1> 	
   492 0000191F BE[6A09]            <1> 	mov si, filelogo
   493 00001922 E8C609              <1> 	call os_draw_icon
   494                              <1> 
   495                              <1> 	; Display the filename
   496                              <1> 
   497                              <1> 	mov16 dx, 42, 14
    35 00001925 BA2A0E              <2>  mov %1, (%2 + %3 * 256)
   498 00001928 E82DFE              <1> 	call os_move_cursor
   499                              <1> 
   500 0000192B 50                  <1> 	push ax
   501 0000192C 89C1                <1> 	mov cx, ax
   502 0000192E E86CFF              <1> 	call .print_filename
   503 00001931 58                  <1> 	pop ax
   504                              <1> 	
   505                              <1> 	; Find the correct directory entry for this file
   506                              <1> 
   507 00001932 E874FF              <1> 	call .get_ptr_from_index
   508                              <1> 
   509 00001935 56                  <1> 	push si
   510                              <1> 	
   511                              <1> 	; Display the file size
   512                              <1> 	
   513 00001936 668B441C            <1> 	mov eax, [si + 28]
   514 0000193A E82511              <1> 	call os_32int_to_string
   515 0000193D 50                  <1> 	push ax
   516 0000193E E82A0E              <1> 	call os_string_length
   517                              <1> 
   518 00001941 B247                <1> 	mov dl, 77 - 6
   519 00001943 28C2                <1> 	sub dl, al
   520 00001945 E810FE              <1> 	call os_move_cursor
   521                              <1> 
   522 00001948 5E                  <1> 	pop si
   523 00001949 E89EFD              <1> 	call os_print_string
   524                              <1> 
   525 0000194C BE[051A]            <1> 	mov si, .byte_msg
   526 0000194F E898FD              <1> 	call os_print_string
   527                              <1> 	
   528                              <1> 	; Display the file write date/time
   529                              <1> 	
   530                              <1> 	mov16 dx, 42, 16
    35 00001952 BA2A10              <2>  mov %1, (%2 + %3 * 256)
   531 00001955 E800FE              <1> 	call os_move_cursor
   532                              <1> 
   533 00001958 BE[191A]            <1> 	mov si, .time_msg
   534 0000195B E88CFD              <1> 	call os_print_string
   535                              <1> 	
   536 0000195E 5E                  <1> 	pop si
   537 0000195F 8B5C0E              <1> 	mov bx, [si + 14]
   538 00001962 8B4C10              <1> 	mov cx, [si + 16]
   539                              <1> 	
   540 00001965 53                  <1> 	push bx
   541 00001966 89C8                <1> 	mov ax, cx		; Days
   542 00001968 83E01F              <1> 	and ax, 11111b
   543                              <1> 	
   544 0000196B B22F                <1> 	mov dl, '/'
   545 0000196D E87500              <1> 	call .cb_print_num
   546                              <1> 	
   547 00001970 89C8                <1> 	mov ax, cx		; Months
   548 00001972 C1E805              <1> 	shr ax, 5
   549 00001975 83E00F              <1> 	and ax, 1111b
   550                              <1> 	
   551 00001978 E86A00              <1> 	call .cb_print_num
   552                              <1> 	
   553 0000197B 89C8                <1> 	mov ax, cx		; Years
   554 0000197D C1E809              <1> 	shr ax, 9
   555 00001980 05BC07              <1> 	add ax, 1980
   556                              <1> 	
   557 00001983 B220                <1> 	mov dl, ' '
   558 00001985 E85D00              <1> 	call .cb_print_num
   559 00001988 59                  <1> 	pop cx
   560                              <1> 	
   561 00001989 89C8                <1> 	mov ax, cx		; Hours
   562 0000198B C1E80B              <1> 	shr ax, 11
   563                              <1> 
   564 0000198E B23A                <1> 	mov dl, ':'
   565 00001990 E85200              <1> 	call .cb_print_num
   566                              <1> 	
   567 00001993 89C8                <1> 	mov ax, cx		; Minutes
   568 00001995 C1E805              <1> 	shr ax, 5
   569 00001998 83E03F              <1> 	and ax, 111111b
   570                              <1> 	
   571 0000199B E84700              <1> 	call .cb_print_num
   572                              <1> 
   573 0000199E 89C8                <1> 	mov ax, cx		; Seconds
   574 000019A0 83E01F              <1> 	and ax, 11111b
   575 000019A3 D1E0                <1> 	shl ax, 1
   576                              <1> 
   577 000019A5 B220                <1> 	mov dl, ' '
   578 000019A7 E83B00              <1> 	call .cb_print_num
   579                              <1> 	
   580                              <1> 	; Display volume information
   581                              <1> 	
   582                              <1> 	mov16 dx, 42, 20
    35 000019AA BA2A14              <2>  mov %1, (%2 + %3 * 256)
   583 000019AD E8A8FD              <1> 	call os_move_cursor
   584                              <1> 
   585 000019B0 B8C409              <1> 	mov ax, 09C4h
   586 000019B3 0FB61EA9DE          <1> 	movzx bx, byte [CONFIG_WINDOW_BG_COLOR]
   587 000019B8 B92300              <1> 	mov cx, 35
   588 000019BB CD10                <1> 	int 10h
   589                              <1> 	
   590 000019BD FEC6                <1> 	inc dh
   591 000019BF E896FD              <1> 	call os_move_cursor
   592                              <1> 
   593 000019C2 BE[371A]            <1> 	mov si, .vol_msg
   594 000019C5 E822FD              <1> 	call os_print_string
   595                              <1> 	
   596 000019C8 A1[4A1A]            <1> 	mov ax, [.freespace]
   597 000019CB E80C0F              <1> 	call os_int_to_string
   598 000019CE 89C6                <1> 	mov si, ax
   599 000019D0 E8980D              <1> 	call os_string_length
   600                              <1> 	
   601 000019D3 80C21B              <1> 	add dl, 27
   602 000019D6 28C2                <1> 	sub dl, al
   603 000019D8 E87DFD              <1> 	call os_move_cursor
   604                              <1> 		
   605 000019DB E80CFD              <1> 	call os_print_string
   606                              <1> 		
   607 000019DE BE[0C1A]            <1> 	mov si, .free_msg
   608 000019E1 E806FD              <1> 	call os_print_string
   609 000019E4 C3                  <1> 	ret
   610                              <1> 	
   611                              <1> .cb_print_num:
   612 000019E5 83F80A              <1> 	cmp ax, 10
   613 000019E8 7D07                <1> 	jge .no_zero
   614                              <1> 	
   615 000019EA 50                  <1> 	push ax
   616 000019EB B030                <1> 	mov al, '0'
   617 000019ED E8E3FC              <1> 	call os_putchar
   618 000019F0 58                  <1> 	pop ax
   619                              <1> 
   620                              <1> .no_zero:
   621 000019F1 E84506              <1> 	call os_print_int
   622                              <1> 
   623 000019F4 88D0                <1> 	mov al, dl
   624 000019F6 E8DAFC              <1> 	call os_putchar
   625 000019F9 C3                  <1> 	ret
   626                              <1> 	
   627 000019FA 00                  <1> 	.help_msg2		db 0
   628 000019FB 46696C746572733A20- <1> 	.filter_msg		db 'Filters: ', 0
   628 00001A04 00                  <1>
   629 00001A05 20627974657300      <1> 	.byte_msg		db ' bytes', 0
   630 00001A0C 206B42206672656500  <1> 	.free_msg		db ' kB free', 0
   631 00001A15 413A2F00            <1> 	.root			db 'A:/', 0
   632                              <1> 
   633 00001A19 5772697474656E2074- <1> 	.time_msg		db 'Written to on:  ', 0
   633 00001A22 6F206F6E3A202000    <1>
   634 00001A2A 00<rep Dh>          <1> 	.filename		times 13 db 0	; 8 + 1 + 3 + term
   635                              <1> 	
   636 00001A37 566F6C756D6520      <1> 	.vol_msg		db 'Volume '
   637 00001A3E 00<rep Ch>          <1> 	.volname		times 12 db 0
   638 00001A4A 0000                <1> 	.freespace		dw 0
   639 00001A4C 0000                <1> 	.extension_list	dw 0
   640 00001A4E 0000                <1> 	.extension_list_sgmt	dw 0
   641                              <1> 
   642 00001A50 00<rep 5h>          <1> 	.history		times 5 db 0
   643                              <1> 
   644                              <1> ; ------------------------------------------------------------------
   645                              <1> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
   646                              <1> ; That means, when the user changes the selection, the application will be called back
   647                              <1> ; to change the tooltip's contents.
   648                              <1> ; IN: DS:AX = comma-separated list of strings to show (zero-terminated),
   649                              <1> ;     DS:BX = first help string, DS:CX = second help string
   650                              <1> ;     SI = key/display callback (see os_list_dialog_ex)
   651                              <1> ;     if AX = 0: DI = entry display callback, DX = number of entries
   652                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   653                              <1> 
   654                              <1> os_list_dialog_tooltip:
   655 00001A55 60                  <1> 	pusha
   656                              <1> 
   657 00001A56 2E8936[A51A]        <1> 	mov [cs:.callbackaddr], si
   658                              <1> 
   659 00001A5B E86600              <1> 	call int_init_list_struct
   660                              <1> 
   661 00001A5E 85C0                <1> 	test ax, ax
   662 00001A60 750A                <1> 	jnz .no_entry_callback
   663                              <1> 
   664 00001A62 2E893E[DF1A]        <1> 	mov [cs:list_dialog_sample_struct + 000h], di
   665 00001A67 2E8916[E51A]        <1> 	mov [cs:list_dialog_sample_struct + 006h], dx
   666                              <1> 
   667                              <1> .no_entry_callback:
   668 00001A6C 2EC706[E31A][871A]  <1> 	mov word [cs:list_dialog_sample_struct + 004h], .callback
   669 00001A73 2EC606[EF1A]25      <1> 	mov byte [cs:list_dialog_sample_struct + 010h], 37
   670 00001A79 61                  <1> 	popa
   671                              <1> 
   672 00001A7A 53                  <1> 	push bx
   673 00001A7B BB[DF1A]            <1> 	mov bx, list_dialog_sample_struct
   674 00001A7E 1E                  <1> 	push ds
   675                              <1> 	movs ds, cs
    39 00001A7F 0E                  <2>  push %2
    40 00001A80 1F                  <2>  pop %1
   676 00001A81 E86F00              <1> 	call os_list_dialog_ex
   677 00001A84 1F                  <1> 	pop ds
   678 00001A85 5B                  <1> 	pop bx
   679 00001A86 C3                  <1> 	ret
   680                              <1> 
   681                              <1> .callback:
   682 00001A87 60                  <1> 	pusha
   683                              <1> 	; Draw the box on the right
   684 00001A88 2E8A1EA9DE          <1> 	mov bl, [cs:CONFIG_WINDOW_BG_COLOR]		; Color from RAM
   685                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    35 00001A8D BA2902              <2>  mov %1, (%2 + %3 * 256)
   686 00001A90 BE2500              <1> 	mov si, 37			; Width
   687 00001A93 BF1700              <1> 	mov di, 23			; Finish Y position
   688 00001A96 E8ECFC              <1> 	call os_draw_block	; Draw option selector window	
   689                              <1> 
   690                              <1> 	mov16 dx, 42, 3
    35 00001A99 BA2A03              <2>  mov %1, (%2 + %3 * 256)
   691 00001A9C E8B9FC              <1> 	call os_move_cursor
   692 00001A9F 61                  <1> 	popa
   693                              <1> 
   694 00001AA0 2EFF26[A51A]        <1> 	jmp [cs:.callbackaddr]
   695                              <1> 	
   696 00001AA5 0000                <1> 	.callbackaddr	dw 0
   697                              <1> 	
   698                              <1> ; ------------------------------------------------------------------
   699                              <1> ; os_list_dialog -- Show a dialog with a list of options
   700                              <1> ; IN: ES:AX = comma-separated list of strings to show (zero-terminated),
   701                              <1> ;     ES:BX = first help string, ES:CX = second help string
   702                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   703                              <1> 
   704                              <1> os_list_dialog:
   705 00001AA7 60                  <1> 	pusha
   706                              <1> 
   707 00001AA8 E81900              <1> 	call int_init_list_struct
   708                              <1> 
   709 00001AAB 2EC606[EF1A]4C      <1> 	mov byte [cs:list_dialog_sample_struct + 010h], 76
   710 00001AB1 2E891E[E31A]        <1> 	mov [cs:list_dialog_sample_struct + 004h], bx
   711 00001AB6 61                  <1> 	popa
   712                              <1> 
   713 00001AB7 53                  <1> 	push bx
   714 00001AB8 BB[DF1A]            <1> 	mov bx, list_dialog_sample_struct
   715 00001ABB 1E                  <1> 	push ds
   716                              <1> 	movs ds, cs
    39 00001ABC 0E                  <2>  push %2
    40 00001ABD 1F                  <2>  pop %1
   717 00001ABE E83200              <1> 	call os_list_dialog_ex
   718 00001AC1 1F                  <1> 	pop ds
   719 00001AC2 5B                  <1> 	pop bx
   720 00001AC3 C3                  <1> 	ret
   721                              <1> 
   722                              <1> int_init_list_struct:
   723 00001AC4 2E8C1E[F11A]        <1> 	mov [cs:list_dialog_sample_struct + 012h], ds
   724 00001AC9 2EA3[E11A]          <1> 	mov [cs:list_dialog_sample_struct + 002h], ax
   725 00001ACD 2E891E[E71A]        <1> 	mov [cs:list_dialog_sample_struct + 008h], bx
   726 00001AD2 2E890E[E91A]        <1> 	mov [cs:list_dialog_sample_struct + 00Ah], cx
   727                              <1> 	clr bx
    31 00001AD7 31DB                <2>  xor %1, %1
   728 00001AD9 2E891E[E51A]        <1> 	mov [cs:list_dialog_sample_struct + 006h], bx
   729 00001ADE C3                  <1> 	ret
   730                              <1> 
   731                              <1> list_dialog_sample_struct:
   732 00001ADF 0000                <1> 	dw 0	; No entry display callback
   733 00001AE1 0000                <1> 	dw 0	; Comma-separated list - will be filled in
   734 00001AE3 0000                <1> 	dw 0	; No key/entry change callback
   735 00001AE5 0000                <1> 	dw 0	; Auto-calculate number of entries
   736 00001AE7 0000                <1> 	dw 0	; First help string - will be filled in
   737 00001AE9 0000                <1> 	dw 0	; Second help string - will be filled in
   738 00001AEB 0000                <1> 	dw 0	; No history data
   739 00001AED 02                  <1> 	db 2	; X position
   740 00001AEE 02                  <1> 	db 2	; Y position
   741 00001AEF 4C                  <1> 	db 76	; Width
   742 00001AF0 15                  <1> 	db 21	; Height
   743 00001AF1 0000                <1> 	dw 0	; Segment
   744                              <1> 	
   745                              <1> ; ------------------------------------------------------------------
   746                              <1> ; os_list_dialog_ex -- Show a dialog with a list of options
   747                              <1> ; IN: DS:BX = pointer to setup struct
   748                              <1> ;       Addr Size Description
   749                              <1> ;       000h word Pointer to entry display callback (accepts CX as entry ID, prints out result) - valid only if ptr to list is zero
   750                              <1> ;       002h word Pointer to comma-separated list of strings to show (zero-terminated)
   751                              <1> ;       004h word Pointer to key/entry change callback (accepts AX as entry ID, CX as keypress),
   752                              <1> ;       006h word Number of entries (if 0, then it is automatically calculated from 002h)
   753                              <1> ;       008h word Pointer to first help string (if 0, then the list will fill the whole dialog)
   754                              <1> ;       00Ah word Pointer to second help string
   755                              <1> ;       00Ch word (ES) Pointer to history data (points to a 5 byte array)
   756                              <1> ;       00Eh byte Screen X position
   757                              <1> ;       00Fh byte Screen Y position
   758                              <1> ;       010h byte Dialog width
   759                              <1> ;       011h byte Dialog height
   760                              <1> ;       012h word Source segment (used for comma-separated list & help strings)
   761                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   762                              <1> 
   763                              <1> os_list_dialog_ex:
   764 00001AF3 60                  <1> 	pusha
   765                              <1> 
   766                              <1> .no_pusha:
   767                              <1> 	; Save these for later
   768                              <1> 
   769 00001AF4 8B4706              <1> 	mov ax, [bx + 006h]					; Number of entries
   770 00001AF7 A3[B51B]            <1> 	mov [.num_of_entries], ax
   771                              <1> 
   772 00001AFA 8B17                <1> 	mov dx, [bx + 000h]					; Entry display callback
   773                              <1> 	
   774 00001AFC 8B4702              <1> 	mov ax, [bx + 002h]					; Entry list
   775 00001AFF 85C0                <1> 	test ax, ax							; Check if callback is used instead
   776 00001B01 7416                <1> 	jz .no_setup_tokenizer_callback
   777                              <1> 
   778 00001B03 1E                  <1> 	push ds
   779 00001B04 8E5F12              <1> 	mov ds, [bx + 012h]
   780 00001B07 E8C10E              <1> 	call os_string_callback_tokenizer	; Create a tokenizer callback from the list
   781 00001B0A 1F                  <1> 	pop ds
   782                              <1> 
   783 00001B0B 8B4706              <1> 	mov ax, [bx + 006h]					; Check if the number of entries is expected to be calculated
   784 00001B0E 85C0                <1> 	test ax, ax
   785 00001B10 7505                <1> 	jnz .no_tokenizer_length_detect
   786                              <1> 
   787 00001B12 2E890E[B51B]        <1> 	mov [cs:.num_of_entries], cx			; If so, store it for later
   788                              <1> 
   789                              <1> .no_tokenizer_length_detect:
   790 00001B17 89F2                <1> 	mov dx, si
   791                              <1> 
   792                              <1> .no_setup_tokenizer_callback:
   793 00001B19 2E8916[B71B]        <1> 	mov [cs:.parsercb], dx					; Store the entry display callback (whatever it ends up being)
   794                              <1> 
   795 00001B1E 8B4704              <1> 	mov ax, [bx + 004h]					; Key/Entry change callback
   796 00001B21 2EA3[B91B]          <1> 	mov [cs:.displaycb], ax
   797                              <1> 
   798                              <1> 	; Draw the window
   799                              <1> 
   800 00001B25 53                  <1> 	push bx
   801 00001B26 8B570E              <1> 	mov dx, [bx + 00Eh]			; Start X/Y position
   802 00001B29 0FB67F11            <1> 	movzx di, byte [bx + 011h]	; Finish Y position
   803 00001B2D 0FB6470F            <1> 	movzx ax, byte [bx + 00Fh]
   804 00001B31 01C7                <1> 	add di, ax
   805 00001B33 0FB67710            <1> 	movzx si, byte [bx + 010h]	; Width
   806 00001B37 2E8A1EA9DE          <1> 	mov bl, [cs:CONFIG_WINDOW_BG_COLOR]				; Color from RAM
   807 00001B3C E846FC              <1> 	call os_draw_block			; Draw option selector window
   808 00001B3F 5B                  <1> 	pop bx
   809                              <1> 
   810                              <1> 	mov16 dx, 3, 3				; Show first line of help text...
    35 00001B40 BA0303              <2>  mov %1, (%2 + %3 * 256)
   811 00001B43 E812FC              <1> 	call os_move_cursor
   812                              <1> 
   813 00001B46 8B7708              <1> 	mov si, [bx + 008h]
   814 00001B49 1E                  <1> 	push ds
   815 00001B4A 8E5F12              <1> 	mov ds, [bx + 012h]
   816 00001B4D E89AFB              <1> 	call os_print_string
   817 00001B50 1F                  <1> 	pop ds
   818                              <1> 
   819 00001B51 FEC6                <1> 	inc dh
   820 00001B53 E802FC              <1> 	call os_move_cursor
   821                              <1> 
   822 00001B56 8B770A              <1> 	mov si, [bx + 00Ah]			; ...and the second
   823 00001B59 1E                  <1> 	push ds
   824 00001B5A 8E5F12              <1> 	mov ds, [bx + 012h]
   825 00001B5D E88AFB              <1> 	call os_print_string
   826 00001B60 1F                  <1> 	pop ds
   827                              <1> 
   828 00001B61 8B4710              <1> 	mov ax, [bx + 010h]			; Width/height
   829 00001B64 2D0606              <1> 	sub ax, 606h
   830 00001B67 8B570E              <1> 	mov dx, [bx + 00Eh]			; X/Y
   831 00001B6A 81C20103            <1> 	add dx, 301h
   832 00001B6E 2E8B0E[B51B]        <1> 	mov cx, [cs:.num_of_entries]	; Number of entries
   833 00001B73 BE[7D1B]            <1> 	mov si, .callbackroutine	; Callback routine
   834 00001B76 8B7F0C              <1> 	mov di, [bx + 00Ch]			; Ptr to history data
   835 00001B79 B3F0                <1> 	mov bl, 11110000b			; Black on white for option list box
   836 00001B7B EB43                <1> 	jmp os_select_list.no_pusha
   837                              <1> 
   838                              <1> .callbackroutine:
   839 00001B7D 7205                <1> 	jc .cbdisplay
   840                              <1> 
   841 00001B7F 2EFF26[B71B]        <1> 	jmp word [cs:.parsercb]
   842                              <1> 
   843                              <1> .cbdisplay:
   844 00001B84 1E                  <1> 	push ds
   845                              <1> 	movs ds, cs
    39 00001B85 0E                  <2>  push %2
    40 00001B86 1F                  <2>  pop %1
   846                              <1> 
   847 00001B87 60                  <1> 	pusha
   848 00001B88 91                  <1> 	xchg ax, cx
   849 00001B89 FF16[B91B]          <1> 	call word [.displaycb]
   850 00001B8D 61                  <1> 	popa
   851                              <1> 
   852 00001B8E 85C0                <1> 	test ax, ax
   853 00001B90 7521                <1> 	jnz .cbexit
   854                              <1> 
   855                              <1> 	mov16 dx, 5, 22
    35 00001B92 BA0516              <2>  mov %1, (%2 + %3 * 256)
   856 00001B95 E8C0FB              <1> 	call os_move_cursor
   857                              <1> 
   858 00001B98 B028                <1> 	mov al, '('
   859 00001B9A E836FB              <1> 	call os_putchar
   860                              <1> 
   861 00001B9D 89C8                <1> 	mov ax, cx
   862 00001B9F E89704              <1> 	call os_print_int
   863                              <1> 	
   864 00001BA2 B02F                <1> 	mov al, '/'
   865 00001BA4 E82CFB              <1> 	call os_putchar
   866                              <1> 	
   867 00001BA7 A1[B51B]            <1> 	mov ax, [.num_of_entries]
   868 00001BAA E88C04              <1> 	call os_print_int
   869                              <1> 	
   870 00001BAD BE[BB1B]            <1> 	mov si, .str_pos_end
   871 00001BB0 E837FB              <1> 	call os_print_string
   872                              <1> 	
   873                              <1> .cbexit:
   874 00001BB3 1F                  <1> 	pop ds
   875 00001BB4 C3                  <1> 	ret
   876                              <1> 
   877 00001BB5 0000                <1> 	.num_of_entries	dw 0
   878 00001BB7 0000                <1> 	.parsercb		dw 0
   879 00001BB9 0000                <1> 	.displaycb		dw 0
   880 00001BBB 29202000            <1> 	.str_pos_end	db ')  ', 0
   881                              <1> 
   882                              <1> ; ------------------------------------------------------------------
   883                              <1> ; os_select_list -- Draws a list of entries (defined by a callback) to select from.
   884                              <1> ; IN: AX = width/height, BL = color, CX = number of entries, DX = X/Y pos,
   885                              <1> ;     SI = callback (if C clear = accepts an entry ID in CX, prints an appropriate string,
   886                              <1> ;     if C set = accepts key input in AX, entry ID in CX; not required to preserve regs),
   887                              <1> ;     ES:DI = pointer to a history struct (word .num_of_entries, word .skip_num, byte .cursor) or 0 if none
   888                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   889                              <1> 
   890                              <1> os_select_list:
   891 00001BBF 60                  <1> 	pusha
   892                              <1> 
   893                              <1> .no_pusha:
   894 00001BC0 1E                  <1> 	push ds
   895                              <1> 	movs ds, cs
    39 00001BC1 0E                  <2>  push %2
    40 00001BC2 1F                  <2>  pop %1
   896                              <1> 
   897 00001BC3 E8B5FB              <1> 	call os_hide_cursor
   898                              <1> 
   899                              <1> 	; Initialize vars
   900                              <1> 
   901 00001BC6 8936[CD1D]          <1> 	mov [.callback], si
   902 00001BCA 8916[CF1D]          <1> 	mov [.xpos], dx
   903 00001BCE A3[D21D]            <1> 	mov [.width], ax
   904                              <1> 	
   905 00001BD1 81C20101            <1> 	add dx, 101h	; Increment both X and Y
   906                              <1> 
   907 00001BD5 00F4                <1> 	add ah, dh
   908 00001BD7 8826[D11D]          <1> 	mov [.endypos], ah
   909                              <1> 
   910 00001BDB C706[C91D]0000      <1> 	mov word [.skip_num], 0
   911                              <1> 
   912                              <1> 	; If history is enabled, check if it matches the data
   913                              <1> 
   914 00001BE1 893E[CB1D]          <1> 	mov [.history], di
   915                              <1> 
   916 00001BE5 85FF                <1> 	test di, di
   917 00001BE7 7410                <1> 	jz .no_history
   918                              <1> 
   919 00001BE9 26390D              <1> 	cmp [es:di], cx
   920 00001BEC 750B                <1> 	jne .no_history
   921                              <1> 
   922 00001BEE 268B4502            <1> 	mov ax, [es:di + 2]
   923 00001BF2 A3[C91D]            <1> 	mov [.skip_num], ax
   924                              <1> 
   925 00001BF5 268A7504            <1> 	mov dh, [es:di + 4]
   926                              <1> 
   927                              <1> .no_history:
   928 00001BF9 890E[C71D]          <1> 	mov [.num_of_entries], cx
   929                              <1> 
   930                              <1> .redraw:
   931                              <1> 	; Draw the BG
   932                              <1> 
   933 00001BFD 60                  <1> 	pusha
   934 00001BFE 8B16[CF1D]          <1> 	mov dx, [.xpos]
   935 00001C02 A0[D21D]            <1> 	mov al, [.width]
   936 00001C05 0404                <1> 	add al, 4
   937 00001C07 0FB6F0              <1> 	movzx si, al
   938 00001C0A A0[D11D]            <1> 	mov al, [.endypos]
   939 00001C0D FEC0                <1> 	inc al
   940 00001C0F 0FB6F8              <1> 	movzx di, al
   941 00001C12 E870FB              <1> 	call os_draw_block
   942 00001C15 61                  <1> 	popa
   943                              <1> 
   944                              <1> 	; Draw the selected entry BG
   945                              <1> 
   946 00001C16 60                  <1> 	pusha
   947 00001C17 C0CB04              <1> 	ror bl, 4				; Invert the selection color
   948 00001C1A A0[D21D]            <1> 	mov al, [.width]
   949 00001C1D 0402                <1> 	add al, 2
   950 00001C1F 0FB6F0              <1> 	movzx si, al
   951 00001C22 0FB6FE              <1> 	movzx di, dh
   952 00001C25 47                  <1> 	inc di
   953 00001C26 E85CFB              <1> 	call os_draw_block
   954 00001C29 61                  <1> 	popa
   955                              <1> 
   956                              <1> 	; Draw the list
   957                              <1> 
   958 00001C2A 60                  <1> 	pusha
   959 00001C2B 8A36[D01D]          <1> 	mov dh, [.ypos]
   960 00001C2F FEC2                <1> 	inc dl
   961 00001C31 0FB60E[D31D]        <1> 	movzx cx, [.height]
   962 00001C36 A1[C91D]            <1> 	mov ax, [.skip_num]
   963                              <1> 
   964                              <1> .entry_draw_loop:
   965 00001C39 40                  <1> 	inc ax
   966 00001C3A FEC6                <1> 	inc dh
   967                              <1> 
   968 00001C3C 3B06[C71D]          <1> 	cmp ax, [.num_of_entries]
   969 00001C40 7F09                <1> 	jg .no_draw
   970                              <1> 
   971 00001C42 E813FB              <1> 	call os_move_cursor
   972 00001C45 60                  <1> 	pusha
   973 00001C46 F8                  <1> 	clc
   974 00001C47 E88F00              <1> 	call .call_callback
   975 00001C4A 61                  <1> 	popa
   976                              <1> 
   977                              <1> .no_draw:
   978 00001C4B E2EC                <1> 	loop .entry_draw_loop
   979 00001C4D 61                  <1> 	popa
   980                              <1> 
   981                              <1> 	; Draw arrows indicating that there may be entries outside the visible area
   982                              <1> 
   983 00001C4E 60                  <1> 	pusha
   984 00001C4F 8B1E[C91D]          <1> 	mov bx, [.skip_num]			; Are we at the top?
   985 00001C53 85DB                <1> 	test bx, bx
   986 00001C55 740F                <1> 	je .no_draw_top_arrow
   987                              <1> 
   988 00001C57 8B16[CF1D]          <1> 	mov dx, [.xpos]
   989 00001C5B 80C202              <1> 	add dl, 2
   990 00001C5E E8F7FA              <1> 	call os_move_cursor
   991 00001C61 B01E                <1> 	mov al, 1Eh
   992 00001C63 E86DFA              <1> 	call os_putchar
   993                              <1> 
   994                              <1> .no_draw_top_arrow:
   995 00001C66 0FB60E[D31D]        <1> 	movzx cx, byte [.height]
   996 00001C6B 01CB                <1> 	add bx, cx
   997                              <1> 
   998 00001C6D 3B1E[C71D]          <1> 	cmp bx, [.num_of_entries]	; Are we at the bottom?
   999 00001C71 7D14                <1> 	jge .no_draw_bottom_arrow
  1000                              <1> 
  1001 00001C73 8B16[CF1D]          <1> 	mov dx, [.xpos]
  1002 00001C77 0236[D31D]          <1> 	add dh, [.height]
  1003 00001C7B 81C20201            <1> 	add dx, 102h
  1004 00001C7F E8D6FA              <1> 	call os_move_cursor
  1005 00001C82 B01F                <1> 	mov al, 1Fh
  1006 00001C84 E84CFA              <1> 	call os_putchar
  1007                              <1> 
  1008                              <1> .no_draw_bottom_arrow:
  1009 00001C87 61                  <1> 	popa
  1010                              <1> 
  1011 00001C88 60                  <1> 	pusha
  1012                              <1> 	clr ax
    31 00001C89 31C0                <2>  xor %1, %1
  1013 00001C8B F9                  <1> 	stc
  1014 00001C8C E84A00              <1> 	call .call_callback
  1015 00001C8F 61                  <1> 	popa
  1016                              <1> 
  1017                              <1> .another_key:
  1018 00001C90 E8F2F4              <1> 	call os_wait_for_key	; Move / select option
  1019 00001C93 3C6A                <1> 	cmp al, 'j'
  1020 00001C95 745A                <1> 	je .go_down
  1021 00001C97 3C6B                <1> 	cmp al, 'k'
  1022 00001C99 7450                <1> 	je .go_up
  1023 00001C9B 3C6C                <1> 	cmp al, 'l'
  1024 00001C9D 0F84F000            <1> 	je .option_selected
  1025 00001CA1 3C68                <1> 	cmp al, 'h'
  1026 00001CA3 0F840201            <1> 	je .esc_pressed
  1027                              <1> 
  1028 00001CA7 80FC48              <1> 	cmp ah, 48h				; Up pressed?
  1029 00001CAA 743F                <1> 	je .go_up
  1030 00001CAC 80FC50              <1> 	cmp ah, 50h				; Down pressed?
  1031 00001CAF 7440                <1> 	je .go_down
  1032 00001CB1 80FC47              <1> 	cmp ah, 47h				; Home pressed?
  1033 00001CB4 7441                <1> 	je .home_pressed
  1034 00001CB6 80FC4F              <1> 	cmp ah, 4Fh				; End pressed?
  1035 00001CB9 7442                <1> 	je .end_pressed
  1036 00001CBB 80FC49              <1> 	cmp ah, 49h				; PgUp pressed?
  1037 00001CBE 7443                <1> 	je .pgup_pressed
  1038 00001CC0 80FC51              <1> 	cmp ah, 51h				; PgDn pressed?
  1039 00001CC3 7443                <1> 	je .pgdn_pressed
  1040 00001CC5 3C0D                <1> 	cmp al, 13				; Enter pressed?
  1041 00001CC7 0F84C600            <1> 	je .option_selected
  1042 00001CCB 3C1B                <1> 	cmp al, 27				; Esc pressed?
  1043 00001CCD 0F84D800            <1> 	je .esc_pressed
  1044                              <1> 
  1045 00001CD1 60                  <1> 	pusha
  1046 00001CD2 F9                  <1> 	stc
  1047 00001CD3 E80300              <1> 	call .call_callback
  1048 00001CD6 61                  <1> 	popa
  1049                              <1> 
  1050 00001CD7 EBB7                <1> 	jmp .another_key		; If not, wait for another key
  1051                              <1> 
  1052                              <1> .call_callback:
  1053                              <1> 	; Calculate the current entry ID
  1054                              <1> 
  1055 00001CD9 9C                  <1> 	pushf
  1056 00001CDA 0FB6CE              <1> 	movzx cx, dh
  1057 00001CDD 2A0E[D01D]          <1> 	sub cl, [.ypos]
  1058 00001CE1 030E[C91D]          <1> 	add cx, [.skip_num]
  1059 00001CE5 9D                  <1> 	popf
  1060                              <1> 
  1061 00001CE6 FF16[CD1D]          <1> 	call word [.callback]
  1062 00001CEA C3                  <1> 	ret
  1063                              <1> 
  1064                              <1> .go_up:
  1065 00001CEB E82900              <1> 	call .move_up
  1066 00001CEE E90CFF              <1> 	jmp .redraw
  1067                              <1> 
  1068                              <1> .go_down:
  1069 00001CF1 E85A00              <1> 	call .move_down
  1070 00001CF4 E906FF              <1> 	jmp .redraw
  1071                              <1> 
  1072                              <1> .home_pressed:
  1073 00001CF7 E88A00              <1> 	call .jump_up
  1074 00001CFA E900FF              <1> 	jmp .redraw
  1075                              <1> 
  1076                              <1> .end_pressed:
  1077 00001CFD E82D00              <1> 	call .jump_down
  1078 00001D00 E9FAFE              <1> 	jmp .redraw
  1079                              <1> 
  1080                              <1> .pgup_pressed:
  1081 00001D03 BE[171D]            <1> 	mov si, .move_up
  1082 00001D06 EB03                <1> 	jmp .pgxx_start
  1083                              <1> 
  1084                              <1> .pgdn_pressed:
  1085 00001D08 BE[4E1D]            <1> 	mov si, .move_down
  1086                              <1> 
  1087                              <1> .pgxx_start:
  1088 00001D0B B91000              <1> 	mov cx, 16
  1089                              <1> 
  1090                              <1> .pgxx_loop:
  1091 00001D0E 51                  <1> 	push cx
  1092 00001D0F FFD6                <1> 	call si
  1093 00001D11 59                  <1> 	pop cx
  1094 00001D12 E2FA                <1> 	loop .pgxx_loop
  1095                              <1> 
  1096 00001D14 E9E6FE              <1> 	jmp .redraw
  1097                              <1> 
  1098                              <1> .move_up:
  1099 00001D17 FECE                <1> 	dec dh					; Move the cursor up
  1100 00001D19 3A36[D01D]          <1> 	cmp dh, [.ypos]			; Have we reached the top?
  1101 00001D1D 7F71                <1> 	jg .sub_exit
  1102                              <1> 
  1103 00001D1F 833E[C91D]00        <1> 	cmp word [.skip_num], 0	; Are we at the top of the list?
  1104 00001D24 7407                <1> 	je .jump_down
  1105                              <1> 
  1106 00001D26 FF0E[C91D]          <1> 	dec word [.skip_num]	; If not, then just move the selection window up
  1107 00001D2A FEC6                <1> 	inc dh
  1108 00001D2C C3                  <1> 	ret
  1109                              <1> 
  1110                              <1> .jump_down:
  1111 00001D2D A1[C71D]            <1> 	mov ax, [.num_of_entries]
  1112 00001D30 0FB60E[D31D]        <1> 	movzx cx, byte [.height]
  1113 00001D35 39C8                <1> 	cmp ax, cx				; Is the dialog smaller than its allowed number of entries?
  1114 00001D37 7F07                <1> 	jg .transpose_skip_num	; If so, then shift the skip num
  1115                              <1> 
  1116 00001D39 0206[D01D]          <1> 	add al, [.ypos]			; Set the cursor position to the last visible value
  1117 00001D3D 88C6                <1> 	mov dh, al
  1118 00001D3F C3                  <1> 	ret
  1119                              <1> 
  1120                              <1> .transpose_skip_num:
  1121 00001D40 29C8                <1> 	sub ax, cx
  1122 00001D42 A3[C91D]            <1> 	mov [.skip_num], ax
  1123                              <1> 
  1124 00001D45 8A36[D31D]          <1> 	mov dh, [.height]		; Scroll the list all the way down
  1125 00001D49 0236[D01D]          <1> 	add dh, [.ypos]
  1126                              <1> 
  1127 00001D4D C3                  <1> 	ret
  1128                              <1> 
  1129                              <1> .move_down:
  1130 00001D4E FEC6                <1> 	inc dh					; Move the cursor down
  1131                              <1> 
  1132 00001D50 0FB60E[D31D]        <1> 	movzx cx, byte [.height]	; Figure out whether the list is scrollable or not
  1133 00001D55 3B0E[C71D]          <1> 	cmp cx, [.num_of_entries]
  1134 00001D59 7F1D                <1> 	jg .move_down_not_scrollable
  1135                              <1> 
  1136 00001D5B 3A36[D11D]          <1> 	cmp dh, [.endypos]		; Have we reached the bottom?
  1137 00001D5F 7C2F                <1> 	jl .sub_exit
  1138                              <1> 
  1139 00001D61 A1[C91D]            <1> 	mov ax, [.skip_num]		; Check if the list is scrolled all the way down
  1140 00001D64 0FB60E[D31D]        <1> 	movzx cx, byte [.height]
  1141 00001D69 01C8                <1> 	add ax, cx
  1142                              <1> 
  1143 00001D6B 3B06[C71D]          <1> 	cmp ax, [.num_of_entries]
  1144 00001D6F 7D13                <1> 	jge .jump_up
  1145                              <1> 
  1146 00001D71 FF06[C91D]          <1> 	inc word [.skip_num]	; If not, then scroll the list down
  1147 00001D75 FECE                <1> 	dec dh
  1148 00001D77 C3                  <1> 	ret
  1149                              <1> 
  1150                              <1> .move_down_not_scrollable:
  1151 00001D78 8A0E[D01D]          <1> 	mov cl, [.ypos]
  1152 00001D7C 020E[C71D]          <1> 	add cl, [.num_of_entries]
  1153                              <1> 
  1154 00001D80 38CE                <1> 	cmp dh, cl
  1155 00001D82 7E0C                <1> 	jle .sub_exit
  1156                              <1> 
  1157                              <1> .jump_up:
  1158 00001D84 C706[C91D]0000      <1> 	mov word [.skip_num], 0
  1159 00001D8A 8A36[D01D]          <1> 	mov dh, [.ypos]
  1160 00001D8E FEC6                <1> 	inc dh
  1161                              <1> 
  1162                              <1> .sub_exit:
  1163 00001D90 C3                  <1> 	ret
  1164                              <1> 
  1165                              <1> .option_selected:
  1166 00001D91 E81C00              <1> 	call .dialog_end
  1167                              <1> 	
  1168 00001D94 2A36[D01D]          <1> 	sub dh, [.ypos]		; Options start from 1
  1169 00001D98 C1EA08              <1> 	shr dx, 8
  1170 00001D9B 0316[C91D]          <1> 	add dx, [.skip_num]	; Add any lines skipped from scrolling
  1171                              <1> 
  1172 00001D9F 1F                  <1> 	pop ds
  1173                              <1> 
  1174 00001DA0 89E3                <1> 	mov bx, sp
  1175 00001DA2 3689570E            <1> 	mov [ss:bx + 14], dx
  1176                              <1> 
  1177 00001DA6 61                  <1> 	popa
  1178 00001DA7 F8                  <1> 	clc					; Clear carry as Esc wasn't pressed
  1179 00001DA8 C3                  <1> 	ret
  1180                              <1> 
  1181                              <1> .esc_pressed:
  1182 00001DA9 E80400              <1> 	call .dialog_end
  1183 00001DAC 1F                  <1> 	pop ds
  1184 00001DAD 61                  <1> 	popa
  1185 00001DAE F9                  <1> 	stc					; Set carry for Esc
  1186 00001DAF C3                  <1> 	ret
  1187                              <1> 
  1188                              <1> .dialog_end:
  1189 00001DB0 E8BDF9              <1> 	call os_show_cursor
  1190                              <1> 
  1191 00001DB3 8B3E[CB1D]          <1> 	mov di, [.history]
  1192 00001DB7 85FF                <1> 	test di, di
  1193 00001DB9 740B                <1> 	jz .no_save_history
  1194                              <1> 
  1195                              <1> 	; Save the history data
  1196                              <1> 
  1197 00001DBB BE[C71D]            <1> 	mov si, .num_of_entries
  1198 00001DBE B90400              <1> 	mov cx, 4
  1199 00001DC1 F3A4                <1> 	rep movsb
  1200                              <1> 
  1201 00001DC3 88F0                <1> 	mov al, dh
  1202 00001DC5 AA                  <1> 	stosb
  1203                              <1> 
  1204                              <1> .no_save_history:
  1205 00001DC6 C3                  <1> 	ret
  1206                              <1> 
  1207 00001DC7 0000                <1> 	.num_of_entries	dw 0
  1208 00001DC9 0000                <1> 	.skip_num		dw 0
  1209                              <1> 
  1210 00001DCB 0000                <1> 	.history		dw 0
  1211                              <1> 
  1212 00001DCD 0000                <1> 	.callback		dw 0
  1213 00001DCF 00                  <1> 	.xpos			db 0
  1214 00001DD0 00                  <1> 	.ypos			db 0
  1215 00001DD1 00                  <1> 	.endypos		db 0
  1216 00001DD2 00                  <1> 	.width			db 0
  1217 00001DD3 00                  <1> 	.height			db 0
  1218                              <1> 
  1219                              <1> ; ------------------------------------------------------------------
  1220                              <1> ; os_draw_background -- Clear screen with white top and bottom bars
  1221                              <1> ; containing text, and a coloured middle section.
  1222                              <1> ; IN: DS:AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
  1223                              <1> ; OUT: None, registers preserved
  1224                              <1> 
  1225                              <1> os_draw_background:
  1226 00001DD4 60                  <1> 	pusha
  1227                              <1> 	
  1228 00001DD5 50                  <1> 	push ax				; Store params to pop out later
  1229 00001DD6 53                  <1> 	push bx
  1230 00001DD7 51                  <1> 	push cx
  1231                              <1> 
  1232                              <1> 	mov16 dx, 0, 0
    35 00001DD8 BA0000              <2>  mov %1, (%2 + %3 * 256)
  1233 00001DDB E86500              <1> 	call .draw_bar
  1234                              <1> 
  1235 00001DDE BA0001              <1> 	mov dx, 256
  1236 00001DE1 E874F9              <1> 	call os_move_cursor
  1237                              <1> 	
  1238 00001DE4 5B                  <1> 	pop bx				; Get colour param (originally in CX)
  1239 00001DE5 81FB0001            <1> 	cmp bx, 256
  1240 00001DE9 7433                <1> 	je .draw_default_background
  1241                              <1> 
  1242                              <1> .fill_bg:	
  1243 00001DEB B82009              <1> 	mov ax, 0920h			; Draw colour section
  1244 00001DEE B93007              <1> 	mov cx, 1840
  1245                              <1> 	clr bh
    31 00001DF1 30FF                <2>  xor %1, %1
  1246 00001DF3 CD10                <1> 	int 10h
  1247                              <1> 
  1248                              <1> .bg_drawn:
  1249                              <1> 	mov16 dx, 0, 24
    35 00001DF5 BA0018              <2>  mov %1, (%2 + %3 * 256)
  1250 00001DF8 E84800              <1> 	call .draw_bar
  1251                              <1> 
  1252                              <1> 	mov16 dx, 1, 24
    35 00001DFB BA0118              <2>  mov %1, (%2 + %3 * 256)
  1253 00001DFE E857F9              <1> 	call os_move_cursor
  1254 00001E01 5E                  <1> 	pop si				; Get bottom string param
  1255 00001E02 E8E5F8              <1> 	call os_print_string
  1256                              <1> 
  1257                              <1> 	mov16 dx, 1, 0
    35 00001E05 BA0100              <2>  mov %1, (%2 + %3 * 256)
  1258 00001E08 E84DF9              <1> 	call os_move_cursor
  1259 00001E0B 5E                  <1> 	pop si				; Get top string param
  1260 00001E0C E8DBF8              <1> 	call os_print_string
  1261                              <1> 
  1262 00001E0F E85705              <1> 	call os_print_clock
  1263                              <1> 
  1264 00001E12 2EC606[6909]00      <1> 	mov byte [cs:system_ui_state], 0	; Assume that an application drawing 
  1265                              <1> 										; the background wants to refresh time		
  1266                              <1> 
  1267                              <1> 	mov16 dx, 0, 1		; Ready for app text
    35 00001E18 BA0001              <2>  mov %1, (%2 + %3 * 256)
  1268 00001E1B E93BF9              <1> 	jmp os_move_cursor.no_pusha
  1269                              <1> 
  1270                              <1> .draw_default_background:
  1271 00001E1E 2E8A1EA8DE          <1> 	mov bl, byte [cs:CONFIG_DESKTOP_BG_COLOR] ; In case it is necessary
  1272                              <1> 
  1273 00001E23 64803E000600        <1> 	cmp byte [fs:DESKTOP_BACKGROUND], 0
  1274 00001E29 74C0                <1> 	je .fill_bg
  1275                              <1> 	
  1276 00001E2B 1E                  <1> 	push ds
  1277 00001E2C 06                  <1> 	push es
  1278                              <1> 	
  1279                              <1> 	movs ds, fs				; Set up source pointer
    39 00001E2D 0FA0                <2>  push %2
    40 00001E2F 1F                  <2>  pop %1
  1280                              <1> 
  1281 00001E30 BE0006              <1> 	mov si, DESKTOP_BACKGROUND
  1282                              <1> 
  1283 00001E33 6800B8              <1> 	push 0B800h ; Set up destination pointer
  1284 00001E36 07                  <1> 	pop es
  1285                              <1> 
  1286 00001E37 BFA000              <1> 	mov di, 160
  1287                              <1> 	
  1288 00001E3A B9600E              <1> 	mov cx, 80 * 23 * 2
  1289                              <1> 	
  1290 00001E3D F3A4                <1> 	rep movsb
  1291                              <1> 	
  1292 00001E3F 07                  <1> 	pop es
  1293 00001E40 1F                  <1> 	pop ds
  1294 00001E41 EBB2                <1> 	jmp .bg_drawn
  1295                              <1> 	
  1296                              <1> .draw_bar:
  1297 00001E43 E812F9              <1> 	call os_move_cursor
  1298                              <1> 
  1299 00001E46 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1300 00001E49 B95000              <1> 	mov cx, 80
  1301 00001E4C BB7000              <1> 	mov bx, 01110000b
  1302 00001E4F CD10                <1> 	int 10h
  1303 00001E51 C3                  <1> 	ret
  1304                              <1> 
  1305                              <1> ; ------------------------------------------------------------------
  1306                              <1> ; os_print_newline -- Reset cursor to start of next line
  1307                              <1> ; IN/OUT: None, registers preserved
  1308                              <1> 
  1309                              <1> os_print_newline:
  1310 00001E52 60                  <1> 	pusha
  1311                              <1> 
  1312 00001E53 B00D                <1> 	mov al, 13
  1313 00001E55 E87BF8              <1> 	call os_putchar
  1314 00001E58 B00A                <1> 	mov al, 10
  1315 00001E5A E977F8              <1> 	jmp os_putchar.no_pusha
  1316                              <1> 
  1317                              <1> 
  1318                              <1> ; ------------------------------------------------------------------
  1319                              <1> ; os_dump_registers -- Dumps all register contents in hex to the screen
  1320                              <1> ; IN: All registers
  1321                              <1> ; OUT: None, registers preserved
  1322                              <1> 
  1323                              <1> os_dump_registers:
  1324                              <1> 	; Push all registers
  1325                              <1> 
  1326 00001E5D 6660                <1> 	pushad
  1327 00001E5F 6657                <1> 	push edi
  1328 00001E61 6656                <1> 	push esi
  1329 00001E63 6652                <1> 	push edx
  1330 00001E65 6651                <1> 	push ecx
  1331 00001E67 6653                <1> 	push ebx
  1332 00001E69 6650                <1> 	push eax
  1333 00001E6B 16                  <1> 	push ss
  1334 00001E6C 0FA8                <1> 	push gs
  1335 00001E6E 0FA0                <1> 	push fs
  1336 00001E70 06                  <1> 	push es
  1337 00001E71 1E                  <1> 	push ds
  1338 00001E72 0E                  <1> 	push cs
  1339 00001E73 9C                  <1> 	pushf
  1340                              <1> 
  1341                              <1> 	; Calculate the SP before the call
  1342                              <1> 
  1343 00001E74 89E3                <1> 	mov bx, sp
  1344 00001E76 83C346              <1> 	add bx, 32 + 7 * 2 + 6 * 4
  1345 00001E79 53                  <1> 	push bx
  1346                              <1> 
  1347                              <1> 	; Get the return IP
  1348                              <1> 
  1349 00001E7A 368B17              <1> 	mov dx, [ss:bx]
  1350 00001E7D 52                  <1> 	push dx
  1351                              <1> 
  1352                              <1> 	; Dump the 16 bit registers
  1353                              <1> 
  1354                              <1> 	movs ds, cs
    39 00001E7E 0E                  <2>  push %2
    40 00001E7F 1F                  <2>  pop %1
  1355 00001E80 BE[C61E]            <1> 	mov si, .ip_string
  1356                              <1> 
  1357 00001E83 89E3                <1> 	mov bx, sp
  1358 00001E85 B90900              <1> 	mov cx, 9
  1359                              <1> 
  1360                              <1> .loop_16:
  1361 00001E88 E82A00              <1> 	call .print_string
  1362                              <1> 
  1363 00001E8B 368B07              <1> 	mov ax, [ss:bx]
  1364 00001E8E E88F01              <1> 	call os_print_4hex
  1365                              <1> 
  1366 00001E91 83C302              <1> 	add bx, 2
  1367                              <1> 
  1368 00001E94 E2F2                <1> 	loop .loop_16
  1369                              <1> 
  1370                              <1> 	; Dump the 32 bit registers
  1371                              <1> 
  1372 00001E96 B90600              <1> 	mov cx, 6
  1373                              <1> 	
  1374                              <1> .loop_32:
  1375 00001E99 E81900              <1> 	call .print_string
  1376                              <1> 
  1377 00001E9C 36668B07            <1> 	mov eax, [ss:bx]
  1378 00001EA0 E88701              <1> 	call os_print_8hex
  1379                              <1> 
  1380 00001EA3 83C304              <1> 	add bx, 4
  1381                              <1> 
  1382 00001EA6 E2F1                <1> 	loop .loop_32
  1383                              <1> 	
  1384 00001EA8 E8A7FF              <1> 	call os_print_newline
  1385                              <1> 
  1386                              <1> 	; Pop necessary registers
  1387                              <1> 
  1388 00001EAB 83C408              <1> 	add sp, 2 * 4			; IP, flags, SP, CS
  1389 00001EAE 1F                  <1> 	pop ds
  1390 00001EAF 83C420              <1> 	add sp, 2 * 4 + 4 * 6	; ES, FS, GS, SS, E**
  1391 00001EB2 6661                <1> 	popad
  1392 00001EB4 C3                  <1> 	ret
  1393                              <1> 
  1394                              <1> .print_string:
  1395 00001EB5 AC                  <1> 	lodsb
  1396                              <1> 
  1397 00001EB6 50                  <1> 	push ax
  1398 00001EB7 247F                <1> 	and al, 7Fh
  1399 00001EB9 E817F8              <1> 	call os_putchar
  1400 00001EBC 58                  <1> 	pop ax
  1401                              <1> 
  1402 00001EBD A880                <1> 	test al, 80h
  1403 00001EBF 74F4                <1> 	jz .print_string
  1404                              <1> 
  1405                              <1> .print_string_end:
  1406 00001EC1 B03A                <1> 	mov al, ':'
  1407 00001EC3 E90DF8              <1> 	jmp os_putchar
  1408                              <1> 
  1409 00001EC6 49D0                <1> 	.ip_string		db 'I', 'P' + 80h
  1410 00001EC8 2053D0              <1> 	.sp_string		db ' S', 'P' + 80h
  1411 00001ECB 20464C4147D3        <1> 	.flags_string	db ' FLAG', 'S' + 80h
  1412 00001ED1 2043D3              <1> 	.cs_string		db ' C', 'S' + 80h
  1413 00001ED4 2044D3              <1> 	.ds_string		db ' D', 'S' + 80h
  1414 00001ED7 2045D3              <1> 	.es_string		db ' E', 'S' + 80h
  1415 00001EDA 2046D3              <1> 	.fs_string		db ' F', 'S' + 80h
  1416 00001EDD 2047D3              <1> 	.gs_string		db ' G', 'S' + 80h
  1417 00001EE0 2053D3              <1> 	.ss_string		db ' S', 'S' + 80h
  1418 00001EE3 0D0A4541D8          <1> 	.ax_string		db 13, 10, 'EA', 'X' + 80h
  1419 00001EE8 204542D8            <1> 	.bx_string		db ' EB', 'X' + 80h
  1420 00001EEC 204543D8            <1> 	.cx_string		db ' EC', 'X' + 80h
  1421 00001EF0 204544D8            <1> 	.dx_string		db ' ED', 'X' + 80h
  1422 00001EF4 204553C9            <1> 	.si_string		db ' ES', 'I' + 80h
  1423 00001EF8 204544C9            <1> 	.di_string		db ' ED', 'I' + 80h
  1424                              <1> 
  1425                              <1> 
  1426                              <1> ; ------------------------------------------------------------------
  1427                              <1> ; os_input_dialog -- Get text string from user via a dialog box
  1428                              <1> ; IN: ES:AX = string location, DS:BX = message to show
  1429                              <1> ; OUT: None, registers preserved
  1430                              <1> 
  1431                              <1> os_input_dialog:
  1432 00001EFC 60                  <1> 	pusha
  1433                              <1> 	clr ch
    31 00001EFD 30ED                <2>  xor %1, %1
  1434 00001EFF EB03                <1> 	jmp int_input_dialog
  1435                              <1> 
  1436                              <1> ; ------------------------------------------------------------------
  1437                              <1> ; os_password_dialog -- Get a password from user via a dialog box
  1438                              <1> ; IN: ES:AX = string location, DS:BX = message to show
  1439                              <1> ; OUT: None, registers preserved
  1440                              <1> 
  1441                              <1> os_password_dialog:
  1442 00001F01 60                  <1> 	pusha
  1443 00001F02 B501                <1> 	mov ch, 1
  1444                              <1> 
  1445                              <1> ; ------------------------------------------------------------------
  1446                              <1> ; int_input_dialog -- Get text string from user via a dialog box
  1447                              <1> ; IN: ES:AX = string location, DS:BX = message to show,
  1448                              <1> ;     CH = CH = 0 if normal input, 1 if password input
  1449                              <1> ; OUT: None, registers preserved
  1450                              <1> 
  1451                              <1> int_input_dialog:
  1452 00001F04 60                  <1> 	pusha
  1453                              <1> 
  1454 00001F05 2E803E[F920]32      <1> 	cmp byte [cs:os_max_input_length], 50			; If there is no limit set, set it now
  1455 00001F0B 7206                <1> 	jb .no_adjust
  1456                              <1> 
  1457 00001F0D 2EC606[F920]32      <1> 	mov byte [cs:os_max_input_length], 50
  1458                              <1> 
  1459                              <1> .no_adjust:
  1460 00001F13 53                  <1> 	push bx				; Save message to show
  1461                              <1> 
  1462 00001F14 2E8A1EA9DE          <1> 	mov bl, [cs:CONFIG_WINDOW_BG_COLOR]		; Color from RAM
  1463                              <1> 	mov16 dx, 12, 10			; First, draw background box
    35 00001F19 BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  1464 00001F1C BE3700              <1> 	mov si, 55
  1465 00001F1F BF1000              <1> 	mov di, 16
  1466 00001F22 E860F8              <1> 	call os_draw_block
  1467                              <1> 
  1468                              <1> 	mov16 dx, 14, 14
    35 00001F25 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  1469 00001F28 E82DF8              <1> 	call os_move_cursor
  1470                              <1> 
  1471                              <1> 	mov16 ax, ' ', 09h
    35 00001F2B B82009              <2>  mov %1, (%2 + %3 * 256)
  1472 00001F2E BBF000              <1> 	mov bx, 240
  1473 00001F31 B93300              <1> 	mov cx, 51
  1474 00001F34 CD10                <1> 	int 10h
  1475                              <1> 	
  1476                              <1> 	mov16 dx, 14, 11
    35 00001F36 BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  1477 00001F39 E81CF8              <1> 	call os_move_cursor
  1478                              <1> 	
  1479 00001F3C 5B                  <1> 	pop bx				; Get message back and display it
  1480 00001F3D 89DE                <1> 	mov si, bx
  1481 00001F3F E8A8F7              <1> 	call os_print_string
  1482                              <1> 
  1483                              <1> 	mov16 dx, 14, 14
    35 00001F42 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  1484 00001F45 E810F8              <1> 	call os_move_cursor
  1485                              <1> 
  1486 00001F48 61                  <1> 	popa
  1487                              <1> 
  1488 00001F49 68[521F]            <1> 	push .retptr		; Don't worry too much about this
  1489 00001F4C 60                  <1> 	pusha
  1490                              <1> 	clr si
    31 00001F4D 31F6                <2>  xor %1, %1
  1491 00001F4F E91701              <1> 	jmp os_input_string_ex.no_pusha
  1492                              <1> 
  1493                              <1> .retptr:
  1494 00001F52 61                  <1> 	popa
  1495 00001F53 C3                  <1> 	ret
  1496                              <1> 
  1497                              <1> ; ------------------------------------------------------------------
  1498                              <1> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
  1499                              <1> ; IN: DS:AX, DS:BX, DS:CX = string locations (set registers to 0 for no display),
  1500                              <1> ; IN: DX = 0 for single 'OK' dialog,
  1501                              <1> ;          1 for two-button 'OK' and 'Cancel' ('OK' selected by default),
  1502                              <1> ;          2 for two-button 'OK' and 'Cancel' ('Cancel' selected by default)
  1503                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
  1504                              <1> ; NOTE: Each string is limited to 40 characters
  1505                              <1> 
  1506                              <1> os_dialog_box:
  1507 00001F54 60                  <1> 	pusha
  1508 00001F55 89C6                <1> 	mov si, ax
  1509 00001F57 89D8                <1> 	mov ax, bx
  1510 00001F59 89CB                <1> 	mov bx, cx
  1511                              <1> 	clr cx
    31 00001F5B 31C9                <2>  xor %1, %1
  1512                              <1> 	clr dx
    31 00001F5D 31D2                <2>  xor %1, %1
  1513 00001F5F E85902              <1> 	call os_temp_box
  1514 00001F62 61                  <1> 	popa
  1515                              <1> 
  1516 00001F63 60                  <1> 	pusha
  1517 00001F64 1E                  <1> 	push ds
  1518                              <1> 	movs ds, cs
    39 00001F65 0E                  <2>  push %2
    40 00001F66 1F                  <2>  pop %1
  1519                              <1> 
  1520 00001F67 83FA01              <1> 	cmp dx, 1
  1521 00001F6A 7D1D                <1> 	jge .two_button
  1522                              <1> 
  1523                              <1> .one_button:
  1524                              <1> 	mov16 dx, 35, 14
    35 00001F6C BA230E              <2>  mov %1, (%2 + %3 * 256)
  1525 00001F6F E8E6F7              <1> 	call os_move_cursor
  1526                              <1> 
  1527 00001F72 B3F0                <1> 	mov bl, 0F0h
  1528 00001F74 BE[E91F]            <1> 	mov si, .ok_button_string
  1529 00001F77 E892F7              <1> 	call os_format_string
  1530                              <1> 
  1531                              <1> .one_button_wait:
  1532 00001F7A E808F2              <1> 	call os_wait_for_key
  1533 00001F7D 3C1B                <1> 	cmp al, 27
  1534 00001F7F 7404                <1> 	je .one_button_exit
  1535                              <1> 
  1536 00001F81 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  1537 00001F83 75F5                <1> 	jne .one_button_wait
  1538                              <1> 
  1539                              <1> .one_button_exit:
  1540 00001F85 1F                  <1> 	pop ds
  1541 00001F86 E9E8F7              <1> 	jmp os_show_cursor.no_pusha
  1542                              <1> 
  1543                              <1> .two_button:
  1544 00001F89 83FA02              <1> 	cmp dx, 2
  1545 00001F8C 7435                <1> 	je .draw_right
  1546 00001F8E 7529                <1> 	jne .draw_left
  1547                              <1> 	
  1548                              <1> .two_button_wait:
  1549 00001F90 E8F2F1              <1> 	call os_wait_for_key
  1550                              <1> 
  1551 00001F93 80FC4B              <1> 	cmp ah, 75			; Left cursor key pressed?
  1552 00001F96 7421                <1> 	je .draw_left
  1553 00001F98 80FC4D              <1> 	cmp ah, 77			; Right cursor key pressed?
  1554 00001F9B 7426                <1> 	je .draw_right
  1555                              <1> 	
  1556 00001F9D 3C1B                <1> 	cmp al, 27			; Escape, automatically select "Cancel"
  1557 00001F9F 7414                <1> 	je .cancel
  1558 00001FA1 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  1559 00001FA3 75EB                <1> 	jne .two_button_wait
  1560                              <1> 
  1561                              <1> .exit:	
  1562 00001FA5 E8C8F7              <1> 	call os_show_cursor
  1563                              <1> 
  1564 00001FA8 880E[FB1F]          <1> 	mov [.tmp], cl			; Keep result after restoring all regs
  1565 00001FAC 1F                  <1> 	pop ds
  1566 00001FAD 61                  <1> 	popa
  1567 00001FAE 2E0FB606[FB1F]      <1> 	movzx ax, byte [cs:.tmp]
  1568                              <1> 
  1569 00001FB4 C3                  <1> 	ret
  1570                              <1> 
  1571                              <1> .cancel:
  1572 00001FB5 B101                <1> 	mov cl, 1
  1573 00001FB7 EBEC                <1> 	jmp .exit
  1574                              <1> 
  1575                              <1> .draw_left:
  1576                              <1> 	clr cl
    31 00001FB9 30C9                <2>  xor %1, %1
  1577 00001FBB B3F0                <1> 	mov bl, 11110000b
  1578 00001FBD 8A3EA9DE            <1> 	mov bh, [CONFIG_WINDOW_BG_COLOR]
  1579                              <1> 
  1580 00001FC1 EB0A                <1> 	jmp .draw_buttons
  1581                              <1> 
  1582                              <1> .draw_right:
  1583 00001FC3 B101                <1> 	mov cl, 1
  1584 00001FC5 8A1EA9DE            <1> 	mov bl, [CONFIG_WINDOW_BG_COLOR]
  1585 00001FC9 B7F0                <1> 	mov bh, 11110000b
  1586                              <1> 
  1587 00001FCB EB00                <1> 	jmp .draw_buttons
  1588                              <1> 
  1589                              <1> .draw_buttons:
  1590                              <1> 	mov16 dx, 27, 14
    35 00001FCD BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  1591 00001FD0 E885F7              <1> 	call os_move_cursor
  1592                              <1> 
  1593 00001FD3 BE[E91F]            <1> 	mov si, .ok_button_string
  1594 00001FD6 E833F7              <1> 	call os_format_string
  1595                              <1> 
  1596                              <1> 	mov16 dx, 42, 14
    35 00001FD9 BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  1597 00001FDC E879F7              <1> 	call os_move_cursor
  1598                              <1> 
  1599 00001FDF 88FB                <1> 	mov bl, bh
  1600 00001FE1 BE[F21F]            <1> 	mov si, .cancel_button_string
  1601 00001FE4 E825F7              <1> 	call os_format_string
  1602                              <1> 
  1603 00001FE7 EBA7                <1> 	jmp .two_button_wait
  1604                              <1> 
  1605 00001FE9 2020204F4B20202000  <1> 	.ok_button_string	db '   OK   ', 0
  1606 00001FF2 2043616E63656C2000  <1> 	.cancel_button_string	db ' Cancel ', 0
  1607                              <1> 
  1608 00001FFB 00                  <1> 	.tmp db 0
  1609                              <1> 
  1610                              <1> ; ------------------------------------------------------------------
  1611                              <1> ; os_print_space -- Print a space to the screen
  1612                              <1> ; IN/OUT: None, registers preserved
  1613                              <1> 
  1614                              <1> os_print_space:
  1615 00001FFC 60                  <1> 	pusha
  1616 00001FFD B020                <1> 	mov al, ' '
  1617 00001FFF E9D2F6              <1> 	jmp os_putchar.no_pusha
  1618                              <1> 
  1619                              <1> 
  1620                              <1> ; ------------------------------------------------------------------
  1621                              <1> ; os_print_digit -- Displays contents of AX as a single digit
  1622                              <1> ; Works up to base 37, ie digits 0-Z
  1623                              <1> ; IN: AX = "digit" to format and print
  1624                              <1> ; OUT: None, registers preserved
  1625                              <1> 
  1626                              <1> os_print_digit:
  1627 00002002 50                  <1> 	push ax
  1628                              <1> 
  1629                              <1> .no_push_ax:
  1630 00002003 3C09                <1> 	cmp al, 9			; There is a break in ASCII table between 9 and A
  1631 00002005 7E02                <1> 	jle .digit_format
  1632                              <1> 
  1633 00002007 0407                <1> 	add al, 'A'-'9'-1		; Correct for the skipped punctuation
  1634                              <1> 
  1635                              <1> .digit_format:
  1636 00002009 0430                <1> 	add al, '0'			; 0 will display as '0', etc.	
  1637                              <1> 
  1638 0000200B E8C5F6              <1> 	call os_putchar
  1639 0000200E 58                  <1> 	pop ax
  1640 0000200F C3                  <1> 	ret
  1641                              <1> 
  1642                              <1> 
  1643                              <1> ; ------------------------------------------------------------------
  1644                              <1> ; os_print_1hex -- Displays low nibble of AL in hex format
  1645                              <1> ; IN: AL = number to format and print
  1646                              <1> ; OUT: None, registers preserved
  1647                              <1> 
  1648                              <1> os_print_1hex:
  1649 00002010 50                  <1> 	push ax
  1650                              <1> 
  1651                              <1> .no_push_ax:
  1652 00002011 240F                <1> 	and al, 0Fh			; Mask off data to display
  1653 00002013 EBEE                <1> 	jmp os_print_digit.no_push_ax
  1654                              <1> 
  1655                              <1> 
  1656                              <1> ; ------------------------------------------------------------------
  1657                              <1> ; os_print_2hex -- Displays AL in hex format
  1658                              <1> ; IN: AL = number to format and print
  1659                              <1> ; OUT: None, registers preserved
  1660                              <1> 
  1661                              <1> os_print_2hex:
  1662 00002015 50                  <1> 	push ax
  1663                              <1> 
  1664                              <1> .no_push_ax:
  1665 00002016 50                  <1> 	push ax				; Output high nibble
  1666 00002017 C1E804              <1> 	shr ax, 4
  1667 0000201A E8F3FF              <1> 	call os_print_1hex
  1668                              <1> 
  1669 0000201D 58                  <1> 	pop ax				; Output low nibble
  1670 0000201E EBF1                <1> 	jmp os_print_1hex.no_push_ax
  1671                              <1> 
  1672                              <1> 
  1673                              <1> ; ------------------------------------------------------------------
  1674                              <1> ; os_print_4hex -- Displays AX in hex format
  1675                              <1> ; IN: AX = number to format and print
  1676                              <1> ; OUT: None, registers preserved
  1677                              <1> 
  1678                              <1> os_print_4hex:
  1679 00002020 50                  <1> 	push ax
  1680                              <1> 
  1681 00002021 50                  <1> 	push ax				; Output high byte
  1682 00002022 88E0                <1> 	mov al, ah
  1683 00002024 E8EEFF              <1> 	call os_print_2hex
  1684                              <1> 
  1685 00002027 58                  <1> 	pop ax				; Output low byte
  1686 00002028 EBEC                <1> 	jmp os_print_2hex.no_push_ax
  1687                              <1> 
  1688                              <1> ; ------------------------------------------------------------------
  1689                              <1> ; os_print_8hex - Displays EAX in hex format
  1690                              <1> ; IN: EAX = unsigned integer
  1691                              <1> ; OUT: None, registers preserved
  1692                              <1> 
  1693                              <1> os_print_8hex:
  1694 0000202A 6660                <1> 	pushad
  1695 0000202C 66C1E810            <1> 	shr eax, 16
  1696 00002030 E8EDFF              <1> 	call os_print_4hex
  1697 00002033 6661                <1> 	popad
  1698 00002035 E8E8FF              <1> 	call os_print_4hex
  1699 00002038 C3                  <1> 	ret
  1700                              <1> 
  1701                              <1> ; ------------------------------------------------------------------
  1702                              <1> ; os_print_int -- Prints an integer in decimal.
  1703                              <1> ; IN: AX = unsigned integer
  1704                              <1> ; OUT: None, registers preserved
  1705                              <1> 
  1706                              <1> os_print_int:
  1707 00002039 60                  <1> 	pusha
  1708 0000203A 1E                  <1> 	push ds
  1709 0000203B E89C08              <1> 	call os_int_to_string
  1710 0000203E 89C6                <1> 	mov si, ax
  1711 00002040 E8A7F6              <1> 	call os_print_string
  1712 00002043 1F                  <1> 	pop ds
  1713 00002044 61                  <1> 	popa
  1714 00002045 C3                  <1> 	ret
  1715                              <1> 
  1716                              <1> ; ------------------------------------------------------------------
  1717                              <1> ; os_print_32int -- Prints a 32 bit integer in decimal.
  1718                              <1> ; IN: EAX = unsigned integer
  1719                              <1> ; OUT: None, registers preserved
  1720                              <1> 
  1721                              <1> os_print_32int:
  1722 00002046 6660                <1> 	pushad
  1723 00002048 1E                  <1> 	push ds
  1724 00002049 E8160A              <1> 	call os_32int_to_string
  1725 0000204C 89C6                <1> 	mov si, ax
  1726 0000204E E899F6              <1> 	call os_print_string
  1727 00002051 1F                  <1> 	pop ds
  1728 00002052 6661                <1> 	popad
  1729 00002054 C3                  <1> 	ret
  1730                              <1> 
  1731                              <1> ; ------------------------------------------------------------------
  1732                              <1> ; os_input_string -- Take string from keyboard entry
  1733                              <1> ; IN: ES:AX = location of string
  1734                              <1> ; OUT: None, registers preserved
  1735                              <1> 
  1736                              <1> os_input_string:
  1737 00002055 60                  <1> 	pusha
  1738                              <1> 
  1739                              <1> .no_pusha:
  1740                              <1> 	clr ch
    31 00002056 30ED                <2>  xor %1, %1
  1741                              <1> 	clr si
    31 00002058 31F6                <2>  xor %1, %1
  1742 0000205A EB0D                <1> 	jmp os_input_string_ex.no_pusha
  1743                              <1> 
  1744                              <1> ; ------------------------------------------------------------------
  1745                              <1> ; os_input_password -- Take password from keyboard entry
  1746                              <1> ; IN: ES:AX = location of string
  1747                              <1> ; OUT: None, registers preserved
  1748                              <1> 
  1749                              <1> os_input_password:
  1750 0000205C 60                  <1> 	pusha
  1751                              <1> 
  1752                              <1> .no_pusha:
  1753 0000205D B501                <1> 	mov ch, 1
  1754                              <1> 	clr si
    31 0000205F 31F6                <2>  xor %1, %1
  1755 00002061 EB06                <1> 	jmp os_input_string_ex.no_pusha
  1756                              <1> 
  1757                              <1> ; ------------------------------------------------------------------
  1758                              <1> ; os_set_max_input_length -- Set the maximum length for the next string input
  1759                              <1> ; IN: AL = maximum number of characters
  1760                              <1> ; OUT: None, registers preserved
  1761                              <1> 
  1762                              <1> os_set_max_input_length:
  1763 00002063 2EA2[F920]          <1> 	mov [cs:os_max_input_length], al
  1764 00002067 C3                  <1> 	ret
  1765                              <1> 
  1766                              <1> ; ------------------------------------------------------------------
  1767                              <1> ; os_input_string_ex -- Take string from keyboard entry
  1768                              <1> ; IN: ES:AX = location of string, CH = 0 if normal input, 1 if password input,
  1769                              <1> ;     DS:SI = callback on keys where AL = 0 (input: AX = keypress)
  1770                              <1> ; OUT: None, registers preserved
  1771                              <1> 
  1772                              <1> os_input_string_ex:
  1773 00002068 60                  <1> 	pusha
  1774                              <1> 
  1775                              <1> .no_pusha:
  1776 00002069 2E8936[F520]        <1> 	mov [cs:.callback_offset], si
  1777 0000206E 2E8C1E[F720]        <1> 	mov [cs:.callback_segment], ds
  1778                              <1> 
  1779 00002073 E8FAF6              <1> 	call os_show_cursor
  1780                              <1> 	
  1781 00002076 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  1782                              <1> 	clr cl				; Received characters counter for backspace
    31 00002078 30C9                <2>  xor %1, %1
  1783                              <1> 
  1784                              <1> .more:
  1785 0000207A E808F1              <1> 	call os_wait_for_key
  1786                              <1> 
  1787 0000207D 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  1788 0000207F 7469                <1> 	je .done
  1789                              <1> 
  1790 00002081 3C08                <1> 	cmp al, 8			; Backspace pressed?
  1791 00002083 7432                <1> 	je .backspace		; If so, skip following checks
  1792                              <1> 
  1793 00002085 3C20                <1> 	cmp al, ' '			; If an incompatible key pressed, call the callback
  1794 00002087 7C16                <1> 	jl .callback
  1795                              <1> 
  1796 00002089 2E3A0E[F920]        <1> 	cmp cl, [cs:os_max_input_length]	; Make sure we don't exhaust buffer
  1797 0000208E 74EA                <1> 	je .more
  1798                              <1> 
  1799 00002090 AA                  <1> 	stosb				; Store character in designated buffer
  1800                              <1> 
  1801 00002091 80FD00              <1> 	cmp ch, 0
  1802 00002094 7402                <1> 	je .no_star
  1803                              <1> 
  1804 00002096 B02A                <1> 	mov al, '*'			; If password input was selected, print stars instead
  1805                              <1> 
  1806                              <1> .no_star:
  1807 00002098 E838F6              <1> 	call os_putchar
  1808                              <1> 
  1809 0000209B FEC1                <1> 	inc cl				; Characters processed += 1
  1810                              <1> 	
  1811 0000209D EBDB                <1> 	jmp .more			; Still room for more
  1812                              <1> 
  1813                              <1> .callback:
  1814 0000209F 85F6                <1> 	test si, si
  1815 000020A1 74D7                <1> 	jz .more
  1816                              <1> 
  1817 000020A3 60                  <1> 	pusha
  1818 000020A4 1E                  <1> 	push ds
  1819 000020A5 06                  <1> 	push es
  1820 000020A6 2E8E1E[F720]        <1> 	mov ds, [cs:.callback_segment]
  1821                              <1> 	movs es, ds
    39 000020AB 1E                  <2>  push %2
    40 000020AC 07                  <2>  pop %1
  1822                              <1> 
  1823 000020AD 2EFF1E[F520]        <1> 	call far [cs:.callback_offset]
  1824 000020B2 07                  <1> 	pop es
  1825 000020B3 1F                  <1> 	pop ds
  1826 000020B4 61                  <1> 	popa
  1827 000020B5 EBC3                <1> 	jmp .more
  1828                              <1> 
  1829                              <1> .backspace:
  1830 000020B7 84C9                <1> 	test cl, cl			; Backspace at start of string?
  1831 000020B9 74BF                <1> 	jz .more			; Ignore it if so
  1832                              <1> 
  1833 000020BB E8A3F6              <1> 	call os_get_cursor_pos		; Backspace at start of screen line?
  1834 000020BE 84D2                <1> 	test dl, dl
  1835 000020C0 7412                <1> 	jz .backspace_linestart
  1836                              <1> 
  1837 000020C2 FECA                <1> 	dec dl
  1838 000020C4 E891F6              <1> 	call os_move_cursor
  1839 000020C7 B020                <1> 	mov al, ' '
  1840 000020C9 E807F6              <1> 	call os_putchar
  1841 000020CC E889F6              <1> 	call os_move_cursor
  1842                              <1> 
  1843 000020CF 4F                  <1> 	dec di				; Character position will be overwritten by new
  1844                              <1> 						; character or terminator at end
  1845                              <1> 
  1846 000020D0 FEC9                <1> 	dec cl				; Step back counter
  1847                              <1> 
  1848 000020D2 EBA6                <1> 	jmp .more
  1849                              <1> 
  1850                              <1> .backspace_linestart:
  1851 000020D4 FECE                <1> 	dec dh				; Jump back to end of previous line
  1852 000020D6 B24F                <1> 	mov dl, 79
  1853 000020D8 E87DF6              <1> 	call os_move_cursor
  1854                              <1> 
  1855 000020DB B020                <1> 	mov al, ' '			; Clear the character there
  1856 000020DD E8F3F5              <1> 	call os_putchar
  1857                              <1> 
  1858 000020E0 B24F                <1> 	mov dl, 79			; And jump back before the space
  1859 000020E2 E873F6              <1> 	call os_move_cursor
  1860                              <1> 
  1861 000020E5 4F                  <1> 	dec di				; Step back position in string
  1862 000020E6 FEC9                <1> 	dec cl				; Step back counter
  1863                              <1> 
  1864 000020E8 EB90                <1> 	jmp .more
  1865                              <1> 
  1866                              <1> .done:
  1867                              <1> 	clr al
    31 000020EA 30C0                <2>  xor %1, %1
  1868 000020EC AA                  <1> 	stosb
  1869                              <1> 
  1870 000020ED 2EC606[F920]FF      <1> 	mov byte [cs:os_max_input_length], 255	; Restore the max length to max
  1871                              <1> 
  1872 000020F3 61                  <1> 	popa
  1873 000020F4 C3                  <1> 	ret
  1874                              <1> 
  1875 000020F5 0000                <1> 	.callback_offset		dw 0
  1876 000020F7 0000                <1> 	.callback_segment		dw 0
  1877                              <1> 
  1878 000020F9 FF                  <1> 	os_max_input_length		db 255
  1879                              <1> 
  1880                              <1> ; ------------------------------------------------------------------
  1881                              <1> ; os_color_selector - Pops up a color selector.
  1882                              <1> ; IN: None
  1883                              <1> ; OUT: color number (0-15)
  1884                              <1> 
  1885                              <1> os_color_selector:
  1886 000020FA 1E                  <1> 	push ds
  1887 000020FB 60                  <1> 	pusha
  1888                              <1> 	movs ds, cs
    39 000020FC 0E                  <2>  push %2
    40 000020FD 1F                  <2>  pop %1
  1889                              <1> 
  1890 000020FE B8[2E21]            <1> 	mov ax, .colorlist			; Call os_list_dialog with colors
  1891 00002101 BB[A921]            <1> 	mov bx, .colormsg0
  1892 00002104 B9[BA21]            <1> 	mov cx, .colormsg1
  1893                              <1> 
  1894 00002107 BE[1A21]            <1> 	mov si, .callback
  1895 0000210A E848F9              <1> 	call os_list_dialog_tooltip
  1896 0000210D 9C                  <1> 	pushf
  1897                              <1> 	
  1898 0000210E FEC8                <1> 	dec al						; Output from os_list_dialog starts with 1, so decrement it
  1899 00002110 89E3                <1> 	mov bx, sp
  1900 00002112 36884710            <1> 	mov [ss:bx + 16], al
  1901 00002116 9D                  <1> 	popf
  1902 00002117 61                  <1> 	popa
  1903 00002118 1F                  <1> 	pop ds
  1904 00002119 C3                  <1> 	ret
  1905                              <1> 
  1906                              <1> .callback:
  1907 0000211A FEC8                <1> 	dec al
  1908 0000211C 88C3                <1> 	mov bl, al			; Selected color
  1909 0000211E C0E304              <1> 	shl bl, 4
  1910                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    35 00002121 BA2902              <2>  mov %1, (%2 + %3 * 256)
  1911 00002124 BE2500              <1> 	mov si, 37			; Width
  1912 00002127 BF1700              <1> 	mov di, 23			; Finish Y position
  1913 0000212A E858F6              <1> 	call os_draw_block	; Draw option selector window	
  1914 0000212D C3                  <1> 	ret
  1915                              <1> 
  1916 0000212E 426C61636B2C426C75- <1> 	.colorlist	db 'Black,Blue,Green,Cyan,Red,Magenta,Brown,Light Gray,Dark Gray,Light Blue,Light Green,Light Cyan,Light Red,Pink,Yellow,White', 0
  1916 00002137 652C477265656E2C43- <1>
  1916 00002140 79616E2C5265642C4D- <1>
  1916 00002149 6167656E74612C4272- <1>
  1916 00002152 6F776E2C4C69676874- <1>
  1916 0000215B 20477261792C446172- <1>
  1916 00002164 6B20477261792C4C69- <1>
  1916 0000216D 67687420426C75652C- <1>
  1916 00002176 4C6967687420477265- <1>
  1916 0000217F 656E2C4C6967687420- <1>
  1916 00002188 4379616E2C4C696768- <1>
  1916 00002191 74205265642C50696E- <1>
  1916 0000219A 6B2C59656C6C6F772C- <1>
  1916 000021A3 576869746500        <1>
  1917 000021A9 43686F6F7365206120- <1> 	.colormsg0	db 'Choose a color...' ; termination not necessary here
  1917 000021B2 636F6C6F722E2E2E    <1>
  1918 000021BA 00                  <1> 	.colormsg1	db 0
  1919                              <1> 	
  1920                              <1> ; ------------------------------------------------------------------
  1921                              <1> ; os_temp_box -- Draws a dialog box with up to 5 lines of text.
  1922                              <1> ; IN: DS:SI/AX/BX/CX/DX = string locations (or 0 for no display)
  1923                              <1> ; OUT: None, registers preserved
  1924                              <1> 
  1925                              <1> os_temp_box:
  1926 000021BB 60                  <1> 	pusha
  1927                              <1> 
  1928 000021BC 52                  <1> 	push dx
  1929 000021BD 51                  <1> 	push cx
  1930 000021BE 53                  <1> 	push bx
  1931 000021BF 50                  <1> 	push ax
  1932 000021C0 56                  <1> 	push si
  1933                              <1> 	
  1934 000021C1 E8B7F5              <1> 	call os_hide_cursor
  1935                              <1> 
  1936 000021C4 2E8A1EA9DE          <1> 	mov bl, [cs:CONFIG_WINDOW_BG_COLOR]		; Color from RAM
  1937                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    35 000021C9 BA1309              <2>  mov %1, (%2 + %3 * 256)
  1938 000021CC BE2A00              <1> 	mov si, 42
  1939 000021CF BF1000              <1> 	mov di, 16
  1940 000021D2 E8B0F5              <1> 	call os_draw_block
  1941                              <1> 
  1942                              <1> 	mov16 dx, 20, 9
    35 000021D5 BA1409              <2>  mov %1, (%2 + %3 * 256)
  1943 000021D8 B90500              <1> 	mov cx, 5
  1944                              <1> 
  1945                              <1> .loop:
  1946 000021DB FEC6                <1> 	inc dh
  1947 000021DD E878F5              <1> 	call os_move_cursor
  1948                              <1> 
  1949 000021E0 5E                  <1> 	pop si
  1950 000021E1 85F6                <1> 	test si, si			; Skip string params if zero
  1951 000021E3 7403                <1> 	jz .no_string
  1952                              <1> 
  1953 000021E5 E802F5              <1> 	call os_print_string
  1954                              <1> 
  1955                              <1> .no_string:
  1956 000021E8 E2F1                <1> 	loop .loop
  1957                              <1> 
  1958 000021EA 61                  <1> 	popa
  1959 000021EB C3                  <1> 	ret
  1960                              <1> 
  1961                              <1> ; ------------------------------------------------------------------
  1962                              <1> ; int_save_footer -- Saves the current footer & prepares cursor, if applicable.
  1963                              <1> ; IN: None
  1964                              <1> ; OUT: DX = cursor position where to return, CF = 1 if no message should be printed
  1965                              <1> 
  1966                              <1> int_save_footer:
  1967 000021EC 60                  <1> 	pusha
  1968 000021ED 2E803E[6909]01      <1> 	cmp byte [cs:system_ui_state], 1
  1969 000021F3 F9                  <1> 	stc
  1970 000021F4 0F849EF4            <1> 	je int_popa_ret
  1971                              <1> 
  1972 000021F8 E866F5              <1> 	call os_get_cursor_pos
  1973 000021FB 2E8916[B122]        <1> 	mov [cs:int_footer_cursor], dx
  1974                              <1> 
  1975 00002200 06                  <1> 	push es
  1976                              <1> 	movs es, cs
    39 00002201 0E                  <2>  push %2
    40 00002202 07                  <2>  pop %1
  1977                              <1> 
  1978 00002203 BF[6122]            <1> 	mov di, int_footer_data
  1979                              <1> 	mov16 dx, 0, 24
    35 00002206 BA0018              <2>  mov %1, (%2 + %3 * 256)
  1980                              <1> 	
  1981                              <1> .loop:
  1982 00002209 E84CF5              <1> 	call os_move_cursor
  1983                              <1> 	
  1984 0000220C B408                <1> 	mov ah, 08h
  1985                              <1> 	clr bh
    31 0000220E 30FF                <2>  xor %1, %1
  1986 00002210 CD10                <1> 	int 10h
  1987                              <1> 	
  1988 00002212 AA                  <1> 	stosb
  1989                              <1> 	
  1990 00002213 FEC2                <1> 	inc dl
  1991 00002215 80FA4F              <1> 	cmp dl, 79
  1992 00002218 7CEF                <1> 	jl .loop
  1993                              <1> 
  1994                              <1> 	mov16 dx, 0, 24
    35 0000221A BA0018              <2>  mov %1, (%2 + %3 * 256)
  1995 0000221D E838F5              <1> 	call os_move_cursor
  1996                              <1> 	
  1997 00002220 B82009              <1> 	mov ax, 0920h
  1998 00002223 BB7000              <1> 	mov bx, 70h
  1999 00002226 B95000              <1> 	mov cx, 80
  2000 00002229 CD10                <1> 	int 10h
  2001                              <1> 	
  2002 0000222B FEC2                <1> 	inc dl
  2003 0000222D E828F5              <1> 	call os_move_cursor
  2004                              <1> 
  2005 00002230 F8                  <1> 	clc
  2006 00002231 07                  <1> 	pop es
  2007 00002232 61                  <1> 	popa
  2008 00002233 C3                  <1> 	ret
  2009                              <1> 
  2010                              <1> ; ------------------------------------------------------------------
  2011                              <1> ; int_restore_footer -- Restores the saved footer, if applicable.
  2012                              <1> ; IN: DX = cursor position where to return
  2013                              <1> ; OUT: None, registers preserved
  2014                              <1> 
  2015                              <1> int_restore_footer:
  2016 00002234 60                  <1> 	pusha
  2017 00002235 2E803E[6909]01      <1> 	cmp byte [cs:system_ui_state], 1
  2018 0000223B 0F8457F4            <1> 	je int_popa_ret
  2019                              <1> 
  2020                              <1> 	mov16 dx, 0, 24
    35 0000223F BA0018              <2>  mov %1, (%2 + %3 * 256)
  2021 00002242 E813F5              <1> 	call os_move_cursor
  2022                              <1> 	
  2023 00002245 B82009              <1> 	mov ax, 0920h
  2024 00002248 BB7000              <1> 	mov bx, 70h
  2025 0000224B B95000              <1> 	mov cx, 80
  2026 0000224E CD10                <1> 	int 10h
  2027                              <1> 	
  2028 00002250 1E                  <1> 	push ds
  2029                              <1> 	movs ds, cs
    39 00002251 0E                  <2>  push %2
    40 00002252 1F                  <2>  pop %1
  2030 00002253 BE[6122]            <1> 	mov si, int_footer_data
  2031 00002256 E891F4              <1> 	call os_print_string
  2032                              <1> 
  2033 00002259 8B16[B122]          <1> 	mov dx, [int_footer_cursor]
  2034 0000225D 1F                  <1> 	pop ds
  2035 0000225E E9F8F4              <1> 	jmp os_move_cursor.no_pusha
  2036                              <1> 
  2037 00002261 00<rep 50h>         <1> 	int_footer_data		times 80 db 0	; 80 chars + zero term.
  2038 000022B1 0000                <1> 	int_footer_cursor	dw 0
  2039                              <1> 
  2040                              <1> ; ------------------------------------------------------------------
  2041                              <1> ; os_reset_font -- Resets the font to the selected default.
  2042                              <1> ; IN/OUT = None, registers preserved
  2043                              <1> 
  2044                              <1> os_reset_font:
  2045 000022B3 60                  <1> 	pusha
  2046                              <1> 	
  2047 000022B4 2E803EF1DE01        <1> 	cmp byte [cs:CONFIG_FONT], CFG_FONT_BIOS
  2048 000022BA 7415                <1> 	je .bios
  2049                              <1> 	
  2050 000022BC 06                  <1> 	push es
  2051 000022BD B80011              <1> 	mov ax, 1100h
  2052 000022C0 BB0010              <1> 	mov bx, 1000h
  2053 000022C3 B90001              <1> 	mov cx, 0100h
  2054                              <1> 	clr dx
    31 000022C6 31D2                <2>  xor %1, %1
  2055                              <1> 	movs es, fs
    39 000022C8 0FA0                <2>  push %2
    40 000022CA 07                  <2>  pop %1
  2056 000022CB BD0016              <1> 	mov bp, SYSTEM_FONT
  2057 000022CE CD10                <1> 	int 10h
  2058 000022D0 07                  <1> 	pop es
  2059                              <1> 
  2060                              <1> .bios:
  2061 000022D1 61                  <1> 	popa
  2062 000022D2 C3                  <1> 	ret
  2063                              <1> 
  2064                              <1> ; ------------------------------------------------------------------
  2065                              <1> ; os_draw_logo -- Draws the MichalOS logo.
  2066                              <1> ; IN: None
  2067                              <1> ; OUT: A very beautiful logo :-)
  2068                              <1> 
  2069                              <1> os_draw_logo:
  2070 000022D3 60                  <1> 	pusha
  2071 000022D4 1E                  <1> 	push ds
  2072                              <1> 	movs ds, cs
    39 000022D5 0E                  <2>  push %2
    40 000022D6 1F                  <2>  pop %1
  2073                              <1> 
  2074 000022D7 B82009              <1> 	mov ax, 0920h
  2075 000022DA BB0400              <1> 	mov bx, 00000100b
  2076 000022DD B93002              <1> 	mov cx, 560
  2077 000022E0 CD10                <1> 	int 10h
  2078                              <1> 
  2079 000022E2 BE[8C09]            <1> 	mov si, logo
  2080 000022E5 E80300              <1> 	call os_draw_icon
  2081                              <1> 
  2082 000022E8 1F                  <1> 	pop ds
  2083 000022E9 61                  <1> 	popa
  2084 000022EA C3                  <1> 	ret
  2085                              <1> 
  2086                              <1> ; ------------------------------------------------------------------
  2087                              <1> ; os_draw_icon -- Draws an icon (in the MichalOS format).
  2088                              <1> ; IN: DS:SI = address of the icon
  2089                              <1> ; OUT: None, registers preserved
  2090                              <1> 
  2091                              <1> os_draw_icon:
  2092 000022EB 60                  <1> 	pusha
  2093                              <1> 	
  2094                              <1> .no_pusha:
  2095 000022EC E872F4              <1> 	call os_get_cursor_pos
  2096                              <1> 	
  2097 000022EF AD                  <1> 	lodsw
  2098                              <1> 	
  2099                              <1> 	clr cx
    31 000022F0 31C9                <2>  xor %1, %1
  2100                              <1> 	
  2101                              <1> .loop:
  2102 000022F2 50                  <1> 	push ax
  2103 000022F3 51                  <1> 	push cx
  2104                              <1> 
  2105 000022F4 AC                  <1> 	lodsb
  2106                              <1> 		
  2107 000022F5 B90400              <1> 	mov cx, 4
  2108 000022F8 88C4                <1> 	mov ah, al
  2109                              <1> 
  2110                              <1> .byteloop:
  2111 000022FA 0FB6DC              <1> 	movzx bx, ah
  2112 000022FD 80E3C0              <1> 	and bl, 11000000b
  2113 00002300 C0EB06              <1> 	shr bl, 6
  2114 00002303 2E8A87[2723]        <1> 	mov al, [cs:.chars + bx]
  2115 00002308 E8C8F3              <1> 	call os_putchar
  2116                              <1> 
  2117 0000230B C0E402              <1> 	shl ah, 2
  2118                              <1> 
  2119 0000230E E2EA                <1> 	loop .byteloop
  2120                              <1> 
  2121 00002310 59                  <1> 	pop cx
  2122 00002311 58                  <1> 	pop ax
  2123                              <1> 
  2124 00002312 FEC1                <1> 	inc cl
  2125 00002314 38C1                <1> 	cmp cl, al
  2126 00002316 75DA                <1> 	jne .loop
  2127                              <1> 
  2128 00002318 FEC6                <1> 	inc dh
  2129 0000231A E83BF4              <1> 	call os_move_cursor
  2130                              <1> 	
  2131                              <1> 	clr cl
    31 0000231D 30C9                <2>  xor %1, %1
  2132 0000231F FEC5                <1> 	inc ch
  2133 00002321 38E5                <1> 	cmp ch, ah
  2134 00002323 75CD                <1> 	jne .loop
  2135                              <1> 	
  2136 00002325 61                  <1> 	popa
  2137 00002326 C3                  <1> 	ret
  2138                              <1> 
  2139 00002327 20DCDFDB            <1> 	.chars		db 32, 220, 223, 219
  2140                              <1> 	
  2141                              <1> ; ------------------------------------------------------------------
  2142                              <1> ; os_option_menu -- Show a menu with a list of options
  2143                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated)
  2144                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
  2145                              <1> 
  2146                              <1> os_option_menu:
  2147 0000232B 60                  <1> 	pusha
  2148 0000232C 2E803EEFDE00        <1> 	cmp byte [cs:CONFIG_MENU_DIMMING], 0	; "Blur" the background if requested
  2149 00002332 741C                <1> 	je .skip
  2150                              <1> 	
  2151                              <1> 	mov16 dx, 0, 1
    35 00002334 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2152                              <1> 
  2153 00002337 E81EF4              <1> 	call os_move_cursor
  2154                              <1> 	
  2155 0000233A B408                <1> 	mov ah, 08h
  2156                              <1> 	clr bh
    31 0000233C 30FF                <2>  xor %1, %1
  2157 0000233E CD10                <1> 	int 10h				; Get the character's attribute (X = 0, Y = 1)
  2158                              <1> 	
  2159 00002340 80E4F0              <1> 	and ah, 0F0h		; Keep only the background, set foreground to 0
  2160                              <1> 	
  2161 00002343 0FB6DC              <1> 	movzx bx, ah
  2162 00002346 B8B109              <1> 	mov ax, 09B1h
  2163 00002349 B93007              <1> 	mov cx, 1840
  2164 0000234C CD10                <1> 	int 10h
  2165                              <1> 	
  2166 0000234E 61                  <1> 	popa
  2167 0000234F 60                  <1> 	pusha
  2168                              <1> 
  2169                              <1> .skip:
  2170 00002350 E87806              <1> 	call os_string_callback_tokenizer
  2171                              <1> 
  2172 00002353 88CC                <1> 	mov ah, cl
  2173                              <1> 
  2174 00002355 83F914              <1> 	cmp cx, 20			; Would the list overflow?
  2175 00002358 7E02                <1> 	jle .good
  2176                              <1> 
  2177 0000235A B414                <1> 	mov ah, 20			; If so, shrink it to fit on the screen
  2178                              <1> 
  2179                              <1> .good:
  2180                              <1> 	mov16 dx, 1, 1
    35 0000235C BA0101              <2>  mov %1, (%2 + %3 * 256)
  2181 0000235F 2E8A1EF0DE          <1> 	mov bl, [cs:CONFIG_MENU_BG_COLOR]
  2182                              <1> 	clr di
    31 00002364 31FF                <2>  xor %1, %1
  2183 00002366 E957F8              <1> 	jmp os_select_list.no_pusha
  2184                              <1> 
  2185                              <1> ; ------------------------------------------------------------------
  2186                              <1> ; os_print_clock -- Prints the time/date/speaker status in the
  2187                              <1> ; top right corner of the screen
  2188                              <1> ; IN/OUT: None, registers preserved
  2189                              <1> 
  2190                              <1> os_print_clock:
  2191 00002369 60                  <1> 	pusha
  2192 0000236A 1E                  <1> 	push ds
  2193 0000236B 06                  <1> 	push es
  2194                              <1> 	movs ds, cs
    39 0000236C 0E                  <2>  push %2
    40 0000236D 1F                  <2>  pop %1
  2195                              <1> 	movs es, cs
    39 0000236E 0E                  <2>  push %2
    40 0000236F 07                  <2>  pop %1
  2196                              <1> 
  2197 00002370 E8EEF3              <1> 	call os_get_cursor_pos
  2198 00002373 52                  <1> 	push dx
  2199                              <1> 	
  2200 00002374 BB[A223]            <1> 	mov bx, .tmp_buffer
  2201 00002377 E8A505              <1> 	call os_get_time_string
  2202                              <1> 
  2203 0000237A BA3F00              <1> 	mov dx, 63			; Display time
  2204 0000237D E8D8F3              <1> 	call os_move_cursor
  2205 00002380 89DE                <1> 	mov si, bx
  2206 00002382 E865F3              <1> 	call os_print_string
  2207                              <1> 
  2208 00002385 BB[A223]            <1> 	mov bx, .tmp_buffer
  2209 00002388 E8DF05              <1> 	call os_get_date_string
  2210                              <1> 
  2211 0000238B E86EFC              <1> 	call os_print_space
  2212 0000238E 89DE                <1> 	mov si, bx
  2213 00002390 E857F3              <1> 	call os_print_string
  2214                              <1> 	
  2215 00002393 B017                <1> 	mov al, 17h
  2216 00002395 2A06[E023]          <1> 	sub al, [speaker_unmuted]
  2217 00002399 E837F3              <1> 	call os_putchar
  2218                              <1> 
  2219 0000239C 5A                  <1> 	pop dx
  2220                              <1> 
  2221 0000239D 07                  <1> 	pop es
  2222 0000239E 1F                  <1> 	pop ds
  2223 0000239F E9B7F3              <1> 	jmp os_move_cursor.no_pusha
  2224                              <1> 		
  2225 000023A2 00<rep Ch>          <1> 	.tmp_buffer		times 12 db 0
  2226                              <1> 
  2227                              <1> ; ==================================================================
   527                                  	%INCLUDE "features/sound.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Sound functions (PC speaker, YM3812)
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
     7                              <1> ; IN: AX = note frequency (in Hz)
     8                              <1> ; OUT: None, registers preserved
     9                              <1> 
    10                              <1> os_speaker_tone:
    11 000023AE 60                  <1> 	pusha
    12 000023AF 2E803E[E023]00      <1> 	cmp byte [cs:speaker_unmuted], 0
    13 000023B5 7425                <1> 	je .exit
    14                              <1> 
    15 000023B7 85C0                <1> 	test ax, ax
    16 000023B9 7421                <1> 	jz .exit
    17                              <1> 	
    18 000023BB E85200              <1> 	call os_speaker_off
    19 000023BE 89C1                <1> 	mov cx, ax			; Store note value for now
    20                              <1> 
    21 000023C0 B0B6                <1> 	mov al, 10110110b
    22 000023C2 E643                <1> 	out 43h, al
    23 000023C4 BA1200              <1> 	mov dx, 12h			; Set up frequency
    24 000023C7 B8DC34              <1> 	mov ax, 34DCh
    25 000023CA F7F1                <1> 	div cx
    26                              <1> 
    27 000023CC 2EA3[DE23]          <1> 	mov [cs:speaker_period], ax
    28                              <1> 
    29 000023D0 E642                <1> 	out 42h, al
    30 000023D2 88E0                <1> 	mov al, ah
    31 000023D4 E642                <1> 	out 42h, al
    32                              <1> 
    33 000023D6 E461                <1> 	in al, 61h			; Switch PC speaker on
    34 000023D8 0C03                <1> 	or al, 03h
    35 000023DA E661                <1> 	out 61h, al
    36                              <1> 
    37                              <1> .exit:
    38 000023DC 61                  <1> 	popa
    39 000023DD C3                  <1> 	ret
    40                              <1> 
    41 000023DE 0100                <1> 	speaker_period	dw 1
    42 000023E0 00                  <1> 	speaker_unmuted	db 0
    43                              <1> 
    44                              <1> ; ------------------------------------------------------------------
    45                              <1> ; os_speaker_raw_period -- Generate PC speaker tone (call os_speaker_off to turn off)
    46                              <1> ; IN: AX = note period (= 105000000 / 88 / freq)
    47                              <1> ; OUT: None, registers preserved
    48                              <1> 
    49                              <1> os_speaker_raw_period:
    50 000023E1 60                  <1> 	pusha
    51 000023E2 2E803E[E023]00      <1> 	cmp byte [cs:speaker_unmuted], 0
    52 000023E8 7416                <1> 	je .exit
    53                              <1> 
    54 000023EA 2EA3[DE23]          <1> 	mov [cs:speaker_period], ax
    55                              <1> 
    56 000023EE 50                  <1> 	push ax
    57 000023EF B0B6                <1> 	mov al, 10110110b
    58 000023F1 E643                <1> 	out 43h, al
    59 000023F3 58                  <1> 	pop ax
    60 000023F4 E642                <1> 	out 42h, al
    61 000023F6 88E0                <1> 	mov al, ah
    62 000023F8 E642                <1> 	out 42h, al
    63                              <1> 
    64 000023FA E461                <1> 	in al, 61h			; Switch PC speaker on
    65 000023FC 0C03                <1> 	or al, 03h
    66 000023FE E661                <1> 	out 61h, al
    67                              <1> 
    68                              <1> .exit:
    69 00002400 61                  <1> 	popa
    70 00002401 C3                  <1> 	ret
    71                              <1> 
    72                              <1> ; ------------------------------------------------------------------
    73                              <1> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
    74                              <1> ; IN: AX = note frequency, CX = length (in ticks)
    75                              <1> ; OUT: None, registers preserved
    76                              <1> 
    77                              <1> os_speaker_note_length:
    78 00002402 60                  <1> 	pusha
    79 00002403 E8A8FF              <1> 	call os_speaker_tone
    80                              <1> 	
    81 00002406 89C8                <1> 	mov ax, cx
    82 00002408 E81D22              <1> 	call os_pause
    83                              <1> 	
    84 0000240B E80200              <1> 	call os_speaker_off
    85 0000240E 61                  <1> 	popa
    86 0000240F C3                  <1> 	ret
    87                              <1> 
    88                              <1> ; ------------------------------------------------------------------
    89                              <1> ; os_speaker_off -- Turn off PC speaker
    90                              <1> ; IN/OUT: None, registers preserved
    91                              <1> 
    92                              <1> os_speaker_off:
    93 00002410 60                  <1> 	pusha
    94                              <1> 
    95 00002411 E461                <1> 	in al, 61h
    96 00002413 24FC                <1> 	and al, 0FCh
    97 00002415 E661                <1> 	out 61h, al
    98                              <1> 
    99 00002417 2E803E[E023]00      <1> 	cmp byte [cs:speaker_unmuted], 0
   100 0000241D 7407                <1> 	je .exit
   101                              <1> 
   102 0000241F 2EC706[DE23]0100    <1> 	mov word [cs:speaker_period], 1
   103                              <1> 
   104                              <1> .exit:
   105 00002426 61                  <1> 	popa
   106 00002427 C3                  <1> 	ret
   107                              <1> 
   108                              <1> ; ------------------------------------------------------------------
   109                              <1> ; os_speaker_muted -- Check if the PC speaker is muted
   110                              <1> ; OUT: ZF set if muted, clear if not
   111                              <1> 
   112                              <1> os_speaker_muted:
   113 00002428 2E803E[E023]00      <1> 	cmp byte [cs:speaker_unmuted], 0
   114 0000242E C3                  <1> 	ret
   115                              <1> 
   116                              <1> ; ------------------------------------------------------------------
   117                              <1> ; os_start_adlib -- Starts the selected Adlib driver
   118                              <1> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
   119                              <1> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
   120                              <1> ; Common prescaler values:
   121                              <1> ;		33 = ~1 kHz (1004.362 Hz)
   122                              <1> ;		663 = ~50 Hz (49.991 Hz)
   123                              <1> ;		1820 = ~18.2 Hz (18.211 Hz)
   124                              <1> ; OUT: None, registers preserved
   125                              <1> 
   126                              <1> os_start_adlib:
   127 0000242F 60                  <1> 	pusha
   128 00002430 2EC606[EC25]01      <1> 	mov byte [cs:adlib_running], 1
   129                              <1> 
   130 00002436 2E803EEEDE01        <1> 	cmp byte [cs:CONFIG_ADLIB_DRIVER], CFG_ADLIB_PWM_DRIVER
   131 0000243C 7D15                <1> 	jge .pcspk
   132                              <1> 	
   133                              <1> 	clr ax
    31 0000243E 31C0                <2>  xor %1, %1
   134                              <1> 	
   135                              <1> .loop:
   136 00002440 E8A000              <1> 	call int_adlib_regwrite
   137 00002443 FEC4                <1> 	inc ah
   138 00002445 75F9                <1> 	jnz .loop
   139                              <1> 	
   140 00002447 B82400              <1> 	mov ax, 36
   141 0000244A F7E1                <1> 	mul cx
   142                              <1> 	
   143 0000244C 89C1                <1> 	mov cx, ax
   144 0000244E E8E421              <1> 	call os_attach_app_timer
   145                              <1> 	
   146 00002451 61                  <1> 	popa
   147 00002452 C3                  <1> 	ret
   148                              <1> 	
   149                              <1> .pcspk:
   150 00002453 B82400              <1> 	mov ax, 36
   151 00002456 F6F3                <1> 	div bl
   152                              <1> 	
   153 00002458 2EA2[8E26]          <1> 	mov [cs:pwm_channel_amplitude], al
   154                              <1> 
   155 0000245C 2E8936[8526]        <1> 	mov [cs:pwm_callback], si
   156 00002461 2E8C1E[8726]        <1> 	mov [cs:pwm_callback_seg], ds
   157 00002466 2E890E[8926]        <1> 	mov [cs:pwm_callback_ctr], cx
   158 0000246B 2E890E[8B26]        <1> 	mov [cs:pwm_callback_ctr_def], cx
   159                              <1> 
   160                              <1> 	; Set up the PC speaker
   161 00002470 E461                <1> 	in al, 0x61
   162 00002472 0C03                <1> 	or al, 3
   163 00002474 E661                <1> 	out 0x61, al
   164                              <1> 
   165                              <1> 	; Enable the callback
   166 00002476 BE[ED25]            <1> 	mov si, pwm_handler
   167 00002479 8CCF                <1> 	mov di, cs
   168 0000247B B11C                <1> 	mov cl, 01Ch
   169 0000247D E88621              <1> 	call os_modify_int_handler
   170                              <1> 
   171 00002480 B92400              <1> 	mov cx, 36
   172 00002483 E8E121              <1> 	call os_set_timer_speed
   173                              <1> 	
   174 00002486 61                  <1> 	popa
   175 00002487 C3                  <1> 	ret
   176                              <1> 	
   177                              <1> ; ------------------------------------------------------------------
   178                              <1> ; os_stop_adlib -- Stops the Adlib driver
   179                              <1> ; IN/OUT: None, registers preserved
   180                              <1> 
   181                              <1> os_stop_adlib:
   182 00002488 60                  <1> 	pusha
   183 00002489 E8C621              <1> 	call os_return_app_timer
   184                              <1> 
   185 0000248C 2E803EEEDE01        <1> 	cmp byte [cs:CONFIG_ADLIB_DRIVER], CFG_ADLIB_PWM_DRIVER
   186 00002492 7D1C                <1> 	jge .pcspk
   187                              <1> 	
   188                              <1> 	clr ah
    31 00002494 30E4                <2>  xor %1, %1
   189                              <1> 	
   190                              <1> .loop:
   191 00002496 0FB6DC              <1> 	movzx bx, ah
   192 00002499 C1EB05              <1> 	shr bx, 5
   193 0000249C 2E8A87[C224]        <1> 	mov al, [cs:adlib_clear_regs + bx]
   194                              <1> 
   195 000024A1 E83F00              <1> 	call int_adlib_regwrite
   196                              <1> 	
   197 000024A4 FEC4                <1> 	inc ah
   198 000024A6 75EE                <1> 	jnz .loop
   199                              <1> 	
   200 000024A8 2EC606[EC25]00      <1> 	mov byte [cs:adlib_running], 0
   201 000024AE 61                  <1> 	popa
   202 000024AF C3                  <1> 	ret
   203                              <1> 	
   204                              <1> .pcspk:
   205                              <1> 	; Turn off the PC speaker
   206 000024B0 E461                <1> 	in al, 0x61
   207 000024B2 24FC                <1> 	and al, 0xfc
   208 000024B4 E661                <1> 	out 0x61, al
   209                              <1> 
   210                              <1> 	; Turn off all of the channels
   211 000024B6 B91200              <1> 	mov cx, 18		; Not only nuke pwm_freq, but also pwm_cntr!
   212 000024B9 BF[6026]            <1> 	mov di, pwm_freq
   213                              <1> 	clr ax
    31 000024BC 31C0                <2>  xor %1, %1
   214 000024BE F3AB                <1> 	rep stosw
   215                              <1> 	
   216 000024C0 61                  <1> 	popa
   217 000024C1 C3                  <1> 	ret
   218                              <1> 	
   219                              <1> 	; Registers:    	   0x00  0x20  0x40  0x60  0x80  0xA0  0xC0  0xE0
   220 000024C2 00003FFFFF000000    <1> 	adlib_clear_regs	db 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00, 0x00
   221                              <1> 	
   222                              <1> ; ------------------------------------------------------------------
   223                              <1> ; os_adlib_regwrite -- Write to a YM3812 register
   224                              <1> ; IN: AH/AL - register address/value to write
   225                              <1> 
   226                              <1> os_adlib_regwrite:
   227 000024CA 60                  <1> 	pusha
   228                              <1> 	
   229 000024CB 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
   230 000024CE 6488870005          <1> 	mov [fs:ADLIB_BUFFER + bx], al
   231                              <1> 	
   232 000024D3 E80D00              <1> 	call int_adlib_regwrite
   233                              <1> 	
   234 000024D6 61                  <1> 	popa
   235 000024D7 C3                  <1> 	ret
   236                              <1> 	
   237                              <1> ; ------------------------------------------------------------------
   238                              <1> ; os_adlib_regread -- Read from a YM3812 register
   239                              <1> ; IN: AH - register address
   240                              <1> ; OUT: AL - value
   241                              <1> 
   242                              <1> os_adlib_regread:
   243 000024D8 53                  <1> 	push bx
   244                              <1> 	
   245 000024D9 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
   246 000024DC 648A870005          <1> 	mov al, [fs:ADLIB_BUFFER + bx]
   247                              <1> 	
   248 000024E1 5B                  <1> 	pop bx
   249 000024E2 C3                  <1> 	ret
   250                              <1> 	
   251                              <1> ; ------------------------------------------------------------------
   252                              <1> ; int_adlib_regwrite -- Internal kernel function - not available to user programs
   253                              <1> ; IN: AH/AL - register address/value to write
   254                              <1> ; OUT: None, registers preserved
   255                              <1> 
   256                              <1> int_adlib_regwrite:
   257 000024E3 60                  <1> 	pusha
   258                              <1> 
   259 000024E4 2E803EEEDE01        <1> 	cmp byte [cs:CONFIG_ADLIB_DRIVER], CFG_ADLIB_PWM_DRIVER
   260 000024EA 7D22                <1> 	jge .pcspk
   261                              <1> 
   262 000024EC 2E803E[EC25]00      <1> 	cmp byte [cs:adlib_running], 0
   263 000024F2 7418                <1> 	je .no_write
   264                              <1> 
   265 000024F4 BA8803              <1> 	mov dx, 388h
   266 000024F7 50                  <1> 	push ax
   267 000024F8 88E0                <1> 	mov al, ah
   268 000024FA EE                  <1> 	out dx, al
   269                              <1> 
   270 000024FB EC                  <1> 	in al, dx
   271 000024FC EC                  <1> 	in al, dx
   272 000024FD EC                  <1> 	in al, dx
   273 000024FE EC                  <1> 	in al, dx
   274 000024FF EC                  <1> 	in al, dx
   275 00002500 EC                  <1> 	in al, dx
   276                              <1> 	
   277 00002501 58                  <1> 	pop ax
   278 00002502 42                  <1> 	inc dx
   279 00002503 EE                  <1> 	out dx, al
   280                              <1> 
   281 00002504 4A                  <1> 	dec	dx
   282 00002505 B422                <1> 	mov	ah, 22h
   283                              <1> 
   284                              <1> .wait:
   285 00002507 EC                  <1> 	in al,dx
   286 00002508 FECC                <1> 	dec ah
   287 0000250A 75FB                <1> 	jnz .wait
   288                              <1> 	
   289                              <1> .no_write:
   290 0000250C 61                  <1> 	popa
   291 0000250D C3                  <1> 	ret
   292                              <1> 
   293                              <1> .pcspk:
   294 0000250E 80FCA0              <1> 	cmp ah, 0A0h
   295 00002511 7CF9                <1> 	jl .no_write
   296                              <1> 
   297 00002513 80FCB8              <1> 	cmp ah, 0B8h
   298 00002516 7FF4                <1> 	jg .no_write
   299                              <1> 
   300 00002518 80E40F              <1> 	and ah, 0Fh
   301 0000251B 0FB6DC              <1> 	movzx bx, ah
   302                              <1> 	
   303 0000251E 648A87A005          <1> 	mov al, [fs:ADLIB_BUFFER + 0A0h + bx]
   304 00002523 648AA7B005          <1> 	mov ah, [fs:ADLIB_BUFFER + 0B0h + bx]
   305                              <1> 	
   306 00002528 F6C420              <1> 	test ah, 20h
   307 0000252B 7439                <1> 	jz .pcspk_clear
   308                              <1> 	
   309 0000252D 88E2                <1> 	mov dl, ah		; Get the block number
   310 0000252F C0EA02              <1> 	shr dl, 2
   311 00002532 80E207              <1> 	and dl, 7
   312                              <1> 	
   313 00002535 25FF03              <1> 	and ax, 3FFh	; Get the FNum
   314                              <1> 	
   315                              <1> 	; WARNING! Due to the 16-bit integer limit (for speed), the maximum is block = 7, FNum = 511.
   316                              <1> 	; Quick and dirty formula: freq = (fnum << block) / 21
   317                              <1> 
   318 00002538 88D1                <1> 	mov cl, dl
   319 0000253A D3E0                <1> 	shl ax, cl
   320                              <1> 
   321 0000253C 53                  <1> 	push bx
   322                              <1> 	
   323 0000253D 31D2                <1> 	xor dx, dx
   324 0000253F BB1500              <1> 	mov bx, 21
   325 00002542 F7F3                <1> 	div bx						; Calculate the frequency
   326                              <1> 
   327 00002544 5B                  <1> 	pop bx
   328                              <1> 
   329 00002545 53                  <1> 	push bx						; Apply the frequency multiplier
   330                              <1> 	clr bh
    31 00002546 30FF                <2>  xor %1, %1
   331 00002548 2E8A9F[8125]        <1> 	mov bl, [cs:adlib_fmul_registers + bx]
   332 0000254D 648A9F0005          <1> 	mov bl, [fs:ADLIB_BUFFER + bx]
   333 00002552 80E30F              <1> 	and bl, 0Fh
   334 00002555 2E8A9F[7125]        <1> 	mov bl, [cs:adlib_fmul_values + bx]
   335                              <1> 	
   336 0000255A F7E3                <1> 	mul bx
   337 0000255C 5B                  <1> 	pop bx
   338                              <1> 	
   339 0000255D D1E3                <1> 	shl bx, 1		; Words
   340 0000255F 2E8987[6026]        <1> 	mov word [cs:pwm_freq + bx], ax
   341                              <1> 
   342 00002564 61                  <1> 	popa
   343 00002565 C3                  <1> 	ret
   344                              <1> 	
   345                              <1> .pcspk_clear:
   346 00002566 D1E3                <1> 	shl bx, 1		; Words
   347 00002568 2EC787[6026]0000    <1> 	mov word [cs:pwm_freq + bx], 0
   348                              <1> 	
   349 0000256F 61                  <1> 	popa
   350 00002570 C3                  <1> 	ret
   351                              <1> 	
   352 00002571 01020406080A0C0E10- <1> 	adlib_fmul_values		db 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 20, 24, 24, 30, 30
   352 0000257A 12141418181E1E      <1>
   353 00002581 2324252B2C2D333435  <1> 	adlib_fmul_registers	db 23h, 24h, 25h, 2Bh, 2Ch, 2Dh, 33h, 34h, 35h
   354                              <1> 	
   355                              <1> ; ------------------------------------------------------------------
   356                              <1> ; os_adlib_mute -- Mute the YM3812's current state
   357                              <1> ; IN/OUT: None
   358                              <1> 
   359                              <1> os_adlib_mute:
   360 0000258A 60                  <1> 	pusha
   361 0000258B 1E                  <1> 	push ds
   362                              <1> 	movs ds, cs
    39 0000258C 0E                  <2>  push %2
    40 0000258D 1F                  <2>  pop %1
   363                              <1> 
   364 0000258E 803EEEDE01          <1> 	cmp byte [CONFIG_ADLIB_DRIVER], CFG_ADLIB_PWM_DRIVER
   365 00002593 7D16                <1> 	jge .pcspk
   366                              <1> 	
   367 00002595 BE[DA25]            <1> 	mov si, adlib_volume_registers
   368 00002598 B91200              <1> 	mov cx, 18
   369                              <1> 	
   370                              <1> .loop:
   371 0000259B AC                  <1> 	lodsb
   372 0000259C 88C4                <1> 	mov ah, al
   373                              <1> 	
   374 0000259E E837FF              <1> 	call os_adlib_regread
   375 000025A1 0C3F                <1> 	or al, 3Fh
   376 000025A3 E83DFF              <1> 	call int_adlib_regwrite
   377                              <1> 	
   378 000025A6 E2F3                <1> 	loop .loop
   379                              <1> 	
   380 000025A8 1F                  <1> 	pop ds
   381 000025A9 61                  <1> 	popa
   382 000025AA C3                  <1> 	ret
   383                              <1> 
   384                              <1> .pcspk:
   385 000025AB C606[8426]01        <1> 	mov byte [pwm_muted], 1
   386 000025B0 1F                  <1> 	pop ds
   387 000025B1 61                  <1> 	popa
   388 000025B2 C3                  <1> 	ret
   389                              <1> 	
   390                              <1> ; ------------------------------------------------------------------
   391                              <1> ; os_adlib_unmute -- Unmute the YM3812's current state
   392                              <1> ; IN/OUT: None
   393                              <1> 
   394                              <1> os_adlib_unmute:
   395 000025B3 60                  <1> 	pusha
   396 000025B4 1E                  <1> 	push ds
   397                              <1> 	movs ds, cs
    39 000025B5 0E                  <2>  push %2
    40 000025B6 1F                  <2>  pop %1
   398                              <1> 
   399 000025B7 803EEEDE01          <1> 	cmp byte [CONFIG_ADLIB_DRIVER], CFG_ADLIB_PWM_DRIVER
   400 000025BC 7D14                <1> 	jge .pcspk
   401                              <1> 	
   402 000025BE BE[DA25]            <1> 	mov si, adlib_volume_registers
   403 000025C1 B91200              <1> 	mov cx, 18
   404                              <1> 	
   405                              <1> .loop:
   406 000025C4 AC                  <1> 	lodsb
   407 000025C5 88C4                <1> 	mov ah, al
   408                              <1> 	
   409 000025C7 E80EFF              <1> 	call os_adlib_regread
   410 000025CA E816FF              <1> 	call int_adlib_regwrite
   411                              <1> 	
   412 000025CD E2F5                <1> 	loop .loop
   413                              <1> 
   414 000025CF 1F                  <1> 	pop ds
   415 000025D0 61                  <1> 	popa
   416 000025D1 C3                  <1> 	ret
   417                              <1> 	
   418                              <1> .pcspk:
   419 000025D2 C606[8426]00        <1> 	mov byte [pwm_muted], 0
   420 000025D7 1F                  <1> 	pop ds
   421 000025D8 61                  <1> 	popa
   422 000025D9 C3                  <1> 	ret
   423                              <1> 
   424 000025DA 40414243444548494A- <1> 	adlib_volume_registers	db 40h, 41h, 42h, 43h, 44h, 45h, 48h, 49h, 4Ah, 4Bh, 4Ch, 4Dh, 50h, 51h, 52h, 53h, 54h, 55h
   424 000025E3 4B4C4D505152535455  <1>
   425 000025EC 00                  <1> 	adlib_running			db 0
   426                              <1> 
   427                              <1> ; ------------------------------------------------------------------
   428                              <1> ; PWM DRIVER
   429                              <1> ; What is emulated: FNum, block number, carrier frequency multiplier
   430                              <1> ; What is NOT emulated: literally everything else - amplitude, ADSR, waveforms, modulator
   431                              <1> 
   432                              <1> pwm_handler:
   433 000025ED FA                  <1> 	cli
   434 000025EE 60                  <1> 	pusha
   435 000025EF 1E                  <1> 	push ds
   436                              <1> 	
   437 000025F0 8CC8                <1> 	mov ax, cs
   438 000025F2 8ED8                <1> 	mov ds, ax
   439                              <1> 	
   440 000025F4 803E[8426]01        <1> 	cmp byte [pwm_muted], 1
   441 000025F9 744B                <1> 	je .no_spk
   442                              <1> 
   443                              <1> 	; Send the PWM value to the PC speaker
   444 000025FB B0B0                <1> 	mov al, 10110000b
   445 000025FD E643                <1> 	out 0x43, al
   446 000025FF A0[8D26]            <1> 	mov al, [pwm_val]
   447 00002602 E642                <1> 	out 0x42, al
   448                              <1> 	clr al
    31 00002604 30C0                <2>  xor %1, %1
   449 00002606 E642                <1> 	out 0x42, al
   450                              <1> 
   451                              <1> 	; Calculate the next value
   452 00002608 B90900              <1> 	mov cx, 9
   453 0000260B BE[6026]            <1> 	mov si, pwm_freq
   454 0000260E BF[7026]            <1> 	mov di, pwm_cntr - 2
   455                              <1> 	clr bl
    31 00002611 30DB                <2>  xor %1, %1
   456                              <1> 	
   457 00002613 8A16[8E26]          <1> 	mov dl, [pwm_channel_amplitude]
   458                              <1> 	
   459 00002617 803EEEDE02          <1> 	cmp byte [CONFIG_ADLIB_DRIVER], CFG_ADLIB_PWM_LOUD_DRIVER
   460 0000261C 7512                <1> 	jne .handler_loop
   461                              <1> 	
   462                              <1> 	; Max volume mode, count the number of active channels
   463 0000261E 56                  <1> 	push si
   464 0000261F 51                  <1> 	push cx
   465                              <1> 	
   466                              <1> 	clr bx
    31 00002620 31DB                <2>  xor %1, %1
   467                              <1> 	
   468                              <1> .channel_count_loop:
   469 00002622 AD                  <1> 	lodsw
   470                              <1> 	
   471 00002623 85C0                <1> 	test ax, ax
   472 00002625 7401                <1> 	jz .channel_count_loop_no_inc
   473                              <1> 	
   474 00002627 43                  <1> 	inc bx
   475                              <1> 	
   476                              <1> .channel_count_loop_no_inc:
   477 00002628 E2F8                <1> 	loop .channel_count_loop
   478                              <1> 	
   479 0000262A 59                  <1> 	pop cx
   480 0000262B 5E                  <1> 	pop si
   481                              <1> 	
   482 0000262C 8A97[8F26]          <1> 	mov dl, [pwm_fixed_amplitudes + bx]
   483                              <1> 
   484                              <1> 	; Add all of the channels together
   485                              <1> .handler_loop:
   486 00002630 AD                  <1> 	lodsw
   487                              <1> 	
   488 00002631 85C0                <1> 	test ax, ax
   489 00002633 7409                <1> 	jz .handler_loop_no_inc
   490                              <1> 	
   491 00002635 83C702              <1> 	add di, 2
   492 00002638 0105                <1> 	add [di], ax
   493                              <1> 	
   494 0000263A 7902                <1> 	jns .handler_loop_no_inc
   495                              <1> 	
   496 0000263C 00D3                <1> 	add	bl, dl
   497                              <1> 
   498                              <1> .handler_loop_no_inc:
   499 0000263E E2F0                <1> 	loop .handler_loop
   500                              <1> 	
   501 00002640 FEC3                <1> 	inc bl
   502 00002642 881E[8D26]          <1> 	mov [pwm_val], bl
   503                              <1> 	
   504                              <1> .no_spk:
   505                              <1> 	; Have we reached the callback value?	
   506 00002646 FF0E[8926]          <1> 	dec word [pwm_callback_ctr]
   507 0000264A 7511                <1> 	jnz .exit
   508                              <1> 
   509                              <1> 	; Yes, reset it
   510 0000264C A1[8B26]            <1> 	mov ax, [pwm_callback_ctr_def]
   511 0000264F A3[8926]            <1> 	mov [pwm_callback_ctr], ax
   512                              <1> 	
   513                              <1> 	; Call the callback if it is set
   514 00002652 833E[8526]00        <1> 	cmp word [pwm_callback], 0
   515 00002657 7404                <1> 	je .exit
   516                              <1> 
   517 00002659 FF1E[8526]          <1> 	call far [pwm_callback]
   518                              <1> 	
   519                              <1> .exit:
   520 0000265D 1F                  <1> 	pop ds
   521 0000265E 61                  <1> 	popa
   522 0000265F CF                  <1> 	iret
   523                              <1> 
   524 00002660 0000<rep 9h>        <1> 	pwm_freq				times 9 dw 0
   525 00002672 0000<rep 9h>        <1> 	pwm_cntr				times 9 dw 0
   526 00002684 00                  <1> 	pwm_muted				db 0
   527 00002685 0000                <1> 	pwm_callback			dw 0
   528 00002687 0000                <1> 	pwm_callback_seg		dw 0
   529 00002689 0000                <1> 	pwm_callback_ctr		dw 0
   530 0000268B 0000                <1> 	pwm_callback_ctr_def	dw 0
   531 0000268D 00                  <1> 	pwm_val					db 0
   532 0000268E 00                  <1> 	pwm_channel_amplitude	db 0
   533 0000268F 0024120C0907060504- <1> 	pwm_fixed_amplitudes	db 0, 36, 18, 12, 9, 7, 6, 5, 4, 4
   533 00002698 04                  <1>
   534                              <1> 	
   535                              <1> ; ------------------------------------------------------------------
   536                              <1> ; os_adlib_calcfreq -- Play a frequency
   537                              <1> ; IN: AX - frequency, CL = channel
   538                              <1> ; OUT: None, registers preserved
   539                              <1> 
   540                              <1> os_adlib_calcfreq:
   541 00002699 6660                <1> 	pushad
   542                              <1> 
   543 0000269B 2E803EEEDE01        <1> 	cmp byte [cs:CONFIG_ADLIB_DRIVER], CFG_ADLIB_PWM_DRIVER
   544 000026A1 7D56                <1> 	jge .pcspk
   545                              <1> 
   546 000026A3 2E880E[0827]        <1> 	mov [cs:.channel], cl
   547                              <1> 	
   548 000026A8 660FB7C0            <1> 	movzx eax, ax
   549                              <1> 	clr cl			; Block number
    31 000026AC 30C9                <2>  xor %1, %1
   550                              <1> 	
   551 000026AE 6650                <1> 	push eax
   552                              <1> 
   553                              <1> .block_loop:		; f-num = freq * 2^(20 - block) / 49716
   554 000026B0 6658                <1> 	pop eax
   555 000026B2 6650                <1> 	push eax
   556                              <1> 	
   557 000026B4 B314                <1> 	mov bl, 20
   558 000026B6 28CB                <1> 	sub bl, cl
   559                              <1> 	
   560 000026B8 51                  <1> 	push cx
   561 000026B9 88D9                <1> 	mov cl, bl
   562 000026BB 66D3E0              <1> 	shl eax, cl
   563 000026BE 59                  <1> 	pop cx
   564                              <1> 
   565                              <1> 	clr edx
    31 000026BF 6631D2              <2>  xor %1, %1
   566 000026C2 66BB34C20000        <1> 	mov ebx, 49716	; Divide by the sample rate
   567 000026C8 66F7F3              <1> 	div ebx
   568                              <1> 
   569 000026CB FEC1                <1> 	inc cl
   570                              <1> 	
   571 000026CD 3D0004              <1> 	cmp ax, 1024	; Is the result too large?
   572 000026D0 7DDE                <1> 	jge .block_loop
   573                              <1> 	
   574 000026D2 FEC9                <1> 	dec cl
   575                              <1> 	
   576 000026D4 C0E102              <1> 	shl cl, 2		; Write the block number
   577 000026D7 00CC                <1> 	add ah, cl
   578                              <1> 
   579 000026D9 80CC20              <1> 	or ah, 20h		; Note on
   580                              <1> 	
   581 000026DC 50                  <1> 	push ax
   582 000026DD B4A0                <1> 	mov ah, 0A0h
   583 000026DF 2E0226[0827]        <1> 	add ah, [cs:.channel]
   584 000026E4 E8E3FD              <1> 	call os_adlib_regwrite
   585 000026E7 58                  <1> 	pop ax
   586                              <1> 	
   587 000026E8 88E0                <1> 	mov al, ah
   588 000026EA B4B0                <1> 	mov ah, 0B0h
   589 000026EC 2E0226[0827]        <1> 	add ah, [cs:.channel]
   590 000026F1 E8D6FD              <1> 	call os_adlib_regwrite
   591                              <1> 	
   592 000026F4 6658                <1> 	pop eax
   593 000026F6 6661                <1> 	popad
   594 000026F8 C3                  <1> 	ret
   595                              <1> 	
   596                              <1> .pcspk:
   597 000026F9 0FB6D9              <1> 	movzx bx, cl
   598 000026FC D1E3                <1> 	shl bx, 1
   599 000026FE D1E0                <1> 	shl ax, 1
   600 00002700 2E8987[6026]        <1> 	mov [cs:pwm_freq + bx], ax
   601 00002705 6661                <1> 	popad
   602 00002707 C3                  <1> 	ret
   603                              <1> 	
   604 00002708 00                  <1> 	.channel	db 0
   605                              <1> 	
   606                              <1> ; ------------------------------------------------------------------
   607                              <1> ; os_adlib_noteoff -- Turns off a note
   608                              <1> ; IN: CL = channel
   609                              <1> ; OUT: None, registers preserved
   610                              <1> 
   611                              <1> os_adlib_noteoff:
   612 00002709 2E803EEEDE01        <1> 	cmp byte [cs:CONFIG_ADLIB_DRIVER], CFG_ADLIB_PWM_DRIVER
   613 0000270F 7D0F                <1> 	jge .pcspk
   614                              <1> 	
   615 00002711 60                  <1> 	pusha
   616                              <1> 
   617 00002712 B4B0                <1> 	mov ah, 0B0h
   618 00002714 00CC                <1> 	add ah, cl
   619 00002716 E8BFFD              <1> 	call os_adlib_regread
   620                              <1> 	
   621 00002719 24DF                <1> 	and al, 11011111b
   622 0000271B E8ACFD              <1> 	call os_adlib_regwrite
   623                              <1> 	
   624 0000271E 61                  <1> 	popa
   625 0000271F C3                  <1> 	ret
   626                              <1> 	
   627                              <1> .pcspk:
   628 00002720 60                  <1> 	pusha
   629 00002721 0FB6D9              <1> 	movzx bx, cl
   630 00002724 D1E3                <1> 	shl bx, 1
   631 00002726 2EC787[6026]0000    <1> 	mov word [cs:pwm_freq + bx], 0
   632 0000272D 61                  <1> 	popa
   633 0000272E C3                  <1> 	ret	
   634                              <1> 	
   635                              <1> ; ==================================================================
   528                                  	%INCLUDE "features/string.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS String manipulation functions
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
     7                              <1> ; IN: DS:SI = Input string/Output string
     8                              <1> ; OUT: None, registers preserved
     9                              <1> 
    10                              <1> os_string_encrypt:
    11 0000272F 60                  <1> 	pusha
    12 00002730 06                  <1> 	push es
    13                              <1> 	movs es, ds
    39 00002731 1E                  <2>  push %2
    40 00002732 07                  <2>  pop %1
    14                              <1> 
    15 00002733 89F7                <1> 	mov di, si
    16                              <1> 
    17 00002735 89F0                <1> 	mov ax, si
    18 00002737 E83100              <1> 	call os_string_length
    19 0000273A C0E002              <1> 	shl al, 2
    20 0000273D 347B                <1> 	xor al, 123
    21                              <1> 	
    22 0000273F B17B                <1> 	mov cl, 123
    23 00002741 00C1                <1> 	add cl, al
    24 00002743 80F1DB              <1> 	xor cl, 219
    25                              <1> 	
    26                              <1> .loop:
    27 00002746 AC                  <1> 	lodsb
    28 00002747 84C0                <1> 	test al, al
    29 00002749 740A                <1> 	jz .exit
    30                              <1> 	
    31 0000274B 00C8                <1> 	add al, cl
    32 0000274D 34AA                <1> 	xor al, 10101010b
    33 0000274F AA                  <1> 	stosb
    34                              <1> 	
    35 00002750 80C14D              <1> 	add cl, 77
    36 00002753 EBF1                <1> 	jmp .loop
    37                              <1> 	
    38                              <1> .exit:
    39 00002755 07                  <1> 	pop es
    40 00002756 61                  <1> 	popa
    41 00002757 C3                  <1> 	ret
    42                              <1> 
    43                              <1> ; ------------------------------------------------------------------
    44                              <1> ; os_string_add -- Add a string on top of another string
    45                              <1> ; IN: DS:AX = Main string, DS:BX = Added string
    46                              <1> ; OUT: None, registers preserved
    47                              <1> 
    48                              <1> os_string_add:
    49 00002758 60                  <1> 	pusha
    50 00002759 06                  <1> 	push es
    51                              <1> 
    52 0000275A 1E                  <1> 	push ds
    53 0000275B 07                  <1> 	pop es
    54                              <1> 
    55 0000275C 50                  <1> 	push ax
    56 0000275D E80B00              <1> 	call os_string_length		; Get the length of the main string
    57 00002760 5F                  <1> 	pop di
    58 00002761 01C7                <1> 	add di, ax					; Add it to the pointer
    59 00002763 89DE                <1> 	mov si, bx
    60 00002765 E88800              <1>  	call os_string_copy			; Copy the string
    61                              <1> 
    62 00002768 07                  <1> 	pop es
    63 00002769 61                  <1>  	popa
    64 0000276A C3                  <1>  	ret
    65                              <1> 	
    66                              <1> ; ------------------------------------------------------------------
    67                              <1> ; os_string_length -- Return length of a string
    68                              <1> ; IN: DS:AX = string location
    69                              <1> ; OUT AX = length (other regs preserved)
    70                              <1> 
    71                              <1> os_string_length:
    72 0000276B 56                  <1> 	push si
    73 0000276C 51                  <1> 	push cx
    74                              <1> 
    75 0000276D 89C6                <1> 	mov si, ax			; Move location of string to SI
    76 0000276F B9FFFF              <1> 	mov cx, -1			; Counter
    77                              <1> 
    78                              <1> .more:
    79 00002772 41                  <1> 	inc cx				; If not, keep adding
    80                              <1> 
    81 00002773 AC                  <1> 	lodsb
    82 00002774 84C0                <1> 	test al, al			; Zero (end of string) yet?
    83 00002776 75FA                <1> 	jnz .more
    84                              <1> 
    85                              <1> .done:
    86 00002778 89C8                <1> 	mov ax, cx
    87                              <1> 
    88 0000277A 59                  <1> 	pop cx
    89 0000277B 5E                  <1> 	pop si
    90 0000277C C3                  <1> 	ret
    91                              <1> 
    92                              <1> 
    93                              <1> ; ------------------------------------------------------------------
    94                              <1> ; os_string_reverse -- Reverse the characters in a string
    95                              <1> ; IN: DS:SI = string location
    96                              <1> ; OUT: None, registers preserved
    97                              <1> 
    98                              <1> os_string_reverse:
    99 0000277D 60                  <1> 	pusha
   100                              <1> 
   101 0000277E 803C00              <1> 	cmp byte [si], 0		; Don't attempt to reverse empty string
   102 00002781 7418                <1> 	je .end
   103                              <1> 
   104 00002783 89F0                <1> 	mov ax, si
   105 00002785 E8E3FF              <1> 	call os_string_length
   106                              <1> 
   107 00002788 89F7                <1> 	mov di, si
   108 0000278A 01C7                <1> 	add di, ax
   109 0000278C 4F                  <1> 	dec di				; DI now points to last char in string
   110                              <1> 
   111                              <1> .loop:
   112 0000278D 8A04                <1> 	mov byte al, [si]		; Swap bytes
   113 0000278F 8A1D                <1> 	mov byte bl, [di]
   114                              <1> 
   115 00002791 881C                <1> 	mov byte [si], bl
   116 00002793 8805                <1> 	mov byte [di], al
   117                              <1> 
   118 00002795 46                  <1> 	inc si				; Move towards string centre
   119 00002796 4F                  <1> 	dec di
   120                              <1> 
   121 00002797 39F7                <1> 	cmp di, si			; Both reached the centre?
   122 00002799 77F2                <1> 	ja .loop
   123                              <1> 
   124                              <1> .end:
   125 0000279B 61                  <1> 	popa
   126 0000279C C3                  <1> 	ret
   127                              <1> 
   128                              <1> 
   129                              <1> ; ------------------------------------------------------------------
   130                              <1> ; os_find_char_in_string -- Find location of character in a string
   131                              <1> ; IN: DS:SI = string location, AL = character to find
   132                              <1> ; OUT: AX = location in string, or 0 if char not present
   133                              <1> 
   134                              <1> os_find_char_in_string:
   135 0000279D 51                  <1> 	push cx
   136 0000279E 56                  <1> 	push si
   137                              <1> 
   138 0000279F B90100              <1> 	mov cx, 1			; Counter -- start at first char (we count
   139                              <1> 						; from 1 in chars here, so that we can
   140                              <1> 						; return 0 if the source char isn't found)
   141                              <1> 
   142                              <1> .more:
   143 000027A2 3804                <1> 	cmp byte [si], al
   144 000027A4 740B                <1> 	je .done
   145 000027A6 803C00              <1> 	cmp byte [si], 0
   146 000027A9 7404                <1> 	je .notfound
   147 000027AB 46                  <1> 	inc si
   148 000027AC 41                  <1> 	inc cx
   149 000027AD EBF3                <1> 	jmp .more
   150                              <1> 
   151                              <1> .notfound:
   152                              <1> 	clr cx
    31 000027AF 31C9                <2>  xor %1, %1
   153                              <1> 
   154                              <1> .done:
   155 000027B1 89C8                <1> 	mov ax, cx
   156 000027B3 5E                  <1> 	pop si
   157 000027B4 59                  <1> 	pop cx
   158 000027B5 C3                  <1> 	ret
   159                              <1> 
   160                              <1> 
   161                              <1> ; ------------------------------------------------------------------
   162                              <1> ; os_string_uppercase -- Convert zero-terminated string to upper case
   163                              <1> ; IN: DS:AX = string location
   164                              <1> ; OUT: None, registers preserved
   165                              <1> 
   166                              <1> os_string_uppercase:
   167 000027B6 60                  <1> 	pusha
   168                              <1> 
   169 000027B7 89C6                <1> 	mov si, ax			; Use SI to access string
   170                              <1> 
   171                              <1> .more:
   172 000027B9 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
   173 000027BC 7413                <1> 	je .done			; If so, quit
   174                              <1> 
   175 000027BE 803C61              <1> 	cmp byte [si], 'a'		; In the lower case A to Z range?
   176 000027C1 720B                <1> 	jb .noatoz
   177 000027C3 803C7A              <1> 	cmp byte [si], 'z'
   178 000027C6 7706                <1> 	ja .noatoz
   179                              <1> 
   180 000027C8 802C20              <1> 	sub byte [si], 20h		; If so, convert input char to upper case
   181                              <1> 
   182 000027CB 46                  <1> 	inc si
   183 000027CC EBEB                <1> 	jmp .more
   184                              <1> 
   185                              <1> .noatoz:
   186 000027CE 46                  <1> 	inc si
   187 000027CF EBE8                <1> 	jmp .more
   188                              <1> 
   189                              <1> .done:
   190 000027D1 61                  <1> 	popa
   191 000027D2 C3                  <1> 	ret
   192                              <1> 
   193                              <1> 
   194                              <1> ; ------------------------------------------------------------------
   195                              <1> ; os_string_lowercase -- Convert zero-terminated string to lower case
   196                              <1> ; IN: DS:AX = string location
   197                              <1> ; OUT: None, registers preserved
   198                              <1> 
   199                              <1> os_string_lowercase:
   200 000027D3 60                  <1> 	pusha
   201                              <1> 
   202 000027D4 89C6                <1> 	mov si, ax			; Use SI to access string
   203                              <1> 
   204                              <1> .more:
   205 000027D6 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
   206 000027D9 7413                <1> 	je .done			; If so, quit
   207                              <1> 
   208 000027DB 803C41              <1> 	cmp byte [si], 'A'		; In the upper case A to Z range?
   209 000027DE 720B                <1> 	jb .noatoz
   210 000027E0 803C5A              <1> 	cmp byte [si], 'Z'
   211 000027E3 7706                <1> 	ja .noatoz
   212                              <1> 
   213 000027E5 800420              <1> 	add byte [si], 20h		; If so, convert input char to lower case
   214                              <1> 
   215 000027E8 46                  <1> 	inc si
   216 000027E9 EBEB                <1> 	jmp .more
   217                              <1> 
   218                              <1> .noatoz:
   219 000027EB 46                  <1> 	inc si
   220 000027EC EBE8                <1> 	jmp .more
   221                              <1> 
   222                              <1> .done:
   223 000027EE 61                  <1> 	popa
   224 000027EF C3                  <1> 	ret
   225                              <1> 
   226                              <1> 
   227                              <1> ; ------------------------------------------------------------------
   228                              <1> ; os_string_copy -- Copy one string into another
   229                              <1> ; IN: DS:SI = source, ES:DI = destination (programmer ensure sufficient room)
   230                              <1> ; OUT: None, registers preserved
   231                              <1> 
   232                              <1> os_string_copy:
   233 000027F0 60                  <1> 	pusha
   234                              <1> 
   235                              <1> .more:
   236 000027F1 AC                  <1> 	lodsb
   237 000027F2 AA                  <1> 	stosb
   238 000027F3 3C00                <1> 	cmp byte al, 0			; If source string is empty, quit out
   239 000027F5 75FA                <1> 	jne .more
   240 000027F7 61                  <1> 	popa
   241 000027F8 C3                  <1> 	ret
   242                              <1> 
   243                              <1> 
   244                              <1> ; ------------------------------------------------------------------
   245                              <1> ; os_string_join -- Join two strings into a third string
   246                              <1> ; IN: DS:AX = string one, DS:BX = string two, ES:CX = destination string
   247                              <1> ; OUT: None, registers preserved
   248                              <1> 
   249                              <1> os_string_join:
   250 000027F9 60                  <1> 	pusha
   251                              <1> 
   252 000027FA 89C6                <1> 	mov si, ax
   253 000027FC 89CF                <1> 	mov di, cx
   254 000027FE E8EFFF              <1> 	call os_string_copy
   255                              <1> 
   256 00002801 E867FF              <1> 	call os_string_length		; Get length of first string
   257                              <1> 
   258 00002804 01C1                <1> 	add cx, ax			; Position at end of first string
   259                              <1> 
   260 00002806 89DE                <1> 	mov si, bx			; Add second string onto it
   261 00002808 89CF                <1> 	mov di, cx
   262 0000280A E8E3FF              <1> 	call os_string_copy
   263                              <1> 
   264 0000280D 61                  <1> 	popa
   265 0000280E C3                  <1> 	ret
   266                              <1> 
   267                              <1> 
   268                              <1> ; ------------------------------------------------------------------
   269                              <1> ; os_string_chomp -- Strip leading and trailing spaces from a string
   270                              <1> ; IN: DS:AX = string location
   271                              <1> ; OUT: None, registers preserved
   272                              <1> 
   273                              <1> os_string_chomp:
   274 0000280F 60                  <1> 	pusha
   275                              <1> 
   276 00002810 89C2                <1> 	mov dx, ax			; Save string location
   277                              <1> 
   278 00002812 89C7                <1> 	mov di, ax			; Put location into DI
   279 00002814 31C9                <1> 	xor cx, cx			; Space counter
   280                              <1> 
   281                              <1> .keepcounting:				; Get number of leading spaces into BX
   282 00002816 803D20              <1> 	cmp byte [di], ' '
   283 00002819 7504                <1> 	jne .counted
   284 0000281B 41                  <1> 	inc cx
   285 0000281C 47                  <1> 	inc di
   286 0000281D EBF7                <1> 	jmp .keepcounting
   287                              <1> 
   288                              <1> .counted:
   289 0000281F 85C9                <1> 	test cx, cx			; No leading spaces?
   290 00002821 7410                <1> 	jz .finished_copy
   291                              <1> 
   292 00002823 89FE                <1> 	mov si, di			; Address of first non-space character
   293 00002825 89D7                <1> 	mov di, dx			; DI = original string start
   294                              <1> 
   295                              <1> .keep_copying:
   296 00002827 8A04                <1> 	mov al, [si]			; Copy SI into DI
   297 00002829 8805                <1> 	mov [di], al			; Including terminator
   298 0000282B 84C0                <1> 	test al, al
   299 0000282D 7404                <1> 	jz .finished_copy
   300 0000282F 46                  <1> 	inc si
   301 00002830 47                  <1> 	inc di
   302 00002831 EBF4                <1> 	jmp .keep_copying
   303                              <1> 
   304                              <1> .finished_copy:
   305 00002833 89D0                <1> 	mov ax, dx			; AX = original string start
   306                              <1> 
   307 00002835 E833FF              <1> 	call os_string_length
   308 00002838 85C0                <1> 	test ax, ax			; If empty or all blank, done, return 'null'
   309 0000283A 740F                <1> 	jz .done
   310                              <1> 
   311 0000283C 89D6                <1> 	mov si, dx
   312 0000283E 01C6                <1> 	add si, ax			; Move to end of string
   313                              <1> 
   314                              <1> .more:
   315 00002840 4E                  <1> 	dec si
   316 00002841 803C20              <1> 	cmp byte [si], ' '
   317 00002844 7505                <1> 	jne .done
   318 00002846 C60400              <1> 	mov byte [si], 0		; Fill end spaces with 0s
   319 00002849 EBF5                <1> 	jmp .more			; (First 0 will be the string terminator)
   320                              <1> 
   321                              <1> .done:
   322 0000284B 61                  <1> 	popa
   323 0000284C C3                  <1> 	ret
   324                              <1> 
   325                              <1> 
   326                              <1> ; ------------------------------------------------------------------
   327                              <1> ; os_string_compare -- See if two strings match
   328                              <1> ; IN: DS:SI = string one, DS:DI = string two
   329                              <1> ; OUT: carry set if same, clear if different
   330                              <1> 
   331                              <1> os_string_compare:
   332 0000284D 60                  <1> 	pusha
   333                              <1> 
   334                              <1> .more:
   335 0000284E 8A04                <1> 	mov al, [si]			; Retrieve string contents
   336 00002850 8A1D                <1> 	mov bl, [di]
   337                              <1> 
   338 00002852 38D8                <1> 	cmp al, bl			; Compare characters at current location
   339 00002854 7508                <1> 	jne .not_same
   340                              <1> 
   341 00002856 84C0                <1> 	test al, al			; End of first string? Must also be end of second
   342 00002858 7407                <1> 	jz .terminated
   343                              <1> 
   344 0000285A 46                  <1> 	inc si
   345 0000285B 47                  <1> 	inc di
   346 0000285C EBF0                <1> 	jmp .more
   347                              <1> 
   348                              <1> 
   349                              <1> .not_same:				; If unequal lengths with same beginning, the byte
   350 0000285E 61                  <1> 	popa				; comparison fails at shortest string terminator
   351 0000285F F8                  <1> 	clc				; Clear carry flag
   352 00002860 C3                  <1> 	ret
   353                              <1> 
   354                              <1> 
   355                              <1> .terminated:				; Both strings terminated at the same position
   356 00002861 61                  <1> 	popa
   357 00002862 F9                  <1> 	stc				; Set carry flag
   358 00002863 C3                  <1> 	ret
   359                              <1> 
   360                              <1> 
   361                              <1> ; ------------------------------------------------------------------
   362                              <1> ; os_string_parse -- Take string (eg "run foo bar baz") and return
   363                              <1> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
   364                              <1> ; IN: DS:SI = string
   365                              <1> ; OUT: AX, BX, CX, DX = individual strings
   366                              <1> 
   367                              <1> os_string_parse:
   368 00002864 56                  <1> 	push si
   369                              <1> 
   370 00002865 89F0                <1> 	mov ax, si			; AX = start of first string
   371                              <1> 
   372 00002867 31DB                <1> 	xor bx, bx			; By default, other strings start empty
   373 00002869 31C9                <1> 	xor cx, cx
   374 0000286B 31D2                <1> 	xor dx, dx
   375                              <1> 
   376 0000286D 50                  <1> 	push ax				; Save to retrieve at end
   377                              <1> 
   378                              <1> .loop1:
   379 0000286E AC                  <1> 	lodsb				; Get a byte
   380 0000286F 84C0                <1> 	test al, al			; End of string?
   381 00002871 742B                <1> 	jz .finish
   382 00002873 3C20                <1> 	cmp al, ' '			; A space?
   383 00002875 75F7                <1> 	jne .loop1
   384 00002877 4E                  <1> 	dec si
   385 00002878 C60400              <1> 	mov byte [si], 0		; If so, zero-terminate this bit of the string
   386                              <1> 
   387 0000287B 46                  <1> 	inc si				; Store start of next string in BX
   388 0000287C 89F3                <1> 	mov bx, si
   389                              <1> 
   390                              <1> .loop2:					; Repeat the above for CX and DX...
   391 0000287E AC                  <1> 	lodsb
   392 0000287F 84C0                <1> 	test al, al
   393 00002881 741B                <1> 	jz .finish
   394 00002883 3C20                <1> 	cmp al, ' '
   395 00002885 75F7                <1> 	jne .loop2
   396 00002887 4E                  <1> 	dec si
   397 00002888 C60400              <1> 	mov byte [si], 0
   398                              <1> 
   399 0000288B 46                  <1> 	inc si
   400 0000288C 89F1                <1> 	mov cx, si
   401                              <1> 
   402                              <1> .loop3:
   403 0000288E AC                  <1> 	lodsb
   404 0000288F 84C0                <1> 	test al, al
   405 00002891 740B                <1> 	jz .finish
   406 00002893 3C20                <1> 	cmp al, ' '
   407 00002895 75F7                <1> 	jne .loop3
   408 00002897 4E                  <1> 	dec si
   409 00002898 C60400              <1> 	mov byte [si], 0
   410                              <1> 
   411 0000289B 46                  <1> 	inc si
   412 0000289C 89F2                <1> 	mov dx, si
   413                              <1> 
   414                              <1> .finish:
   415 0000289E 58                  <1> 	pop ax
   416                              <1> 
   417 0000289F 5E                  <1> 	pop si
   418 000028A0 C3                  <1> 	ret
   419                              <1> 
   420                              <1> 
   421                              <1> ; ------------------------------------------------------------------
   422                              <1> ; os_string_to_int -- Convert decimal string to integer value
   423                              <1> ; IN: DS:SI = string location (max 5 chars, up to '65535')
   424                              <1> ; OUT: AX = number
   425                              <1> 
   426                              <1> os_string_to_int:
   427 000028A1 E9EF01              <1> 	jmp os_string_to_32int		; This function only exists for compatibility reasons
   428                              <1> 
   429                              <1> ; ------------------------------------------------------------------
   430                              <1> ; os_string_to_hex -- Convert hexadecimal string to integer value
   431                              <1> ; IN: DS:SI = string location (max 8 chars, up to 'FFFFFFFF')
   432                              <1> ; OUT: EAX = number
   433                              <1> 
   434                              <1> os_string_to_hex:
   435 000028A4 56                  <1> 	push si
   436 000028A5 51                  <1> 	push cx
   437                              <1> 	
   438 000028A6 89F0                <1> 	mov ax, si			; First, uppercase the string
   439 000028A8 E80BFF              <1> 	call os_string_uppercase
   440                              <1> 
   441 000028AB 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
   442                              <1> 	
   443                              <1> .loop:
   444 000028AE 6650                <1> 	push eax
   445 000028B0 AC                  <1> 	lodsb					; Load a byte from SI
   446 000028B1 88C1                <1> 	mov cl, al
   447 000028B3 6658                <1> 	pop eax
   448                              <1> 
   449 000028B5 80F930              <1> 	cmp cl, '0'				; Verify allowed range
   450 000028B8 721D                <1> 	jb .exit
   451                              <1> 
   452 000028BA 80F946              <1> 	cmp cl, 'F'
   453 000028BD 7718                <1> 	ja .exit
   454                              <1> 
   455 000028BF 80F939              <1> 	cmp cl, '9'
   456 000028C2 7608                <1> 	jbe .no_change
   457                              <1> 
   458 000028C4 80F941              <1> 	cmp cl, 'A'
   459 000028C7 720E                <1> 	jb .exit
   460                              <1> 
   461 000028C9 80E907              <1> 	sub cl, 7
   462                              <1> 	
   463                              <1> .no_change:
   464 000028CC 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
   465 000028CF 66C1E004            <1> 	shl eax, 4				; Multiply EAX by 16
   466 000028D3 00C8                <1> 	add al, cl				; Add the value to the integer
   467 000028D5 EBD7                <1> 	jmp .loop				; Loop again
   468                              <1> 	
   469                              <1> .exit:
   470 000028D7 59                  <1> 	pop cx
   471 000028D8 5E                  <1> 	pop si
   472 000028D9 C3                  <1> 	ret
   473                              <1> 	
   474                              <1> ; ------------------------------------------------------------------
   475                              <1> ; os_int_to_string -- Convert unsigned integer to string
   476                              <1> ; IN: AX = unsigned int
   477                              <1> ; OUT: DS:AX = string location
   478                              <1> 
   479                              <1> os_int_to_string:
   480 000028DA 60                  <1> 	pusha
   481                              <1> 	movs ds, cs
    39 000028DB 0E                  <2>  push %2
    40 000028DC 1F                  <2>  pop %1
   482                              <1> 
   483 000028DD BF[0129]            <1> 	mov di, .t			; Get our pointer ready
   484                              <1> 
   485                              <1> .ptr_rdy:
   486                              <1> 	clr cx
    31 000028E0 31C9                <2>  xor %1, %1
   487 000028E2 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
   488                              <1> 
   489                              <1> .push:
   490 000028E5 31D2                <1> 	xor dx, dx
   491 000028E7 F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
   492 000028E9 41                  <1> 	inc cx				; Increase pop loop counter
   493                              <1> 
   494 000028EA 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
   495                              <1> 
   496 000028EB 85C0                <1> 	test ax, ax			; Is quotient zero?
   497 000028ED 75F6                <1> 	jnz .push			; If not, loop again
   498                              <1> 
   499                              <1> .pop:
   500 000028EF 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
   501                              <1> 
   502 000028F0 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
   503 000028F3 8815                <1> 	mov [di], dl
   504                              <1> 	
   505 000028F5 47                  <1> 	inc di
   506 000028F6 49                  <1> 	dec cx
   507 000028F7 75F6                <1> 	jnz .pop
   508                              <1> 
   509 000028F9 C60500              <1> 	mov byte [di], 0	; Zero-terminate string
   510                              <1> 
   511 000028FC 61                  <1> 	popa
   512 000028FD B8[0129]            <1> 	mov ax, .t			; Return location of string
   513 00002900 C3                  <1> 	ret
   514                              <1> 
   515 00002901 00<rep Ch>          <1> 	.t times 12 db 0
   516                              <1> 
   517                              <1> 
   518                              <1> ; ------------------------------------------------------------------
   519                              <1> ; os_sint_to_string -- Convert signed integer to string
   520                              <1> ; IN: AX = signed int
   521                              <1> ; OUT: DS:AX = string location
   522                              <1> 
   523                              <1> os_sint_to_string:
   524 0000290D 60                  <1> 	pusha
   525                              <1> 	movs ds, cs
    39 0000290E 0E                  <2>  push %2
    40 0000290F 1F                  <2>  pop %1
   526                              <1> 
   527 00002910 BF[0129]            <1> 	mov di, os_int_to_string.t		; Get our pointer ready
   528                              <1> 
   529 00002913 85C0                <1> 	test ax, ax						; Find out if X > 0 or not, force a sign
   530 00002915 79C9                <1> 	jns os_int_to_string.ptr_rdy	; If positive, there's no problem
   531                              <1> 
   532 00002917 F7D8                <1> 	neg ax							; Make AX positive
   533 00002919 C6052D              <1> 	mov byte [di], '-'				; Add a minus sign to our string
   534 0000291C 47                  <1> 	inc di							; Update the index
   535                              <1> 
   536 0000291D EBC1                <1> 	jmp os_int_to_string.ptr_rdy	; Finish the conversion
   537                              <1> 
   538                              <1> ; ------------------------------------------------------------------
   539                              <1> ; os_get_time_string -- Get current time in a string (eg '10:25')
   540                              <1> ; IN: ES:BX = string location
   541                              <1> ; OUT: None, registers preserved
   542                              <1> 
   543                              <1> os_get_time_string:
   544 0000291F 60                  <1> 	pusha
   545 00002920 1E                  <1> 	push ds
   546                              <1> 	movs ds, cs
    39 00002921 0E                  <2>  push %2
    40 00002922 1F                  <2>  pop %1
   547                              <1> 
   548 00002923 89DF                <1> 	mov di, bx			; Location to place the string
   549                              <1> 
   550 00002925 B402                <1> 	mov ah, 02h			; Get the current time
   551 00002927 E85FEC              <1> 	call os_int_1Ah
   552                              <1> 	
   553 0000292A 723B                <1> 	jc .exit
   554                              <1> 
   555 0000292C 51                  <1> 	push cx	
   556                              <1> 
   557 0000292D 88E8                <1> 	mov al, ch
   558 0000292F E8A7E9              <1> 	call os_bcd_to_int
   559 00002932 83F80A              <1> 	cmp ax, 10
   560 00002935 7D05                <1> 	jge .hour_10
   561                              <1> 	
   562 00002937 50                  <1> 	push ax
   563 00002938 B030                <1> 	mov al, '0'
   564 0000293A AA                  <1> 	stosb
   565 0000293B 58                  <1> 	pop ax
   566                              <1> 	
   567                              <1> .hour_10:
   568 0000293C E89BFF              <1> 	call os_int_to_string
   569 0000293F 89C6                <1> 	mov si, ax
   570                              <1> 	
   571                              <1> .hour_loop:	
   572 00002941 AC                  <1> 	lodsb
   573 00002942 84C0                <1> 	test al, al
   574 00002944 7403                <1> 	jz .hour_loop_end
   575 00002946 AA                  <1> 	stosb
   576 00002947 EBF8                <1> 	jmp .hour_loop
   577                              <1> 	
   578                              <1> .hour_loop_end:
   579 00002949 B03A                <1> 	mov al, ':'			; Insert the time separator (or whatever it's called)
   580 0000294B AA                  <1> 	stosb
   581                              <1> 		
   582 0000294C 59                  <1> 	pop cx
   583 0000294D 88C8                <1> 	mov al, cl
   584 0000294F E887E9              <1> 	call os_bcd_to_int
   585 00002952 83F80A              <1> 	cmp ax, 10
   586 00002955 7D05                <1> 	jge .minute_10
   587                              <1> 	
   588 00002957 50                  <1> 	push ax
   589 00002958 B030                <1> 	mov al, '0'
   590 0000295A AA                  <1> 	stosb
   591 0000295B 58                  <1> 	pop ax
   592                              <1> 	
   593                              <1> .minute_10:
   594 0000295C E87BFF              <1> 	call os_int_to_string
   595 0000295F 89C6                <1> 	mov si, ax
   596                              <1> 		
   597                              <1> .minute_loop:	
   598 00002961 AC                  <1> 	lodsb
   599 00002962 AA                  <1> 	stosb
   600                              <1> 	
   601 00002963 84C0                <1> 	test al, al
   602 00002965 75FA                <1> 	jnz .minute_loop
   603                              <1> 
   604                              <1> .exit:
   605 00002967 1F                  <1> 	pop ds
   606 00002968 61                  <1> 	popa
   607 00002969 C3                  <1> 	ret
   608                              <1> 
   609                              <1> ; ------------------------------------------------------------------
   610                              <1> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
   611                              <1> ; IN: ES:BX = string location
   612                              <1> ; OUT: None, registers preserved
   613                              <1> 
   614                              <1> os_get_date_string:
   615 0000296A 60                  <1> 	pusha
   616 0000296B 1E                  <1> 	push ds
   617                              <1> 	movs ds, cs
    39 0000296C 0E                  <2>  push %2
    40 0000296D 1F                  <2>  pop %1
   618                              <1> 
   619 0000296E 89DF                <1> 	mov di, bx
   620                              <1> 	
   621 00002970 F8                  <1> 	clc				; For buggy BIOSes
   622 00002971 B404                <1> 	mov ah, 4			; Get date data from BIOS in BCD format
   623 00002973 E813EC              <1> 	call os_int_1Ah
   624 00002976 7306                <1> 	jnc .fmt1_day
   625                              <1> 
   626 00002978 F8                  <1> 	clc
   627 00002979 B404                <1> 	mov ah, 4			; BIOS was updating (~1 in 500 chance), so try again
   628 0000297B E80BEC              <1> 	call os_int_1Ah
   629                              <1> 
   630                              <1> .fmt1_day:
   631 0000297E 88D4                <1> 	mov ah, dl			; Day
   632 00002980 E81B00              <1> 	call .add_2digits
   633                              <1> 
   634 00002983 B02F                <1> 	mov al, '/'
   635 00002985 AA                  <1> 	stosb				; Day-month separator
   636                              <1> 
   637                              <1> .fmt1_month:
   638 00002986 88F4                <1> 	mov ah,	dh			; Month
   639 00002988 E81300              <1> 	call .add_2digits
   640                              <1> 
   641 0000298B B02F                <1> 	mov al, '/'
   642 0000298D AA                  <1> 	stosb
   643                              <1> 
   644                              <1> .fmt1_century:
   645 0000298E 88EC                <1> 	mov ah,	ch			; Century
   646 00002990 E80B00              <1> 	call .add_2digits
   647                              <1> 
   648                              <1> .fmt1_year:
   649 00002993 88CC                <1> 	mov ah, cl			; Year
   650 00002995 E80600              <1> 	call .add_2digits
   651                              <1> 
   652                              <1> 	clr al				; Terminate date string
    31 00002998 30C0                <2>  xor %1, %1
   653 0000299A AA                  <1> 	stosb
   654                              <1> 
   655 0000299B 1F                  <1> 	pop ds
   656 0000299C 61                  <1> 	popa
   657 0000299D C3                  <1> 	ret
   658                              <1> 
   659                              <1> .add_2digits:
   660 0000299E 88E0                <1> 	mov al, ah			; Convert AH to 2 ASCII digits
   661 000029A0 C0E804              <1> 	shr al, 4
   662 000029A3 E80800              <1> 	call .add_digit
   663 000029A6 88E0                <1> 	mov al, ah
   664 000029A8 240F                <1> 	and al, 0Fh
   665 000029AA E80100              <1> 	call .add_digit
   666 000029AD C3                  <1> 	ret
   667                              <1> 
   668                              <1> .add_digit:
   669 000029AE 0430                <1> 	add al, '0'			; Convert AL to ASCII
   670 000029B0 AA                  <1> 	stosb				; Put into string buffer
   671 000029B1 C3                  <1> 	ret
   672                              <1> 	
   673                              <1> 	
   674                              <1> ; ------------------------------------------------------------------
   675                              <1> ; os_string_tokenize -- Reads tokens separated by specified char from
   676                              <1> ; a string. Returns pointer to next token, or 0 if none left
   677                              <1> ; IN: AL = separator char, DS:SI = beginning
   678                              <1> ; OUT: DI = next token or 0 if none
   679                              <1> 
   680                              <1> os_string_tokenize:
   681 000029B2 56                  <1> 	push si
   682                              <1> 
   683                              <1> .next_char:
   684 000029B3 3804                <1> 	cmp byte [si], al
   685 000029B5 7408                <1> 	je .return_token
   686 000029B7 803C00              <1> 	cmp byte [si], 0
   687 000029BA 740B                <1> 	jz .no_more
   688 000029BC 46                  <1> 	inc si
   689 000029BD EBF4                <1> 	jmp .next_char
   690                              <1> 
   691                              <1> .return_token:
   692 000029BF C60400              <1> 	mov byte [si], 0
   693 000029C2 46                  <1> 	inc si
   694 000029C3 89F7                <1> 	mov di, si
   695 000029C5 5E                  <1> 	pop si
   696 000029C6 C3                  <1> 	ret
   697                              <1> 
   698                              <1> .no_more:
   699 000029C7 31FF                <1> 	xor di, di
   700 000029C9 5E                  <1> 	pop si
   701 000029CA C3                  <1> 	ret
   702                              <1> 
   703                              <1> ; ------------------------------------------------------------------
   704                              <1> ; os_string_callback_tokenizer -- Prints a token from string, requests are done by callback
   705                              <1> ; IN: DS:AX = comma-separated string
   706                              <1> ; OUT: AL = AH = max length of any token, CX = number of entries in the list,
   707                              <1> ;      DX:SI = callback location (if C clear, accepts CX as entry ID, prints out result)
   708                              <1> 
   709                              <1> os_string_callback_tokenizer:
   710                              <1> 	; Believe it or not, we do not need to preserve any regs here
   711                              <1> 
   712 000029CB 2E8C1E[5A2A]        <1> 	mov [cs:.strbasesgmt], ds
   713                              <1> 	
   714 000029D0 2EA3[5C2A]          <1> 	mov [cs:.strbaseptr], ax
   715 000029D4 2EA3[5E2A]          <1> 	mov [cs:.strcurptr], ax
   716 000029D8 2EC706[602A]0000    <1> 	mov word [cs:.curentryid], 0
   717                              <1> 
   718 000029DF 89C6                <1> 	mov si, ax
   719                              <1> 	clr cx
    31 000029E1 31C9                <2>  xor %1, %1
   720 000029E3 B401                <1> 	mov ah, 1			; In case the list is empty
   721                              <1> 
   722 000029E5 803C00              <1> 	cmp byte [si], 0	; Check if the list contains any entries
   723 000029E8 741B                <1> 	je .no_entries
   724                              <1> 
   725 000029EA 41                  <1> 	inc cx				; Automatically assume there is at least 1 entry in the list
   726                              <1> 	clr ah				; For storing the max length
    31 000029EB 30E4                <2>  xor %1, %1
   727                              <1> 	clr dl				; For storing the current length
    31 000029ED 30D2                <2>  xor %1, %1
   728                              <1> 
   729                              <1> .entry_loop:
   730 000029EF AC                  <1> 	lodsb
   731                              <1> 
   732 000029F0 FEC2                <1> 	inc dl				; Increment the current width
   733 000029F2 38E2                <1> 	cmp dl, ah			; Save it if it is the largest so far
   734 000029F4 7E02                <1> 	jle .no_expand
   735                              <1> 
   736 000029F6 88D4                <1> 	mov ah, dl
   737                              <1> 
   738                              <1> .no_expand:
   739 000029F8 84C0                <1> 	test al, al			; End of string?
   740 000029FA 7409                <1> 	jz .no_entries
   741                              <1> 
   742 000029FC 3C2C                <1> 	cmp al, ','			; End of entry?
   743 000029FE 75EF                <1> 	jne .entry_loop
   744                              <1> 
   745                              <1> 	clr dl				; Reset the width counter
    31 00002A00 30D2                <2>  xor %1, %1
   746 00002A02 41                  <1> 	inc cx				; Increment the entry counter
   747 00002A03 EBEA                <1> 	jmp .entry_loop
   748                              <1> 
   749                              <1> .no_entries:
   750 00002A05 FECC                <1> 	dec ah				; Terminator character was counted as well, so get rid of it
   751 00002A07 88E0                <1> 	mov al, ah
   752 00002A09 BE[0F2A]            <1> 	mov si, .callback
   753 00002A0C 8CCA                <1> 	mov dx, cs
   754 00002A0E C3                  <1> 	ret
   755                              <1> 
   756                              <1> .callback:
   757 00002A0F 1E                  <1> 	push ds
   758 00002A10 53                  <1> 	push bx
   759                              <1> 
   760 00002A11 7244                <1> 	jc .cb_exit
   761                              <1> 
   762                              <1> 	movs ds, cs
    39 00002A13 0E                  <2>  push %2
    40 00002A14 1F                  <2>  pop %1
   763                              <1> 
   764 00002A15 49                  <1> 	dec cx
   765                              <1> 	
   766 00002A16 8B36[5E2A]          <1> 	mov si, [.strcurptr]
   767 00002A1A 8B1E[602A]          <1> 	mov bx, [.curentryid]
   768                              <1> 
   769                              <1> 	; Check if we're able to simply advance forward or if we have to rewind to the start
   770                              <1> 	
   771 00002A1E 39D9                <1> 	cmp cx, bx
   772 00002A20 7D06                <1> 	jge .advance
   773                              <1> 
   774                              <1> 	clr bx
    31 00002A22 31DB                <2>  xor %1, %1
   775 00002A24 8B36[5C2A]          <1> 	mov si, [.strbaseptr]
   776                              <1> 
   777                              <1> .advance:
   778 00002A28 29D9                <1> 	sub cx, bx				; Subtract the IDs that we've already processed
   779                              <1> 
   780 00002A2A 8E1E[5A2A]          <1> 	mov ds, [.strbasesgmt]
   781                              <1> 
   782 00002A2E 85C9                <1> 	test cx, cx				; Do we already have the thing we want?
   783 00002A30 740C                <1> 	jz .print_loop
   784                              <1> 
   785                              <1> 	; If not, then find it
   786                              <1> 
   787                              <1> .search_loop:
   788 00002A32 AC                  <1> 	lodsb
   789                              <1> 
   790 00002A33 84C0                <1> 	test al, al				; This should not happen
   791 00002A35 7420                <1> 	jz .cb_exit
   792                              <1> 
   793 00002A37 3C2C                <1> 	cmp al, ','
   794 00002A39 75F7                <1> 	jne .search_loop
   795                              <1> 
   796 00002A3B 43                  <1> 	inc bx
   797 00002A3C E2F4                <1> 	loop .search_loop
   798                              <1> 
   799                              <1> .print_loop:
   800 00002A3E AC                  <1> 	lodsb
   801                              <1> 
   802 00002A3F 84C0                <1> 	test al, al
   803 00002A41 7409                <1> 	jz .cb_save_exit
   804                              <1> 
   805 00002A43 3C2C                <1> 	cmp al, ','
   806 00002A45 7405                <1> 	je .cb_save_exit
   807                              <1> 
   808 00002A47 E889EC              <1> 	call os_putchar
   809 00002A4A EBF2                <1> 	jmp .print_loop
   810                              <1> 
   811                              <1> .cb_save_exit:
   812 00002A4C 43                  <1> 	inc bx
   813 00002A4D 2E891E[602A]        <1> 	mov [cs:.curentryid], bx
   814 00002A52 2E8936[5E2A]        <1> 	mov [cs:.strcurptr], si	
   815                              <1> 
   816                              <1> .cb_exit:
   817 00002A57 5B                  <1> 	pop bx
   818 00002A58 1F                  <1> 	pop ds
   819 00002A59 C3                  <1> 	ret
   820                              <1> 
   821 00002A5A 0000                <1> .strbasesgmt	dw 0
   822 00002A5C 0000                <1> .strbaseptr		dw 0
   823 00002A5E 0000                <1> .strcurptr		dw 0
   824 00002A60 0000                <1> .curentryid		dw 0
   825                              <1> 
   826                              <1> ; ------------------------------------------------------------------
   827                              <1> ; os_32int_to_string -- Converts an unsigned 32-bit integer into a string
   828                              <1> ; IN: EAX = unsigned int
   829                              <1> ; OUT: DS:AX = string location
   830                              <1> 
   831                              <1> os_32int_to_string:
   832 00002A62 6660                <1> 	pushad
   833                              <1> 	movs ds, cs
    39 00002A64 0E                  <2>  push %2
    40 00002A65 1F                  <2>  pop %1
   834                              <1> 
   835                              <1> 	clr cx
    31 00002A66 31C9                <2>  xor %1, %1
   836 00002A68 66BB0A000000        <1> 	mov ebx, 10					; Set BX 10, for division and mod
   837 00002A6E BF[0129]            <1> 	mov di, os_int_to_string.t	; Get our pointer ready
   838                              <1> 
   839                              <1> .push:
   840                              <1> 	clr edx
    31 00002A71 6631D2              <2>  xor %1, %1
   841 00002A74 66F7F3              <1> 	div ebx						; Remainder in DX, quotient in AX
   842                              <1> 
   843 00002A77 41                  <1> 	inc cx						; Increase pop loop counter
   844                              <1> 
   845 00002A78 6652                <1> 	push edx					; Push remainder, so as to reverse order when popping
   846 00002A7A 6685C0              <1> 	test eax, eax				; Is quotient zero?
   847 00002A7D 75F2                <1> 	jnz .push					; If not, loop again
   848                              <1> 
   849                              <1> .pop:
   850 00002A7F 665A                <1> 	pop edx						; Pop off values in reverse order, and add 48 to make them digits
   851                              <1> 
   852 00002A81 80C230              <1> 	add dl, '0'					; And save them in the string, increasing the pointer each time
   853 00002A84 8815                <1> 	mov [di], dl
   854                              <1> 
   855 00002A86 47                  <1> 	inc di
   856 00002A87 49                  <1> 	dec cx
   857 00002A88 75F5                <1> 	jnz .pop
   858                              <1> 
   859 00002A8A C60500              <1> 	mov byte [di], 0			; Zero-terminate string
   860                              <1> 
   861 00002A8D 6661                <1> 	popad
   862 00002A8F B8[0129]            <1> 	mov ax, os_int_to_string.t	; Return location of string
   863 00002A92 C3                  <1> 	ret
   864                              <1> 
   865                              <1> 
   866                              <1> ; ------------------------------------------------------------------
   867                              <1> ; os_string_to_32int -- Converts a string into a 32-bit integer
   868                              <1> ; IN: DS:SI = string location
   869                              <1> ; OUT: EAX = unsigned integer
   870                              <1> 
   871                              <1> os_string_to_32int:
   872 00002A93 56                  <1> 	push si
   873 00002A94 6651                <1> 	push ecx
   874 00002A96 6652                <1> 	push edx
   875                              <1> 
   876                              <1> 	clr eax					; Temporary 32-bit integer
    31 00002A98 6631C0              <2>  xor %1, %1
   877                              <1> 	
   878                              <1> .loop:
   879 00002A9B 6650                <1> 	push eax
   880 00002A9D AC                  <1> 	lodsb					; Load a byte from SI
   881 00002A9E 88C1                <1> 	mov cl, al
   882 00002AA0 6658                <1> 	pop eax
   883                              <1> 
   884 00002AA2 80F930              <1> 	cmp cl, '0'
   885 00002AA5 7C1A                <1> 	jl .exit
   886                              <1> 
   887 00002AA7 80F939              <1> 	cmp cl, '9'
   888 00002AAA 7F15                <1> 	jg .exit
   889                              <1> 
   890 00002AAC 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
   891 00002AAF 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
   892                              <1> 
   893 00002AB6 2E66F726[C72A]      <1> 	mul dword [cs:.divisor]	; Multiply EAX by 10
   894 00002ABC 6601C8              <1> 	add eax, ecx			; Add the value to the integer
   895 00002ABF EBDA                <1> 	jmp .loop				; Loop again
   896                              <1> 	
   897                              <1> .exit:
   898 00002AC1 665A                <1> 	pop edx
   899 00002AC3 6659                <1> 	pop ecx
   900 00002AC5 5E                  <1> 	pop si
   901 00002AC6 C3                  <1> 	ret
   902                              <1> 	
   903 00002AC7 0A000000            <1> 	.divisor	dd 10
   904                              <1> 	
   905                              <1> ; ==================================================================
   529                                  	%INCLUDE "features/basic.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS/MikeOS 4.5 BASIC interpreter
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; ------------------------------------------------------------------
     6                              <1> ; Token types
     7                              <1> 
     8                              <1> %DEFINE VARIABLE 1
     9                              <1> %DEFINE STRING_VAR 2
    10                              <1> %DEFINE NUMBER 3
    11                              <1> %DEFINE STRING 4
    12                              <1> %DEFINE QUOTE 5
    13                              <1> %DEFINE CHAR 6
    14                              <1> %DEFINE UNKNOWN 7
    15                              <1> %DEFINE LABEL 8
    16                              <1> 
    17                              <1> ; ------------------------------------------------------------------
    18                              <1> ; The BASIC interpreter execution starts here -- a parameter string
    19                              <1> ; is passed in SI and copied into the first string, unless SI = 0
    20                              <1> 
    21                              <1> os_run_basic:
    22 00002ACB E86FEC              <1> 	call os_clear_screen
    23                              <1> 	
    24 00002ACE 8926[8C44]          <1> 	mov word [orig_stack], sp		; Save stack pointer -- we might jump to the
    25                              <1> 						; error printing code and quit in the middle
    26                              <1> 						; some nested loops, and we want to preserve
    27                              <1> 						; the stack
    28                              <1> 
    29 00002AD2 A3[9244]            <1> 	mov word [load_point], ax		; AX was passed as starting location of code
    30                              <1> 
    31 00002AD5 A3[8E44]            <1> 	mov word [prog], ax			; prog = pointer to current execution point in code
    32                              <1> 
    33 00002AD8 01C3                <1> 	add bx, ax				; We were passed the .BAS byte size in BX
    34 00002ADA 4B                  <1> 	dec bx
    35 00002ADB 4B                  <1> 	dec bx
    36 00002ADC 891E[9044]          <1> 	mov word [prog_end], bx			; Make note of program end point
    37                              <1> 
    38                              <1> 
    39 00002AE0 E81C02              <1> 	call clear_ram				; Clear variables etc. from previous run
    40                              <1> 						; of a BASIC program
    41                              <1> 
    42 00002AE3 85F6                <1> 	test si, si				; Passed a parameter string?
    43 00002AE5 7406                <1> 	jz mainloop
    44                              <1> 
    45 00002AE7 BF007C              <1> 	mov di, string_vars			; If so, copy it into $1
    46 00002AEA E803FD              <1> 	call os_string_copy
    47                              <1> 
    48                              <1> 
    49                              <1> 
    50                              <1> mainloop:
    51 00002AED E81F18              <1> 	call get_token				; Get a token from the start of the line
    52                              <1> 
    53 00002AF0 83F804              <1> 	cmp ax, STRING				; Is the type a string of characters?
    54 00002AF3 7418                <1> 	je .keyword				; If so, let's see if it's a keyword to process
    55                              <1> 
    56 00002AF5 83F801              <1> 	cmp ax, VARIABLE			; If it's a variable at the start of the line,
    57 00002AF8 0F844702            <1> 	je assign				; this is an assign (eg "X = Y + 5")
    58                              <1> 
    59 00002AFC 83F802              <1> 	cmp ax, STRING_VAR			; Same for a string variable (eg $1)
    60 00002AFF 0F844002            <1> 	je assign
    61                              <1> 
    62 00002B03 83F808              <1> 	cmp ax, LABEL				; Don't need to do anything here - skip
    63 00002B06 74E5                <1> 	je mainloop
    64                              <1> 
    65 00002B08 B314                <1> 	mov bl, err_syntax			; Otherwise show an error and quit
    66 00002B0A E91B19              <1> 	jmp error
    67                              <1> 
    68                              <1> 
    69                              <1> .keyword:
    70 00002B0D BE007B              <1> 	mov si, token				; Start trying to match commands
    71                              <1> 
    72 00002B10 BF[9A44]            <1> 	mov di, alert_cmd
    73 00002B13 E837FD              <1> 	call os_string_compare
    74 00002B16 0F82CC04            <1> 	jc do_alert
    75                              <1> 
    76 00002B1A BF[A044]            <1> 	mov di, askfile_cmd
    77 00002B1D E82DFD              <1> 	call os_string_compare
    78 00002B20 0F82FF04            <1> 	jc do_askfile
    79                              <1> 
    80 00002B24 BF[A844]            <1> 	mov di, break_cmd
    81 00002B27 E823FD              <1> 	call os_string_compare
    82 00002B2A 0F823005            <1> 	jc do_break
    83                              <1> 
    84 00002B2E BF[B344]            <1> 	mov di, case_cmd
    85 00002B31 E819FD              <1> 	call os_string_compare
    86 00002B34 0F825205            <1> 	jc do_case
    87                              <1> 
    88 00002B38 BF[AE44]            <1> 	mov di, call_cmd
    89 00002B3B E80FFD              <1> 	call os_string_compare
    90 00002B3E 0F822105            <1> 	jc do_call
    91                              <1> 
    92 00002B42 BF[B844]            <1> 	mov di, cls_cmd
    93 00002B45 E805FD              <1> 	call os_string_compare
    94 00002B48 0F829005            <1> 	jc do_cls
    95                              <1> 
    96 00002B4C BF[BC44]            <1> 	mov di, cursor_cmd
    97 00002B4F E8FBFC              <1> 	call os_string_compare
    98 00002B52 0F829A05            <1> 	jc do_cursor
    99                              <1> 
   100 00002B56 BF[C344]            <1> 	mov di, curschar_cmd
   101 00002B59 E8F1FC              <1> 	call os_string_compare
   102 00002B5C 0F82C105            <1> 	jc do_curschar
   103                              <1> 
   104 00002B60 BF[CC44]            <1> 	mov di, curscol_cmd
   105 00002B63 E8E7FC              <1> 	call os_string_compare
   106 00002B66 0F82DF05            <1> 	jc do_curscol
   107                              <1> 
   108 00002B6A BF[D444]            <1> 	mov di, curspos_cmd
   109 00002B6D E8DDFC              <1> 	call os_string_compare
   110 00002B70 0F82FD05            <1> 	jc do_curspos
   111                              <1> 	
   112 00002B74 BF[DC44]            <1> 	mov di, delete_cmd
   113 00002B77 E8D3FC              <1> 	call os_string_compare
   114 00002B7A 0F822B06            <1> 	jc do_delete
   115                              <1> 	
   116 00002B7E BF[E344]            <1> 	mov di, do_cmd
   117 00002B81 E8C9FC              <1> 	call os_string_compare
   118 00002B84 0F827606            <1> 	jc do_do
   119                              <1> 
   120 00002B88 BF[EB44]            <1> 	mov di, end_cmd
   121 00002B8B E8BFFC              <1> 	call os_string_compare
   122 00002B8E 0F82B306            <1> 	jc do_end
   123                              <1> 
   124 00002B92 BF[E644]            <1> 	mov di, else_cmd
   125 00002B95 E8B5FC              <1> 	call os_string_compare
   126 00002B98 0F828A06            <1> 	jc do_else
   127                              <1> 
   128 00002B9C BF[EF44]            <1> 	mov di, files_cmd
   129 00002B9F E8ABFC              <1> 	call os_string_compare
   130 00002BA2 0F82B406            <1> 	jc do_files
   131                              <1> 
   132 00002BA6 BF[F544]            <1> 	mov di, for_cmd
   133 00002BA9 E8A1FC              <1> 	call os_string_compare
   134 00002BAC 0F820E07            <1> 	jc do_for
   135                              <1> 
   136 00002BB0 BF[0445]            <1> 	mov di, getkey_cmd
   137 00002BB3 E897FC              <1> 	call os_string_compare
   138 00002BB6 0F82B207            <1> 	jc do_getkey
   139                              <1> 
   140 00002BBA BF[F944]            <1> 	mov di, gosub_cmd
   141 00002BBD E88DFC              <1> 	call os_string_compare
   142 00002BC0 0F82F007            <1> 	jc do_gosub
   143                              <1> 
   144 00002BC4 BF[FF44]            <1> 	mov di, goto_cmd
   145 00002BC7 E883FC              <1> 	call os_string_compare
   146 00002BCA 0F828308            <1> 	jc do_goto
   147                              <1> 
   148 00002BCE BF[0B45]            <1> 	mov di, if_cmd
   149 00002BD1 E879FC              <1> 	call os_string_compare
   150 00002BD4 0F82F908            <1> 	jc do_if
   151                              <1> 
   152 00002BD8 BF[0E45]            <1> 	mov di, include_cmd
   153 00002BDB E86FFC              <1> 	call os_string_compare
   154 00002BDE 0F82030B            <1> 	jc do_include
   155                              <1> 
   156 00002BE2 BF[1645]            <1> 	mov di, ink_cmd
   157 00002BE5 E865FC              <1> 	call os_string_compare
   158 00002BE8 0F82280B            <1> 	jc do_ink
   159                              <1> 
   160 00002BEC BF[1A45]            <1> 	mov di, input_cmd
   161 00002BEF E85BFC              <1> 	call os_string_compare
   162 00002BF2 0F82400B            <1> 	jc do_input
   163                              <1> 	
   164 00002BF6 BF[2045]            <1> 	mov di, len_cmd
   165 00002BF9 E851FC              <1> 	call os_string_compare
   166 00002BFC 0F82A10B            <1> 	jc do_len
   167                              <1> 
   168 00002C00 BF[2445]            <1> 	mov di, listbox_cmd
   169 00002C03 E847FC              <1> 	call os_string_compare
   170 00002C06 0F82DF0B            <1> 	jc do_listbox
   171                              <1> 
   172 00002C0A BF[2C45]            <1> 	mov di, load_cmd
   173 00002C0D E83DFC              <1> 	call os_string_compare
   174 00002C10 0F826E0C            <1> 	jc do_load
   175                              <1> 
   176 00002C14 BF[3145]            <1> 	mov di, loop_cmd
   177 00002C17 E833FC              <1> 	call os_string_compare
   178 00002C1A 0F82D60C            <1> 	jc do_loop
   179                              <1> 
   180 00002C1E BF[3645]            <1> 	mov di, move_cmd
   181 00002C21 E829FC              <1> 	call os_string_compare
   182 00002C24 0F82C00D            <1> 	jc do_move
   183                              <1> 
   184 00002C28 BF[3B45]            <1> 	mov di, next_cmd
   185 00002C2B E81FFC              <1> 	call os_string_compare
   186 00002C2E 0F82F90D            <1> 	jc do_next
   187                              <1> 
   188 00002C32 BF[4045]            <1> 	mov di, number_cmd
   189 00002C35 E815FC              <1> 	call os_string_compare
   190 00002C38 0F823C0E            <1> 	jc do_number
   191                              <1> 
   192 00002C3C BF[4745]            <1> 	mov di, page_cmd
   193 00002C3F E80BFC              <1> 	call os_string_compare
   194 00002C42 0F829D0E            <1> 	jc do_page
   195                              <1> 
   196 00002C46 BF[4C45]            <1> 	mov di, pause_cmd
   197 00002C49 E801FC              <1> 	call os_string_compare
   198 00002C4C 0F82C20E            <1> 	jc do_pause
   199                              <1> 
   200 00002C50 BF[5245]            <1> 	mov di, peek_cmd
   201 00002C53 E8F7FB              <1> 	call os_string_compare
   202 00002C56 0F82D60E            <1> 	jc do_peek
   203                              <1> 
   204 00002C5A BF[5745]            <1> 	mov di, peekint_cmd
   205 00002C5D E8EDFB              <1> 	call os_string_compare
   206 00002C60 0F820E0F            <1> 	jc do_peekint
   207                              <1> 	
   208 00002C64 BF[5F45]            <1> 	mov di, poke_cmd
   209 00002C67 E8E3FB              <1> 	call os_string_compare
   210 00002C6A 0F823E0F            <1> 	jc do_poke
   211                              <1> 	
   212 00002C6E BF[6445]            <1> 	mov di, pokeint_cmd
   213 00002C71 E8D9FB              <1> 	call os_string_compare
   214 00002C74 0F828C0F            <1> 	jc do_pokeint
   215                              <1> 
   216 00002C78 BF[6C45]            <1> 	mov di, port_cmd
   217 00002C7B E8CFFB              <1> 	call os_string_compare
   218 00002C7E 0F82C70F            <1> 	jc do_port
   219                              <1> 
   220 00002C82 BF[7145]            <1> 	mov di, print_cmd
   221 00002C85 E8C5FB              <1> 	call os_string_compare
   222 00002C88 0F823F10            <1> 	jc do_print
   223                              <1> 
   224 00002C8C BF[7745]            <1> 	mov di, rand_cmd
   225 00002C8F E8BBFB              <1> 	call os_string_compare
   226 00002C92 0F825D11            <1> 	jc do_rand
   227                              <1> 
   228 00002C96 BF[7C45]            <1> 	mov di, read_cmd
   229 00002C99 E8B1FB              <1> 	call os_string_compare
   230 00002C9C 0F82A511            <1> 	jc do_read
   231                              <1> 
   232 00002CA0 BF[8145]            <1> 	mov di, rem_cmd
   233 00002CA3 E8A7FB              <1> 	call os_string_compare
   234 00002CA6 0F827112            <1> 	jc do_rem
   235                              <1> 
   236 00002CAA BF[8545]            <1> 	mov di, rename_cmd
   237 00002CAD E89DFB              <1> 	call os_string_compare
   238 00002CB0 0F827812            <1> 	jc do_rename
   239                              <1> 
   240 00002CB4 BF[8C45]            <1> 	mov di, return_cmd
   241 00002CB7 E893FB              <1> 	call os_string_compare
   242 00002CBA 0F822313            <1> 	jc do_return
   243                              <1> 
   244 00002CBE BF[9345]            <1> 	mov di, save_cmd
   245 00002CC1 E889FB              <1> 	call os_string_compare
   246 00002CC4 0F823A13            <1> 	jc do_save
   247                              <1> 
   248 00002CC8 BF[9845]            <1> 	mov di, serial_cmd
   249 00002CCB E87FFB              <1> 	call os_string_compare
   250 00002CCE 0F82EF13            <1> 	jc do_serial
   251                              <1> 
   252 00002CD2 BF[9F45]            <1> 	mov di, size_cmd
   253 00002CD5 E875FB              <1> 	call os_string_compare
   254 00002CD8 0F828914            <1> 	jc do_size
   255                              <1> 
   256 00002CDC BF[A445]            <1> 	mov di, sound_cmd
   257 00002CDF E86BFB              <1> 	call os_string_compare
   258 00002CE2 0F82D414            <1> 	jc do_sound
   259                              <1> 	
   260 00002CE6 BF[AA45]            <1> 	mov di, string_cmd
   261 00002CE9 E861FB              <1> 	call os_string_compare
   262 00002CEC 0F820615            <1> 	jc do_string
   263                              <1> 
   264 00002CF0 BF[B145]            <1> 	mov di, waitkey_cmd
   265 00002CF3 E857FB              <1> 	call os_string_compare
   266 00002CF6 0F82B015            <1> 	jc do_waitkey
   267                              <1> 
   268 00002CFA B301                <1> 	mov bl, err_cmd_unknown			; Command not found?
   269 00002CFC E92917              <1> 	jmp error
   270                              <1> 
   271                              <1> 
   272                              <1> ; ------------------------------------------------------------------
   273                              <1> ; CLEAR RAM
   274                              <1> 
   275                              <1> clear_ram:
   276 00002CFF 60                  <1> 	pusha
   277                              <1> 	clr al
    31 00002D00 30C0                <2>  xor %1, %1
   278                              <1> 
   279 00002D02 BF4C7A              <1> 	mov di, variables
   280 00002D05 B93400              <1> 	mov cx, 52
   281 00002D08 F3AA                <1> 	rep stosb
   282                              <1> 
   283 00002D0A BF187A              <1> 	mov di, for_variables
   284 00002D0D B93400              <1> 	mov cx, 52
   285 00002D10 F3AA                <1> 	rep stosb
   286                              <1> 
   287 00002D12 BFE479              <1> 	mov di, for_code_points
   288 00002D15 B93400              <1> 	mov cx, 52
   289 00002D18 F3AA                <1> 	rep stosb
   290                              <1> 	
   291 00002D1A BFD079              <1> 	mov di, do_loop_store
   292 00002D1D B90A00              <1> 	mov cx, 10
   293 00002D20 F3AA                <1> 	rep stosb
   294                              <1> 
   295 00002D22 C606[0546]00        <1> 	mov byte [gosub_depth], 0
   296 00002D27 C606[9544]00        <1> 	mov byte [loop_in], 0
   297                              <1> 
   298 00002D2C BFBC79              <1> 	mov di, gosub_points
   299 00002D2F B91400              <1> 	mov cx, 20
   300 00002D32 F3AA                <1> 	rep stosb
   301                              <1> 
   302 00002D34 BF007C              <1> 	mov di, string_vars
   303 00002D37 B90004              <1> 	mov cx, 1024
   304 00002D3A F3AA                <1> 	rep stosb
   305                              <1> 
   306 00002D3C C606[9744]07        <1> 	mov byte [ink_colour], 7		; White ink
   307                              <1> 
   308 00002D41 61                  <1> 	popa
   309 00002D42 C3                  <1> 	ret
   310                              <1> 
   311                              <1> 
   312                              <1> ; ------------------------------------------------------------------
   313                              <1> ; ASSIGNMENT
   314                              <1> 
   315                              <1> assign:
   316 00002D43 83F801              <1> 	cmp ax, VARIABLE			; Are we starting with a number var?
   317 00002D46 0F84A700            <1> 	je .do_num_var
   318                              <1> 
   319 00002D4A BF007C              <1> 	mov di, string_vars			; Otherwise it's a string var
   320 00002D4D B88000              <1> 	mov ax, 128
   321 00002D50 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
   322 00002D52 01C7                <1> 	add di, ax
   323                              <1> 
   324 00002D54 57                  <1> 	push di
   325                              <1> 
   326 00002D55 E8B715              <1> 	call get_token
   327 00002D58 A0007B              <1> 	mov byte al, [token]
   328 00002D5B 3C3D                <1> 	cmp al, '='
   329 00002D5D 0F857C02            <1> 	jne .error
   330                              <1> 
   331 00002D61 E8AB15              <1> 	call get_token				; See if second is quote
   332 00002D64 83F805              <1> 	cmp ax, QUOTE
   333 00002D67 7417                <1> 	je .second_is_quote
   334                              <1> 
   335 00002D69 83F802              <1> 	cmp ax, STRING_VAR
   336 00002D6C 0F856D02            <1> 	jne .error
   337                              <1> 
   338 00002D70 BE007C              <1> 	mov si, string_vars			; Otherwise it's a string var
   339 00002D73 B88000              <1> 	mov ax, 128
   340 00002D76 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
   341 00002D78 01C6                <1> 	add si, ax
   342                              <1> 
   343 00002D7A 5F                  <1> 	pop di
   344 00002D7B E872FA              <1> 	call os_string_copy
   345                              <1> 
   346 00002D7E EB07                <1> 	jmp .string_check_for_more
   347                              <1> 
   348                              <1> 
   349                              <1> .second_is_quote:
   350 00002D80 BE007B              <1> 	mov si, token
   351 00002D83 5F                  <1> 	pop di
   352 00002D84 E869FA              <1> 	call os_string_copy
   353                              <1> 
   354                              <1> 
   355                              <1> .string_check_for_more:
   356 00002D87 57                  <1> 	push di
   357 00002D88 A1[8E44]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
   358 00002D8B A3[E32F]            <1> 	mov word [.tmp_loc], ax
   359                              <1> 
   360 00002D8E E87E15              <1> 	call get_token				; Any more to deal with in this assignment?
   361 00002D91 A0007B              <1> 	mov byte al, [token]
   362 00002D94 3C2B                <1> 	cmp al, '+'
   363 00002D96 740A                <1> 	je .string_theres_more
   364                              <1> 
   365 00002D98 A1[E32F]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
   366 00002D9B A3[8E44]            <1> 	mov word [prog], ax			; that we just grabbed
   367                              <1> 
   368 00002D9E 5F                  <1> 	pop di
   369 00002D9F E94BFD              <1> 	jmp mainloop				; And go back to the code interpreter!
   370                              <1> 
   371                              <1> 
   372                              <1> .string_theres_more:
   373 00002DA2 E86A15              <1> 	call get_token
   374 00002DA5 83F802              <1> 	cmp ax, STRING_VAR
   375 00002DA8 740D                <1> 	je .another_string_var
   376 00002DAA 83F805              <1> 	cmp ax, QUOTE
   377 00002DAD 741E                <1> 	je .another_quote
   378 00002DAF 83F801              <1> 	cmp ax, VARIABLE
   379 00002DB2 7426                <1> 	je .add_number_var
   380 00002DB4 E92602              <1> 	jmp .error
   381                              <1> 
   382                              <1> 
   383                              <1> .another_string_var:
   384 00002DB7 5F                  <1> 	pop di
   385                              <1> 
   386 00002DB8 BE007C              <1> 	mov si, string_vars
   387 00002DBB B88000              <1> 	mov ax, 128
   388 00002DBE F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
   389 00002DC0 01C6                <1> 	add si, ax
   390                              <1> 
   391 00002DC2 89F8                <1> 	mov ax, di
   392 00002DC4 89F9                <1> 	mov cx, di
   393 00002DC6 89F3                <1> 	mov bx, si
   394 00002DC8 E82EFA              <1> 	call os_string_join
   395                              <1> 
   396 00002DCB EBBA                <1> 	jmp .string_check_for_more
   397                              <1> 
   398                              <1> 
   399                              <1> 
   400                              <1> .another_quote:
   401 00002DCD 5F                  <1> 	pop di
   402                              <1> 
   403 00002DCE 89F8                <1> 	mov ax, di
   404 00002DD0 89F9                <1> 	mov cx, di
   405 00002DD2 BB007B              <1> 	mov bx, token
   406 00002DD5 E821FA              <1> 	call os_string_join
   407                              <1> 
   408 00002DD8 EBAD                <1> 	jmp .string_check_for_more
   409                              <1> 
   410                              <1> 
   411                              <1> .add_number_var:
   412 00002DDA 31C0                <1> 	xor ax, ax
   413 00002DDC A0007B              <1> 	mov byte al, [token]
   414 00002DDF E81115              <1> 	call get_var
   415 00002DE2 E8F5FA              <1> 	call os_int_to_string
   416                              <1> 
   417 00002DE5 89C3                <1> 	mov bx, ax
   418 00002DE7 5F                  <1> 	pop di
   419 00002DE8 89F8                <1> 	mov ax, di
   420 00002DEA 89F9                <1> 	mov cx, di
   421 00002DEC E80AFA              <1> 	call os_string_join
   422                              <1> 
   423 00002DEF EB96                <1> 	jmp .string_check_for_more
   424                              <1> 	
   425                              <1> 
   426                              <1> 
   427                              <1> 
   428                              <1> .do_num_var:
   429 00002DF1 31C0                <1> 	xor ax, ax
   430 00002DF3 A0007B              <1> 	mov byte al, [token]
   431 00002DF6 A2[E22F]            <1> 	mov byte [.tmp], al
   432                              <1> 
   433 00002DF9 E81315              <1> 	call get_token
   434 00002DFC A0007B              <1> 	mov byte al, [token]
   435 00002DFF 3C3D                <1> 	cmp al, '='
   436 00002E01 0F85D801            <1> 	jne .error
   437                              <1> 
   438 00002E05 E80715              <1> 	call get_token
   439 00002E08 83F803              <1> 	cmp ax, NUMBER
   440 00002E0B 744D                <1> 	je .second_is_num
   441                              <1> 
   442 00002E0D 83F801              <1> 	cmp ax, VARIABLE
   443 00002E10 7436                <1> 	je .second_is_variable
   444                              <1> 
   445 00002E12 83F804              <1> 	cmp ax, STRING
   446 00002E15 0F842E01            <1> 	je .second_is_string
   447                              <1> 
   448 00002E19 83F807              <1> 	cmp ax, UNKNOWN
   449 00002E1C 0F85BD01            <1> 	jne .error
   450                              <1> 
   451 00002E20 A0007B              <1> 	mov byte al, [token]			; Address of string var?
   452 00002E23 3C26                <1> 	cmp al, '&'
   453 00002E25 0F85B401            <1> 	jne .error
   454                              <1> 
   455 00002E29 E8E314              <1> 	call get_token				; Let's see if there's a string var
   456 00002E2C 83F802              <1> 	cmp ax, STRING_VAR
   457 00002E2F 0F85AA01            <1> 	jne .error
   458                              <1> 
   459 00002E33 BF007C              <1> 	mov di, string_vars
   460 00002E36 B88000              <1> 	mov ax, 128
   461 00002E39 F7E3                <1> 	mul bx
   462 00002E3B 01C7                <1> 	add di, ax
   463                              <1> 
   464 00002E3D 89FB                <1> 	mov bx, di
   465                              <1> 
   466 00002E3F A0[E22F]            <1> 	mov byte al, [.tmp]
   467 00002E42 E8BB14              <1> 	call set_var
   468                              <1> 
   469 00002E45 E9A5FC              <1> 	jmp mainloop
   470                              <1> 
   471                              <1> 
   472                              <1> .second_is_variable:
   473 00002E48 31C0                <1> 	xor ax, ax
   474 00002E4A A0007B              <1> 	mov byte al, [token]
   475                              <1> 
   476 00002E4D E8A314              <1> 	call get_var
   477 00002E50 89C3                <1> 	mov bx, ax
   478 00002E52 A0[E22F]            <1> 	mov byte al, [.tmp]
   479 00002E55 E8A814              <1> 	call set_var
   480                              <1> 
   481 00002E58 EB10                <1> 	jmp .check_for_more
   482                              <1> 
   483                              <1> 
   484                              <1> .second_is_num:
   485 00002E5A BE007B              <1> 	mov si, token
   486 00002E5D E841FA              <1> 	call os_string_to_int
   487                              <1> 
   488 00002E60 89C3                <1> 	mov bx, ax				; Number to insert in variable table
   489                              <1> 
   490 00002E62 31C0                <1> 	xor ax, ax
   491 00002E64 A0[E22F]            <1> 	mov byte al, [.tmp]
   492                              <1> 
   493 00002E67 E89614              <1> 	call set_var
   494                              <1> 
   495                              <1> 
   496                              <1> 	; The assignment could be simply "X = 5" etc. Or it could be
   497                              <1> 	; "X = Y + 5" -- ie more complicated. So here we check to see if
   498                              <1> 	; there's a delimiter...
   499                              <1> 
   500                              <1> .check_for_more:
   501 00002E6A A1[8E44]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
   502 00002E6D A3[E32F]            <1> 	mov word [.tmp_loc], ax
   503                              <1> 
   504 00002E70 E89C14              <1> 	call get_token				; Any more to deal with in this assignment?
   505 00002E73 A0007B              <1> 	mov byte al, [token]
   506 00002E76 3C2B                <1> 	cmp al, '+'
   507 00002E78 7419                <1> 	je .theres_more
   508 00002E7A 3C2D                <1> 	cmp al, '-'
   509 00002E7C 7415                <1> 	je .theres_more
   510 00002E7E 3C2A                <1> 	cmp al, '*'
   511 00002E80 7411                <1> 	je .theres_more
   512 00002E82 3C2F                <1> 	cmp al, '/'
   513 00002E84 740D                <1> 	je .theres_more
   514 00002E86 3C25                <1> 	cmp al, '%'
   515 00002E88 7409                <1> 	je .theres_more
   516                              <1> 
   517 00002E8A A1[E32F]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
   518 00002E8D A3[8E44]            <1> 	mov word [prog], ax			; that we just grabbed
   519                              <1> 
   520 00002E90 E95AFC              <1> 	jmp mainloop				; And go back to the code interpreter!
   521                              <1> 
   522                              <1> 
   523                              <1> .theres_more:
   524 00002E93 A2[E52F]            <1> 	mov byte [.delim], al
   525                              <1> 
   526 00002E96 E87614              <1> 	call get_token
   527 00002E99 83F801              <1> 	cmp ax, VARIABLE
   528 00002E9C 7458                <1> 	je .handle_variable
   529                              <1> 
   530 00002E9E BE007B              <1> 	mov si, token
   531 00002EA1 E8FDF9              <1> 	call os_string_to_int
   532 00002EA4 89C3                <1> 	mov bx, ax
   533                              <1> 
   534 00002EA6 31C0                <1> 	xor ax, ax
   535 00002EA8 A0[E22F]            <1> 	mov byte al, [.tmp]
   536                              <1> 
   537 00002EAB E84514              <1> 	call get_var				; This also points SI at right place in variable table
   538                              <1> 
   539 00002EAE 803E[E52F]2B        <1> 	cmp byte [.delim], '+'
   540 00002EB3 7504                <1> 	jne .not_plus
   541                              <1> 
   542 00002EB5 01D8                <1> 	add ax, bx
   543 00002EB7 EB2D                <1> 	jmp .finish
   544                              <1> 
   545                              <1> .not_plus:
   546 00002EB9 803E[E52F]2D        <1> 	cmp byte [.delim], '-'
   547 00002EBE 7504                <1> 	jne .not_minus
   548                              <1> 
   549 00002EC0 29D8                <1> 	sub ax, bx
   550 00002EC2 EB22                <1> 	jmp .finish
   551                              <1> 
   552                              <1> .not_minus:
   553 00002EC4 803E[E52F]2A        <1> 	cmp byte [.delim], '*'
   554 00002EC9 7504                <1> 	jne .not_times
   555                              <1> 
   556 00002ECB F7E3                <1> 	mul bx
   557 00002ECD EB17                <1> 	jmp .finish
   558                              <1> 
   559                              <1> .not_times:
   560 00002ECF 803E[E52F]2F        <1> 	cmp byte [.delim], '/'
   561 00002ED4 750A                <1> 	jne .not_divide
   562                              <1> 
   563 00002ED6 85DB                <1> 	test bx, bx
   564 00002ED8 7417                <1> 	jz .divide_zero
   565                              <1> 	
   566 00002EDA 31D2                <1> 	xor dx, dx
   567 00002EDC F7F3                <1> 	div bx
   568 00002EDE EB06                <1> 	jmp .finish
   569                              <1> 
   570                              <1> .not_divide:
   571 00002EE0 31D2                <1> 	xor dx, dx
   572 00002EE2 F7F3                <1> 	div bx
   573 00002EE4 89D0                <1> 	mov ax, dx				; Get remainder
   574                              <1> 
   575                              <1> .finish:
   576 00002EE6 89C3                <1> 	mov bx, ax
   577 00002EE8 A0[E22F]            <1> 	mov byte al, [.tmp]
   578 00002EEB E81214              <1> 	call set_var
   579                              <1> 
   580 00002EEE E979FF              <1> 	jmp .check_for_more
   581                              <1> 
   582                              <1> .divide_zero:
   583 00002EF1 B302                <1> 	mov bl, err_divide_by_zero
   584 00002EF3 E93215              <1> 	jmp error
   585                              <1> 	
   586                              <1> .handle_variable:
   587 00002EF6 31C0                <1> 	xor ax, ax
   588 00002EF8 A0007B              <1> 	mov byte al, [token]
   589                              <1> 
   590 00002EFB E8F513              <1> 	call get_var
   591                              <1> 
   592 00002EFE 89C3                <1> 	mov bx, ax
   593                              <1> 
   594 00002F00 31C0                <1> 	xor ax, ax
   595 00002F02 A0[E22F]            <1> 	mov byte al, [.tmp]
   596                              <1> 
   597 00002F05 E8EB13              <1> 	call get_var
   598                              <1> 
   599 00002F08 803E[E52F]2B        <1> 	cmp byte [.delim], '+'
   600 00002F0D 7504                <1> 	jne .vnot_plus
   601                              <1> 
   602 00002F0F 01D8                <1> 	add ax, bx
   603 00002F11 EB29                <1> 	jmp .vfinish
   604                              <1> 
   605                              <1> .vnot_plus:
   606 00002F13 803E[E52F]2D        <1> 	cmp byte [.delim], '-'
   607 00002F18 7504                <1> 	jne .vnot_minus
   608                              <1> 
   609 00002F1A 29D8                <1> 	sub ax, bx
   610 00002F1C EB1E                <1> 	jmp .vfinish
   611                              <1> 
   612                              <1> .vnot_minus:
   613 00002F1E 803E[E52F]2A        <1> 	cmp byte [.delim], '*'
   614 00002F23 7504                <1> 	jne .vnot_times
   615                              <1> 
   616 00002F25 F7E3                <1> 	mul bx
   617 00002F27 EB13                <1> 	jmp .vfinish
   618                              <1> 
   619                              <1> .vnot_times:
   620 00002F29 803E[E52F]2F        <1> 	cmp byte [.delim], '/'
   621 00002F2E 7506                <1> 	jne .vnot_divide
   622                              <1> 
   623 00002F30 31D2                <1> 	xor dx, dx
   624 00002F32 F7F3                <1> 	div bx
   625 00002F34 EBB0                <1> 	jmp .finish
   626                              <1> 
   627                              <1> .vnot_divide:
   628 00002F36 31D2                <1> 	xor dx, dx
   629 00002F38 F7F3                <1> 	div bx
   630 00002F3A 89D0                <1> 	mov ax, dx				; Get remainder
   631                              <1> 
   632                              <1> .vfinish:
   633 00002F3C 89C3                <1> 	mov bx, ax
   634 00002F3E A0[E22F]            <1> 	mov byte al, [.tmp]
   635 00002F41 E8BC13              <1> 	call set_var
   636                              <1> 
   637 00002F44 E923FF              <1> 	jmp .check_for_more
   638                              <1> 
   639                              <1> 
   640                              <1> .second_is_string:				; These are "X = word" functions
   641 00002F47 BF007B              <1> 	mov di, token
   642                              <1> 	
   643 00002F4A BE[D645]            <1> 	mov si, ink_keyword
   644 00002F4D E8FDF8              <1> 	call os_string_compare
   645 00002F50 742A                <1> 	je .is_ink
   646                              <1> 	
   647 00002F52 BE[DA45]            <1> 	mov si, progstart_keyword
   648 00002F55 E8F5F8              <1> 	call os_string_compare
   649 00002F58 7433                <1> 	je .is_progstart
   650                              <1> 
   651 00002F5A BE[E445]            <1> 	mov si, ramstart_keyword
   652 00002F5D E8EDF8              <1> 	call os_string_compare
   653 00002F60 743A                <1> 	je .is_ramstart
   654                              <1> 
   655 00002F62 BE[ED45]            <1> 	mov si, timer_keyword
   656 00002F65 E8E5F8              <1> 	call os_string_compare
   657 00002F68 7444                <1> 	je .is_timer
   658                              <1> 	
   659 00002F6A BE[F345]            <1> 	mov si, variables_keyword
   660 00002F6D E8DDF8              <1> 	call os_string_compare
   661 00002F70 744E                <1> 	je .is_variables
   662                              <1> 	
   663 00002F72 BE[FD45]            <1> 	mov si, version_keyword
   664 00002F75 E8D5F8              <1> 	call os_string_compare
   665 00002F78 7454                <1> 	je .is_version
   666                              <1> 
   667 00002F7A EB61                <1> 	jmp .error
   668                              <1> 
   669                              <1> 
   670                              <1> .is_ink:
   671 00002F7C 0FB606[E22F]        <1> 	movzx ax, byte [.tmp]
   672                              <1> 	
   673 00002F81 31C0                <1> 	xor ax, ax
   674 00002F83 8A1E[9744]          <1> 	mov byte bl, [ink_colour]
   675 00002F87 E87613              <1> 	call set_var
   676                              <1> 	
   677 00002F8A E960FB              <1> 	jmp mainloop
   678                              <1> 
   679                              <1> 
   680                              <1> .is_progstart:
   681 00002F8D 0FB606[E22F]        <1> 	movzx ax, byte [.tmp]
   682                              <1> 
   683 00002F92 8B1E[9244]          <1> 	mov word bx, [load_point]
   684 00002F96 E86713              <1> 	call set_var
   685                              <1> 
   686 00002F99 E951FB              <1> 	jmp mainloop
   687                              <1> 
   688                              <1> 
   689                              <1> .is_ramstart:
   690 00002F9C 31C0                <1> 	xor ax, ax
   691 00002F9E A0[E22F]            <1> 	mov byte al, [.tmp]
   692                              <1> 
   693 00002FA1 8B1E[9044]          <1> 	mov word bx, [prog_end]
   694 00002FA5 43                  <1> 	inc bx
   695 00002FA6 43                  <1> 	inc bx
   696 00002FA7 43                  <1> 	inc bx
   697 00002FA8 E85513              <1> 	call set_var
   698                              <1> 
   699 00002FAB E93FFB              <1> 	jmp mainloop
   700                              <1> 
   701                              <1> 
   702                              <1> .is_timer:
   703                              <1> 	clr ah
    31 00002FAE 30E4                <2>  xor %1, %1
   704 00002FB0 E8D6E5              <1> 	call os_int_1Ah
   705 00002FB3 89D3                <1> 	mov bx, dx
   706                              <1> 
   707 00002FB5 31C0                <1> 	xor ax, ax
   708 00002FB7 A0[E22F]            <1> 	mov byte al, [.tmp]
   709 00002FBA E84313              <1> 	call set_var
   710                              <1> 
   711 00002FBD E92DFB              <1> 	jmp mainloop
   712                              <1> 
   713                              <1> 
   714                              <1> .is_variables:
   715 00002FC0 BB[9544]            <1> 	mov bx, vars_loc
   716 00002FC3 31C0                <1> 	xor ax, ax
   717 00002FC5 A0[E22F]            <1> 	mov byte al, [.tmp]
   718 00002FC8 E83513              <1> 	call set_var
   719                              <1> 
   720 00002FCB E91FFB              <1> 	jmp mainloop
   721                              <1> 
   722                              <1> 
   723                              <1> .is_version:
   724 00002FCE B0FF                <1> 	mov al, 255
   725                              <1> 	
   726                              <1> 	clr bh
    31 00002FD0 30FF                <2>  xor %1, %1
   727 00002FD2 88C3                <1> 	mov bl, al
   728 00002FD4 A0[E22F]            <1> 	mov al, [.tmp]
   729 00002FD7 E82613              <1> 	call set_var
   730                              <1> 	
   731 00002FDA E910FB              <1> 	jmp mainloop 
   732                              <1> 
   733                              <1> 
   734                              <1> .error:
   735 00002FDD B314                <1> 	mov bl, err_syntax
   736 00002FDF E94614              <1> 	jmp error
   737                              <1> 
   738                              <1> 
   739 00002FE2 00                  <1> 	.tmp		db 0
   740 00002FE3 0000                <1> 	.tmp_loc	dw 0
   741 00002FE5 00                  <1> 	.delim		db 0
   742                              <1> 
   743                              <1> 
   744                              <1> ; ==================================================================
   745                              <1> ; SPECIFIC COMMAND CODE STARTS HERE
   746                              <1> 
   747                              <1> ; ------------------------------------------------------------------
   748                              <1> ; ALERT
   749                              <1> 
   750                              <1> do_alert:
   751 00002FE6 8A3E[9844]          <1> 	mov bh, [work_page]			; Store the cursor position
   752 00002FEA B403                <1> 	mov ah, 03h
   753 00002FEC CD10                <1> 	int 10h
   754                              <1> 
   755 00002FEE E81E13              <1> 	call get_token
   756                              <1> 
   757 00002FF1 83F805              <1> 	cmp ax, QUOTE
   758 00002FF4 7416                <1> 	je .is_quote
   759                              <1> 	
   760 00002FF6 83F802              <1> 	cmp ax, STRING_VAR
   761 00002FF9 7405                <1> 	je .is_string
   762                              <1> 
   763 00002FFB B314                <1> 	mov bl, err_syntax
   764 00002FFD E92814              <1> 	jmp error
   765                              <1> 
   766                              <1> .is_string:
   767 00003000 BE007C              <1> 	mov si, string_vars
   768 00003003 B88000              <1> 	mov ax, 128
   769 00003006 F7E3                <1> 	mul bx
   770 00003008 01F0                <1> 	add ax, si
   771 0000300A EB03                <1> 	jmp .display_message
   772                              <1> 	
   773                              <1> .is_quote:
   774 0000300C B8007B              <1> 	mov ax, token				; First string for alert box
   775                              <1> 	
   776                              <1> .display_message:
   777 0000300F 31DB                <1> 	xor bx, bx				; Others are blank
   778 00003011 31C9                <1> 	xor cx, cx
   779 00003013 31D2                <1> 	xor dx, dx				; One-choice box
   780 00003015 E83CEF              <1> 	call os_dialog_box
   781                              <1> 	
   782 00003018 8A3E[9844]          <1> 	mov bh, [work_page]			; Move the cursor back
   783 0000301C B402                <1> 	mov ah, 02h
   784 0000301E CD10                <1> 	int 10h
   785                              <1> 	
   786 00003020 E9CAFA              <1> 	jmp mainloop
   787                              <1> 
   788                              <1> 
   789                              <1> ;-------------------------------------------------------------------
   790                              <1> ; ASKFILE
   791                              <1> 
   792                              <1> do_askfile:
   793 00003023 8A3E[9844]          <1> 	mov bh, [work_page]			; Store the cursor position
   794 00003027 B403                <1> 	mov ah, 03h
   795 00003029 CD10                <1> 	int 10h
   796                              <1> 	
   797 0000302B E8E112              <1> 	call get_token
   798                              <1> 	
   799 0000302E 83F802              <1> 	cmp ax, STRING_VAR
   800 00003031 7524                <1> 	jne .error
   801                              <1> 	
   802 00003033 BE007C              <1> 	mov si, string_vars			; Get the string location
   803 00003036 B88000              <1> 	mov ax, 128
   804 00003039 F7E3                <1> 	mul bx
   805 0000303B 01F0                <1> 	add ax, si
   806 0000303D A3[5C30]            <1> 	mov word [.tmp], ax
   807                              <1> 	
   808 00003040 E85AE7              <1> 	call os_file_selector			; Present the selector
   809                              <1> 	
   810 00003043 8B3E[5C30]          <1> 	mov word di, [.tmp]			; Copy the string
   811 00003047 89C6                <1> 	mov si, ax
   812 00003049 E8A4F7              <1> 	call os_string_copy
   813                              <1> 
   814 0000304C 8A3E[9844]          <1> 	mov bh, [work_page]			; Move the cursor back
   815 00003050 B402                <1> 	mov ah, 02h
   816 00003052 CD10                <1> 	int 10h
   817                              <1> 	
   818 00003054 E996FA              <1> 	jmp mainloop
   819                              <1> 	
   820                              <1> .error:
   821 00003057 B314                <1> 	mov bl, err_syntax
   822 00003059 E9CC13              <1> 	jmp error
   823                              <1> 
   824                              <1> .data:
   825 0000305C 0000                <1> 	.tmp					dw 0
   826                              <1> 
   827                              <1> 
   828                              <1> ; ------------------------------------------------------------------
   829                              <1> ; BREAK
   830                              <1> 
   831                              <1> do_break:
   832 0000305E B3[76]              <1> 	mov bl, err_break
   833 00003060 E9C513              <1> 	jmp error
   834                              <1> 
   835                              <1> 
   836                              <1> ; ------------------------------------------------------------------
   837                              <1> ; CALL
   838                              <1> 
   839                              <1> do_call:
   840 00003063 E8A912              <1> 	call get_token
   841 00003066 83F803              <1> 	cmp ax, NUMBER
   842 00003069 740A                <1> 	je .is_number
   843                              <1> 
   844 0000306B 31C0                <1> 	xor ax, ax
   845 0000306D A0007B              <1> 	mov byte al, [token]
   846 00003070 E88012              <1> 	call get_var
   847 00003073 EB06                <1> 	jmp .execute_call
   848                              <1> 
   849                              <1> .is_number:
   850 00003075 BE007B              <1> 	mov si, token
   851 00003078 E826F8              <1> 	call os_string_to_int
   852                              <1> 
   853                              <1> .execute_call:
   854 0000307B 31DB                <1> 	xor bx, bx
   855 0000307D 31C9                <1> 	xor cx, cx
   856 0000307F 31D2                <1> 	xor dx, dx
   857 00003081 31FF                <1> 	xor di, di
   858 00003083 31F6                <1> 	xor si, si
   859                              <1> 
   860 00003085 FFD0                <1> 	call ax
   861                              <1> 
   862 00003087 E963FA              <1> 	jmp mainloop
   863                              <1> 
   864                              <1> 
   865                              <1> ; ------------------------------------------------------------------
   866                              <1> ; CASE
   867                              <1> 
   868                              <1> do_case:
   869 0000308A E88212              <1> 	call get_token
   870 0000308D 83F804              <1> 	cmp ax, STRING
   871 00003090 7545                <1> 	jne .error
   872                              <1> 	
   873 00003092 BE007B              <1> 	mov si, token
   874                              <1> 
   875 00003095 BF[D045]            <1> 	mov di, upper_keyword
   876 00003098 E8B2F7              <1> 	call os_string_compare
   877 0000309B 720A                <1> 	jc .uppercase
   878                              <1> 	
   879 0000309D BF[CA45]            <1> 	mov di, lower_keyword
   880 000030A0 E8AAF7              <1> 	call os_string_compare
   881 000030A3 721A                <1> 	jc .lowercase
   882                              <1> 	
   883 000030A5 EB30                <1> 	jmp .error
   884                              <1> 	
   885                              <1> .uppercase:
   886 000030A7 E86512              <1> 	call get_token
   887 000030AA 83F802              <1> 	cmp ax, STRING_VAR
   888 000030AD 7528                <1> 	jne .error
   889                              <1> 	
   890 000030AF BE007C              <1> 	mov si, string_vars
   891 000030B2 B88000              <1> 	mov ax, 128
   892 000030B5 F7E3                <1> 	mul bx
   893 000030B7 01F0                <1> 	add ax, si
   894                              <1> 	
   895 000030B9 E8FAF6              <1> 	call os_string_uppercase
   896                              <1> 	
   897 000030BC E92EFA              <1> 	jmp mainloop
   898                              <1> 	
   899                              <1> .lowercase:
   900 000030BF E84D12              <1> 	call get_token
   901 000030C2 83F802              <1> 	cmp ax, STRING_VAR
   902 000030C5 7510                <1> 	jne .error
   903                              <1> 	
   904 000030C7 BE007C              <1> 	mov si, string_vars
   905 000030CA B88000              <1> 	mov ax, 128
   906 000030CD F7E3                <1> 	mul bx
   907 000030CF 01F0                <1> 	add ax, si
   908                              <1> 	
   909 000030D1 E8FFF6              <1> 	call os_string_lowercase
   910                              <1> 	
   911 000030D4 E916FA              <1> 	jmp mainloop
   912                              <1> 	
   913                              <1> .error:
   914 000030D7 B314                <1> 	mov bl, err_syntax
   915 000030D9 E94C13              <1> 	jmp error
   916                              <1> 
   917                              <1> 
   918                              <1> ; ------------------------------------------------------------------
   919                              <1> ; CLS
   920                              <1> 
   921                              <1> do_cls:
   922 000030DC B405                <1> 	mov ah, 5
   923 000030DE A0[9844]            <1> 	mov byte al, [work_page]
   924 000030E1 CD10                <1> 	int 10h
   925                              <1> 
   926 000030E3 E857E6              <1> 	call os_clear_screen
   927                              <1> 
   928 000030E6 B405                <1> 	mov ah, 5
   929 000030E8 A0[9944]            <1> 	mov byte al, [disp_page]
   930 000030EB CD10                <1> 	int 10h
   931                              <1> 
   932 000030ED E9FDF9              <1> 	jmp mainloop
   933                              <1> 
   934                              <1> 
   935                              <1> 
   936                              <1> ; ------------------------------------------------------------------
   937                              <1> ; CURSOR
   938                              <1> 
   939                              <1> do_cursor:
   940 000030F0 E81C12              <1> 	call get_token
   941                              <1> 
   942 000030F3 BE007B              <1> 	mov si, token
   943 000030F6 BF[1A31]            <1> 	mov di, .on_str
   944 000030F9 E851F7              <1> 	call os_string_compare
   945 000030FC 7210                <1> 	jc .turn_on
   946                              <1> 
   947 000030FE BE007B              <1> 	mov si, token
   948 00003101 BF[1D31]            <1> 	mov di, .off_str
   949 00003104 E846F7              <1> 	call os_string_compare
   950 00003107 720B                <1> 	jc .turn_off
   951                              <1> 
   952 00003109 B314                <1> 	mov bl, err_syntax
   953 0000310B E91A13              <1> 	jmp error
   954                              <1> 
   955                              <1> .turn_on:
   956 0000310E E85FE6              <1> 	call os_show_cursor
   957 00003111 E9D9F9              <1> 	jmp mainloop
   958                              <1> 
   959                              <1> .turn_off:
   960 00003114 E864E6              <1> 	call os_hide_cursor
   961 00003117 E9D3F9              <1> 	jmp mainloop
   962                              <1> 
   963                              <1> 
   964 0000311A 4F4E00              <1> 	.on_str db "ON", 0
   965 0000311D 4F464600            <1> 	.off_str db "OFF", 0
   966                              <1> 
   967                              <1> 
   968                              <1> ; ------------------------------------------------------------------
   969                              <1> ; CURSCHAR
   970                              <1> 
   971                              <1> do_curschar:
   972 00003121 E8EB11              <1> 	call get_token
   973                              <1> 
   974 00003124 83F801              <1> 	cmp ax, VARIABLE
   975 00003127 7405                <1> 	je .is_variable
   976                              <1> 
   977 00003129 B314                <1> 	mov bl, err_syntax
   978 0000312B E9FA12              <1> 	jmp error
   979                              <1> 
   980                              <1> .is_variable:
   981 0000312E 31C0                <1> 	xor ax, ax
   982 00003130 A0007B              <1> 	mov byte al, [token]
   983                              <1> 
   984 00003133 50                  <1> 	push ax				; Store variable we're going to use
   985                              <1> 
   986 00003134 B408                <1> 	mov ah, 08h
   987 00003136 31DB                <1> 	xor bx, bx
   988 00003138 8A3E[9844]          <1> 	mov byte bh, [work_page]
   989 0000313C CD10                <1> 	int 10h				; Get char at current cursor location
   990                              <1> 
   991 0000313E 31DB                <1> 	xor bx, bx			; We only want the lower byte (the char, not attribute)
   992 00003140 88C3                <1> 	mov bl, al
   993                              <1> 
   994 00003142 58                  <1> 	pop ax				; Get the variable back
   995                              <1> 
   996 00003143 E8BA11              <1> 	call set_var			; And store the value
   997                              <1> 
   998 00003146 E9A4F9              <1> 	jmp mainloop
   999                              <1> 
  1000                              <1> 
  1001                              <1> ; ------------------------------------------------------------------
  1002                              <1> ; CURSCOL
  1003                              <1> 
  1004                              <1> do_curscol:
  1005 00003149 E8C311              <1> 	call get_token
  1006                              <1> 
  1007 0000314C 83F801              <1> 	cmp ax, VARIABLE
  1008 0000314F 751B                <1> 	jne .error
  1009                              <1> 
  1010                              <1> 	clr ah
    31 00003151 30E4                <2>  xor %1, %1
  1011 00003153 A0007B              <1> 	mov byte al, [token]
  1012 00003156 50                  <1> 	push ax
  1013                              <1> 
  1014 00003157 B408                <1> 	mov ah, 8
  1015 00003159 31DB                <1> 	xor bx, bx
  1016 0000315B 8A3E[9844]          <1> 	mov byte bh, [work_page]
  1017 0000315F CD10                <1> 	int 10h
  1018                              <1> 	clr bh
    31 00003161 30FF                <2>  xor %1, %1
  1019 00003163 88E3                <1> 	mov bl, ah			; Get colour for higher byte; ignore lower byte (char)
  1020                              <1> 
  1021 00003165 58                  <1> 	pop ax
  1022 00003166 E89711              <1> 	call set_var
  1023                              <1> 
  1024 00003169 E981F9              <1> 	jmp mainloop
  1025                              <1> 
  1026                              <1> .error:
  1027 0000316C B314                <1> 	mov bl, err_syntax
  1028 0000316E E9B712              <1> 	jmp error
  1029                              <1> 
  1030                              <1> 
  1031                              <1> ; ------------------------------------------------------------------
  1032                              <1> ; CURSPOS
  1033                              <1> 
  1034                              <1> do_curspos:
  1035 00003171 8A3E[9844]          <1> 	mov byte bh, [work_page]
  1036 00003175 B403                <1> 	mov ah, 3
  1037 00003177 CD10                <1> 	int 10h
  1038                              <1> 
  1039 00003179 E89311              <1> 	call get_token
  1040 0000317C 83F801              <1> 	cmp ax, VARIABLE
  1041 0000317F 7523                <1> 	jne .error
  1042                              <1> 
  1043 00003181 0FB606007B          <1> 	movzx ax, byte [token]
  1044 00003186 31DB                <1> 	xor bx, bx
  1045 00003188 88D3                <1> 	mov bl, dl
  1046 0000318A E87311              <1> 	call set_var
  1047                              <1> 
  1048 0000318D E87F11              <1> 	call get_token
  1049 00003190 83F801              <1> 	cmp ax, VARIABLE
  1050 00003193 750F                <1> 	jne .error
  1051                              <1> 
  1052 00003195 0FB606007B          <1> 	movzx ax, byte [token]
  1053 0000319A 31DB                <1> 	xor bx, bx
  1054 0000319C 88F3                <1> 	mov bl, dh
  1055 0000319E E85F11              <1> 	call set_var
  1056                              <1> 
  1057 000031A1 E949F9              <1> 	jmp mainloop
  1058                              <1> 
  1059                              <1> .error:
  1060 000031A4 B314                <1> 	mov bl, err_syntax
  1061 000031A6 E97F12              <1> 	jmp error
  1062                              <1> 
  1063                              <1> 
  1064                              <1> ; ------------------------------------------------------------------
  1065                              <1> ; DELETE
  1066                              <1> 
  1067                              <1> do_delete:
  1068 000031A9 E86311              <1> 	call get_token
  1069 000031AC 83F805              <1> 	cmp ax, QUOTE
  1070 000031AF 7411                <1> 	je .is_quote
  1071                              <1> 
  1072 000031B1 83F802              <1> 	cmp ax, STRING_VAR
  1073 000031B4 7543                <1> 	jne .error
  1074                              <1> 
  1075 000031B6 BE007C              <1> 	mov si, string_vars
  1076 000031B9 B88000              <1> 	mov ax, 128
  1077 000031BC F7E3                <1> 	mul bx
  1078 000031BE 01C6                <1> 	add si, ax
  1079 000031C0 EB03                <1> 	jmp .get_filename
  1080                              <1> 
  1081                              <1> .is_quote:
  1082 000031C2 BE007B              <1> 	mov si, token
  1083                              <1> 
  1084                              <1> .get_filename:
  1085 000031C5 89F0                <1> 	mov ax, si
  1086 000031C7 E8FCDB              <1> 	call os_file_exists
  1087 000031CA 7207                <1> 	jc .no_file
  1088                              <1> 
  1089 000031CC E8E3DC              <1> 	call os_remove_file
  1090 000031CF 721B                <1> 	jc .del_fail
  1091                              <1> 
  1092 000031D1 EB0D                <1> 	jmp .returngood
  1093                              <1> 
  1094                              <1> .no_file:
  1095 000031D3 31C0                <1> 	xor ax, ax
  1096 000031D5 B052                <1> 	mov byte al, 'R'
  1097 000031D7 BB0200              <1> 	mov bx, 2
  1098 000031DA E82311              <1> 	call set_var
  1099 000031DD E90DF9              <1> 	jmp mainloop
  1100                              <1> 
  1101                              <1> .returngood:
  1102 000031E0 31C0                <1> 	xor ax, ax
  1103 000031E2 B052                <1> 	mov byte al, 'R'
  1104 000031E4 31DB                <1> 	xor bx, bx
  1105 000031E6 E81711              <1> 	call set_var
  1106 000031E9 E901F9              <1> 	jmp mainloop
  1107                              <1> 
  1108                              <1> .del_fail:
  1109 000031EC 31C0                <1> 	xor ax, ax
  1110 000031EE B052                <1> 	mov byte al, 'R'
  1111 000031F0 BB0100              <1> 	mov bx, 1
  1112 000031F3 E80A11              <1> 	call set_var
  1113 000031F6 E9F4F8              <1> 	jmp mainloop
  1114                              <1> 
  1115                              <1> .error:
  1116 000031F9 B314                <1> 	mov bl, err_syntax
  1117 000031FB E92A12              <1> 	jmp error
  1118                              <1> 	
  1119                              <1> 
  1120                              <1> ; ------------------------------------------------------------------
  1121                              <1> ; DO
  1122                              <1> 
  1123                              <1> do_do:
  1124 000031FE 803E[9544]14        <1> 	cmp byte [loop_in], 20
  1125 00003203 741C                <1> 	je .loop_max
  1126 00003205 BFD079              <1> 	mov word di, do_loop_store
  1127 00003208 A0[9544]            <1> 	mov byte al, [loop_in]
  1128                              <1> 	clr ah
    31 0000320B 30E4                <2>  xor %1, %1
  1129 0000320D 01C7                <1> 	add di, ax
  1130 0000320F A1[8E44]            <1> 	mov word ax, [prog]
  1131 00003212 83E803              <1> 	sub ax, 3
  1132 00003215 AB                  <1> 	stosw
  1133 00003216 FE06[9544]          <1> 	inc byte [loop_in]
  1134 0000321A FE06[9544]          <1> 	inc byte [loop_in]
  1135 0000321E E9CCF8              <1> 	jmp mainloop
  1136                              <1> 
  1137                              <1> .loop_max:
  1138 00003221 B303                <1> 	mov bl, err_doloop_maximum
  1139 00003223 E90212              <1> 	jmp error
  1140                              <1> 
  1141                              <1> 	
  1142                              <1> ;-------------------------------------------------------------------
  1143                              <1> ; ELSE
  1144                              <1> 
  1145                              <1> do_else:
  1146 00003226 803E[9644]01        <1> 	cmp byte [last_if_true], 1
  1147 0000322B 7407                <1> 	je .last_true
  1148                              <1> 	
  1149 0000322D FF06[8E44]          <1> 	inc word [prog]
  1150 00003231 E9B9F8              <1> 	jmp mainloop
  1151                              <1> 	
  1152                              <1> .last_true:
  1153 00003234 8B36[8E44]          <1> 	mov word si, [prog]
  1154                              <1> 	
  1155                              <1> .next_line:
  1156 00003238 AC                  <1> 	lodsb
  1157 00003239 3C0A                <1> 	cmp al, 10
  1158 0000323B 75FB                <1> 	jne .next_line
  1159                              <1> 	
  1160 0000323D 4E                  <1> 	dec si
  1161 0000323E 8936[8E44]          <1> 	mov word [prog], si
  1162                              <1> 	
  1163 00003242 E9A8F8              <1> 	jmp mainloop
  1164                              <1> 
  1165                              <1> 
  1166                              <1> ; ------------------------------------------------------------------
  1167                              <1> ; END
  1168                              <1> 
  1169                              <1> do_end:
  1170 00003245 B405                <1> 	mov ah, 5				; Restore active page
  1171                              <1> 	clr al
    31 00003247 30C0                <2>  xor %1, %1
  1172 00003249 CD10                <1> 	int 10h
  1173                              <1> 
  1174 0000324B C606[9844]00        <1> 	mov byte [work_page], 0
  1175 00003250 C606[9944]00        <1> 	mov byte [disp_page], 0
  1176                              <1> 
  1177 00003255 8B26[8C44]          <1> 	mov word sp, [orig_stack]
  1178 00003259 C3                  <1> 	ret
  1179                              <1> 
  1180                              <1> 
  1181                              <1> ; ------------------------------------------------------------------
  1182                              <1> ; FILES
  1183                              <1> 
  1184                              <1> do_files:
  1185 0000325A B800FA              <1> 	mov ax, .filelist			; get a copy of the filelist
  1186 0000325D E8F9D7              <1> 	call os_get_file_list
  1187                              <1> 	
  1188 00003260 89C6                <1> 	mov si, ax
  1189                              <1> 
  1190 00003262 E8FCE4              <1> 	call os_get_cursor_pos			; move cursor to start of line
  1191                              <1> 	clr dl
    31 00003265 30D2                <2>  xor %1, %1
  1192 00003267 E8EEE4              <1> 	call os_move_cursor
  1193                              <1> 	
  1194 0000326A B409                <1> 	mov ah, 9				; print character function
  1195 0000326C 8A3E[9844]          <1> 	mov bh, [work_page]			; define parameters (page, colour, times)
  1196 00003270 8A1E[9744]          <1> 	mov bl, [ink_colour]
  1197 00003274 B90100              <1> 	mov cx, 1
  1198                              <1> .file_list_loop:
  1199 00003277 AC                  <1> 	lodsb					; get a byte from the list
  1200 00003278 3C2C                <1> 	cmp al, ','				; a comma means the next file, so create a new line for it
  1201 0000327A 7410                <1> 	je .nextfile
  1202                              <1> 	
  1203 0000327C 84C0                <1> 	test al, al				; the list is null terminated
  1204 0000327E 7438                <1> 	jz .end_of_list
  1205                              <1> 	
  1206 00003280 CD10                <1> 	int 10h					; okay, it's not a comma or a null so print it
  1207                              <1> 
  1208 00003282 E8DCE4              <1> 	call os_get_cursor_pos			; find the location of the cursor
  1209 00003285 FEC2                <1> 	inc dl					; move the cursor forward
  1210 00003287 E8CEE4              <1> 	call os_move_cursor
  1211                              <1> 
  1212 0000328A EBEB                <1> 	jmp .file_list_loop			; keep going until the list is finished
  1213                              <1> 	
  1214                              <1> .nextfile:
  1215 0000328C E8D2E4              <1> 	call os_get_cursor_pos			; if the column is over 60 we need a new line
  1216 0000328F 80FA3C              <1> 	cmp dl, 60
  1217 00003292 7D1F                <1> 	jge .newline
  1218                              <1> 
  1219                              <1> .next_column:					; print spaces until the next column
  1220 00003294 B020                <1> 	mov al, ' '
  1221 00003296 CD10                <1> 	int 10h
  1222                              <1> 	
  1223 00003298 FEC2                <1> 	inc dl
  1224 0000329A E8BBE4              <1> 	call os_move_cursor
  1225                              <1> 	
  1226 0000329D 80FA0F              <1> 	cmp dl, 15
  1227 000032A0 74D5                <1> 	je .file_list_loop
  1228                              <1> 	
  1229 000032A2 80FA1E              <1> 	cmp dl, 30
  1230 000032A5 74D0                <1> 	je .file_list_loop
  1231                              <1> 	
  1232 000032A7 80FA2D              <1> 	cmp dl, 45
  1233 000032AA 74CB                <1> 	je .file_list_loop
  1234                              <1> 	
  1235 000032AC 80FA3C              <1> 	cmp dl, 60
  1236 000032AF 74C6                <1> 	je .file_list_loop
  1237                              <1> 	
  1238 000032B1 EBE1                <1> 	jmp .next_column
  1239                              <1> 	
  1240                              <1> .newline:
  1241 000032B3 E89CEB              <1> 	call os_print_newline			; create a new line
  1242 000032B6 EBBF                <1> 	jmp .file_list_loop
  1243                              <1> 	
  1244                              <1> .end_of_list:
  1245 000032B8 E897EB              <1> 	call os_print_newline
  1246 000032BB E92FF8              <1> 	jmp mainloop				; preform next command
  1247                              <1> 	
  1248                              <1> .data:
  1249                              <1> 	.filelist		equ 64000
  1250                              <1> 	
  1251                              <1> 
  1252                              <1> 
  1253                              <1> ; ------------------------------------------------------------------
  1254                              <1> ; FOR
  1255                              <1> 
  1256                              <1> do_for:
  1257 000032BE E84E10              <1> 	call get_token				; Get the variable we're using in this loop
  1258                              <1> 
  1259 000032C1 83F801              <1> 	cmp ax, VARIABLE
  1260 000032C4 0F859B00            <1> 	jne .error
  1261                              <1> 
  1262 000032C8 0FB606007B          <1> 	movzx ax, byte [token]
  1263 000032CD A2[6833]            <1> 	mov byte [.tmp_var], al			; Store it in a temporary location for now
  1264                              <1> 
  1265 000032D0 E83C10              <1> 	call get_token
  1266                              <1> 
  1267 000032D3 0FB606007B          <1> 	movzx ax, byte [token]
  1268 000032D8 3C3D                <1> 	cmp al, '='
  1269 000032DA 0F858500            <1> 	jne .error
  1270                              <1> 
  1271 000032DE E82E10              <1> 	call get_token				; Next we want a number
  1272                              <1> 
  1273 000032E1 83F801              <1> 	cmp ax, VARIABLE
  1274 000032E4 740D                <1> 	je .first_is_var
  1275                              <1> 
  1276 000032E6 83F803              <1> 	cmp ax, NUMBER
  1277 000032E9 7578                <1> 	jne .error
  1278                              <1> 
  1279 000032EB BE007B              <1> 	mov si, token				; Convert it
  1280 000032EE E8B0F5              <1> 	call os_string_to_int
  1281 000032F1 EB08                <1> 	jmp .continue
  1282                              <1> 
  1283                              <1> .first_is_var:
  1284 000032F3 0FB606007B          <1> 	movzx ax, byte [token]
  1285 000032F8 E8F80F              <1> 	call get_var
  1286                              <1> 	
  1287                              <1> 	; At this stage, we've read something like "FOR X = 1"
  1288                              <1> 	; so let's store that 1 in the variable table
  1289                              <1> 
  1290                              <1> .continue:
  1291 000032FB 89C3                <1> 	mov bx, ax
  1292 000032FD 0FB606[6833]        <1> 	movzx ax, byte [.tmp_var]
  1293 00003302 E8FB0F              <1> 	call set_var
  1294                              <1> 
  1295                              <1> 
  1296 00003305 E80710              <1> 	call get_token				; Next we're looking for "TO"
  1297                              <1> 
  1298 00003308 83F804              <1> 	cmp ax, STRING
  1299 0000330B 7556                <1> 	jne .error
  1300                              <1> 
  1301 0000330D B8007B              <1> 	mov ax, token
  1302 00003310 E8A3F4              <1> 	call os_string_uppercase
  1303                              <1> 
  1304 00003313 BE007B              <1> 	mov si, token
  1305 00003316 BF[6933]            <1> 	mov di, .to_string
  1306 00003319 E831F5              <1> 	call os_string_compare
  1307 0000331C 7345                <1> 	jnc .error
  1308                              <1> 
  1309                              <1> 
  1310                              <1> 	; So now we're at "FOR X = 1 TO"
  1311                              <1> 
  1312 0000331E E8EE0F              <1> 	call get_token
  1313                              <1> 
  1314 00003321 83F801              <1> 	cmp ax, VARIABLE
  1315 00003324 740D                <1> 	je .second_is_var
  1316                              <1> 
  1317 00003326 83F803              <1> 	cmp ax, NUMBER
  1318 00003329 7538                <1> 	jne .error
  1319                              <1> 
  1320                              <1> .second_is_number:
  1321 0000332B BE007B              <1> 	mov si, token					; Get target number
  1322 0000332E E870F5              <1> 	call os_string_to_int
  1323 00003331 EB08                <1> 	jmp .continue2
  1324                              <1> 
  1325                              <1> .second_is_var:
  1326 00003333 0FB606007B          <1> 	movzx ax, byte [token]
  1327 00003338 E8B80F              <1> 	call get_var
  1328                              <1> 
  1329                              <1> .continue2:
  1330 0000333B 89C3                <1> 	mov bx, ax
  1331                              <1> 
  1332 0000333D 0FB606[6833]        <1> 	movzx ax, byte [.tmp_var]
  1333                              <1> 
  1334 00003342 2C41                <1> 	sub al, 65					; Store target number in table
  1335 00003344 BF187A              <1> 	mov di, for_variables
  1336 00003347 01C7                <1> 	add di, ax
  1337 00003349 01C7                <1> 	add di, ax
  1338 0000334B 89D8                <1> 	mov ax, bx
  1339 0000334D AB                  <1> 	stosw
  1340                              <1> 
  1341                              <1> 
  1342                              <1> 	; So we've got the variable, assigned it the starting number, and put into
  1343                              <1> 	; our table the limit it should reach. But we also need to store the point in
  1344                              <1> 	; code after the FOR line we should return to if NEXT X doesn't complete the loop...
  1345                              <1> 
  1346 0000334E 0FB606[6833]        <1> 	movzx ax, byte [.tmp_var]
  1347                              <1> 
  1348 00003353 2C41                <1> 	sub al, 65					; Store code position to return to in table
  1349 00003355 BFE479              <1> 	mov di, for_code_points
  1350 00003358 01C7                <1> 	add di, ax
  1351 0000335A 01C7                <1> 	add di, ax
  1352 0000335C A1[8E44]            <1> 	mov word ax, [prog]
  1353 0000335F AB                  <1> 	stosw
  1354                              <1> 
  1355 00003360 E98AF7              <1> 	jmp mainloop
  1356                              <1> 
  1357                              <1> 
  1358                              <1> .error:
  1359 00003363 B314                <1> 	mov bl, err_syntax
  1360 00003365 E9C010              <1> 	jmp error
  1361                              <1> 
  1362                              <1> 
  1363 00003368 00                  <1> 	.tmp_var	db 0
  1364 00003369 544F00              <1> 	.to_string	db 'TO', 0
  1365                              <1> 
  1366                              <1> 
  1367                              <1> ; ------------------------------------------------------------------
  1368                              <1> ; GETKEY
  1369                              <1> 
  1370                              <1> do_getkey:
  1371 0000336C E8A00F              <1> 	call get_token
  1372 0000336F 83F801              <1> 	cmp ax, VARIABLE
  1373 00003372 7405                <1> 	je .is_variable
  1374                              <1> 
  1375 00003374 B314                <1> 	mov bl, err_syntax
  1376 00003376 E9AF10              <1> 	jmp error
  1377                              <1> 
  1378                              <1> .is_variable:
  1379 00003379 0FB606007B          <1> 	movzx ax, byte [token]
  1380                              <1> 
  1381 0000337E 50                  <1> 	push ax
  1382                              <1> 
  1383 0000337F E8AADE              <1> 	call os_check_for_key
  1384                              <1> 
  1385 00003382 3DE048              <1> 	cmp ax, 48E0h
  1386 00003385 7419                <1> 	je .up_pressed
  1387                              <1> 
  1388 00003387 3DE050              <1> 	cmp ax, 50E0h
  1389 0000338A 7419                <1> 	je .down_pressed
  1390                              <1> 
  1391 0000338C 3DE04B              <1> 	cmp ax, 4BE0h
  1392 0000338F 7419                <1> 	je .left_pressed
  1393                              <1> 
  1394 00003391 3DE04D              <1> 	cmp ax, 4DE0h
  1395 00003394 7419                <1> 	je .right_pressed
  1396                              <1> 
  1397                              <1> .store:	
  1398 00003396 0FB6D8              <1> 	movzx bx, al
  1399                              <1> 	
  1400 00003399 58                  <1> 	pop ax
  1401                              <1> 
  1402 0000339A E8630F              <1> 	call set_var
  1403                              <1> 
  1404 0000339D E94DF7              <1> 	jmp mainloop
  1405                              <1> 
  1406                              <1> .up_pressed:
  1407 000033A0 B80100              <1> 	mov ax, 1
  1408 000033A3 EBF1                <1> 	jmp .store
  1409                              <1> 
  1410                              <1> .down_pressed:
  1411 000033A5 B80200              <1> 	mov ax, 2
  1412 000033A8 EBEC                <1> 	jmp .store
  1413                              <1> 
  1414                              <1> .left_pressed:
  1415 000033AA B80300              <1> 	mov ax, 3
  1416 000033AD EBE7                <1> 	jmp .store
  1417                              <1> 
  1418                              <1> .right_pressed:
  1419 000033AF B80400              <1> 	mov ax, 4
  1420 000033B2 EBE2                <1> 	jmp .store
  1421                              <1> 
  1422                              <1> ; ------------------------------------------------------------------
  1423                              <1> ; GOSUB
  1424                              <1> 
  1425                              <1> do_gosub:
  1426 000033B4 E8580F              <1> 	call get_token				; Get the number (label)
  1427                              <1> 
  1428 000033B7 83F804              <1> 	cmp ax, STRING
  1429 000033BA 7405                <1> 	je .is_ok
  1430                              <1> 
  1431 000033BC B305                <1> 	mov bl, err_goto_notlabel
  1432 000033BE E96710              <1> 	jmp error
  1433                              <1> 
  1434                              <1> .is_ok:
  1435 000033C1 BE007B              <1> 	mov si, token				; Back up this label
  1436 000033C4 BF[3334]            <1> 	mov di, .tmp_token
  1437 000033C7 E826F4              <1> 	call os_string_copy
  1438                              <1> 
  1439 000033CA B8[3334]            <1> 	mov ax, .tmp_token
  1440 000033CD E89BF3              <1> 	call os_string_length
  1441                              <1> 
  1442 000033D0 BF[3334]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  1443 000033D3 01C7                <1> 	add di, ax
  1444 000033D5 B03A                <1> 	mov al, ':'
  1445 000033D7 AA                  <1> 	stosb
  1446                              <1> 	clr al
    31 000033D8 30C0                <2>  xor %1, %1
  1447 000033DA AA                  <1> 	stosb	
  1448                              <1> 
  1449                              <1> 
  1450 000033DB FE06[0546]          <1> 	inc byte [gosub_depth]
  1451                              <1> 
  1452 000033DF 0FB606[0546]        <1> 	movzx ax, byte [gosub_depth]		; Get current GOSUB nest level
  1453                              <1> 
  1454 000033E4 3C09                <1> 	cmp al, 9
  1455 000033E6 7E05                <1> 	jle .within_limit
  1456                              <1> 
  1457 000033E8 B307                <1> 	mov bl, err_nest_limit
  1458 000033EA E93B10              <1> 	jmp error
  1459                              <1> 
  1460                              <1> 
  1461                              <1> .within_limit:
  1462 000033ED BFBC79              <1> 	mov di, gosub_points			; Move into our table of pointers
  1463 000033F0 01C7                <1> 	add di, ax				; Table is words (not bytes)
  1464 000033F2 01C7                <1> 	add di, ax
  1465 000033F4 A1[8E44]            <1> 	mov word ax, [prog]
  1466 000033F7 AB                  <1> 	stosw					; Store current location before jump
  1467                              <1> 
  1468                              <1> 
  1469 000033F8 A1[9244]            <1> 	mov word ax, [load_point]
  1470 000033FB A3[8E44]            <1> 	mov word [prog], ax			; Return to start of program to find label
  1471                              <1> 
  1472                              <1> .loop:
  1473 000033FE E80E0F              <1> 	call get_token
  1474                              <1> 
  1475 00003401 83F808              <1> 	cmp ax, LABEL
  1476 00003404 750D                <1> 	jne .line_loop
  1477                              <1> 
  1478 00003406 BE007B              <1> 	mov si, token
  1479 00003409 BF[3334]            <1> 	mov di, .tmp_token
  1480 0000340C E83EF4              <1> 	call os_string_compare
  1481 0000340F 0F82DAF6            <1> 	jc mainloop
  1482                              <1> 
  1483                              <1> 
  1484                              <1> .line_loop:					; Go to end of line
  1485 00003413 8B36[8E44]          <1> 	mov word si, [prog]
  1486 00003417 8A04                <1> 	mov byte al, [si]
  1487 00003419 FF06[8E44]          <1> 	inc word [prog]
  1488 0000341D 3C0A                <1> 	cmp al, 10
  1489 0000341F 75F2                <1> 	jne .line_loop
  1490                              <1> 
  1491 00003421 A1[8E44]            <1> 	mov word ax, [prog]
  1492 00003424 8B1E[9044]          <1> 	mov word bx, [prog_end]
  1493 00003428 39D8                <1> 	cmp ax, bx
  1494 0000342A 7F02                <1> 	jg .past_end
  1495                              <1> 
  1496 0000342C EBD0                <1> 	jmp .loop
  1497                              <1> 
  1498                              <1> 
  1499                              <1> .past_end:
  1500 0000342E B306                <1> 	mov bl, err_label_notfound
  1501 00003430 E9F50F              <1> 	jmp error
  1502                              <1> 
  1503                              <1> 
  1504 00003433 00<rep 1Eh>         <1> 	.tmp_token	times 30 db 0
  1505                              <1> 
  1506                              <1> 
  1507                              <1> ; ------------------------------------------------------------------
  1508                              <1> ; GOTO
  1509                              <1> 
  1510                              <1> do_goto:
  1511 00003451 E8BB0E              <1> 	call get_token				; Get the next token
  1512                              <1> 
  1513 00003454 83F804              <1> 	cmp ax, STRING
  1514 00003457 7405                <1> 	je .is_ok
  1515                              <1> 
  1516 00003459 B305                <1> 	mov bl, err_goto_notlabel
  1517 0000345B E9CA0F              <1> 	jmp error
  1518                              <1> 
  1519                              <1> .is_ok:
  1520 0000345E BE007B              <1> 	mov si, token				; Back up this label
  1521 00003461 BF[B334]            <1> 	mov di, .tmp_token
  1522 00003464 E889F3              <1> 	call os_string_copy
  1523                              <1> 
  1524 00003467 B8[B334]            <1> 	mov ax, .tmp_token
  1525 0000346A E8FEF2              <1> 	call os_string_length
  1526                              <1> 
  1527 0000346D BF[B334]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  1528 00003470 01C7                <1> 	add di, ax
  1529 00003472 B03A                <1> 	mov al, ':'
  1530 00003474 AA                  <1> 	stosb
  1531                              <1> 	clr al
    31 00003475 30C0                <2>  xor %1, %1
  1532 00003477 AA                  <1> 	stosb	
  1533                              <1> 
  1534 00003478 A1[9244]            <1> 	mov word ax, [load_point]
  1535 0000347B A3[8E44]            <1> 	mov word [prog], ax			; Return to start of program to find label
  1536                              <1> 
  1537                              <1> .loop:
  1538 0000347E E88E0E              <1> 	call get_token
  1539                              <1> 
  1540 00003481 83F808              <1> 	cmp ax, LABEL
  1541 00003484 750D                <1> 	jne .line_loop
  1542                              <1> 
  1543 00003486 BE007B              <1> 	mov si, token
  1544 00003489 BF[B334]            <1> 	mov di, .tmp_token
  1545 0000348C E8BEF3              <1> 	call os_string_compare
  1546 0000348F 0F825AF6            <1> 	jc mainloop
  1547                              <1> 
  1548                              <1> .line_loop:					; Go to end of line
  1549 00003493 8B36[8E44]          <1> 	mov word si, [prog]
  1550 00003497 8A04                <1> 	mov byte al, [si]
  1551 00003499 FF06[8E44]          <1> 	inc word [prog]
  1552                              <1> 
  1553 0000349D 3C0A                <1> 	cmp al, 10
  1554 0000349F 75F2                <1> 	jne .line_loop
  1555                              <1> 
  1556 000034A1 A1[8E44]            <1> 	mov word ax, [prog]
  1557 000034A4 8B1E[9044]          <1> 	mov word bx, [prog_end]
  1558 000034A8 39D8                <1> 	cmp ax, bx
  1559 000034AA 7F02                <1> 	jg .past_end
  1560                              <1> 
  1561 000034AC EBD0                <1> 	jmp .loop
  1562                              <1> 
  1563                              <1> .past_end:
  1564 000034AE B306                <1> 	mov bl, err_label_notfound
  1565 000034B0 E9750F              <1> 	jmp error
  1566                              <1> 
  1567                              <1> 
  1568 000034B3 00<rep 1Eh>         <1> 	.tmp_token 	times 30 db 0
  1569                              <1> 
  1570                              <1> 
  1571                              <1> ; ------------------------------------------------------------------
  1572                              <1> ; IF
  1573                              <1> 
  1574                              <1> do_if:
  1575 000034D1 E83B0E              <1> 	call get_token
  1576                              <1> 
  1577 000034D4 83F801              <1> 	cmp ax, VARIABLE			; If can only be followed by a variable
  1578 000034D7 740C                <1> 	je .num_var
  1579                              <1> 
  1580 000034D9 83F802              <1> 	cmp ax, STRING_VAR
  1581 000034DC 0F847001            <1> 	je .string_var
  1582                              <1> 
  1583 000034E0 B314                <1> 	mov bl, err_syntax
  1584 000034E2 E9430F              <1> 	jmp error
  1585                              <1> 
  1586                              <1> .num_var:
  1587 000034E5 0FB606007B          <1> 	movzx ax, byte [token]
  1588 000034EA E8060E              <1> 	call get_var
  1589                              <1> 
  1590 000034ED 89C2                <1> 	mov dx, ax				; Store value of first part of comparison
  1591                              <1> 
  1592 000034EF E81D0E              <1> 	call get_token				; Get the delimiter
  1593 000034F2 A0007B              <1> 	mov byte al, [token]
  1594 000034F5 3C3D                <1> 	cmp al, '='
  1595 000034F7 7415                <1> 	je .equals
  1596 000034F9 3C3E                <1> 	cmp al, '>'
  1597 000034FB 0F849E00            <1> 	je .greater
  1598 000034FF 3C3C                <1> 	cmp al, '<'
  1599 00003501 0F84F500            <1> 	je .less
  1600 00003505 3C21                <1> 	cmp al, '!'
  1601 00003507 7443                <1> 	je .not_equals
  1602                              <1> 
  1603 00003509 B314                <1> 	mov bl, err_syntax			; If not one of the above, error out
  1604 0000350B E91A0F              <1> 	jmp error
  1605                              <1> 
  1606                              <1> .equals:
  1607 0000350E E8FE0D              <1> 	call get_token				; Is this 'X = Y' (equals another variable?)
  1608                              <1> 
  1609 00003511 83F806              <1> 	cmp ax, CHAR
  1610 00003514 7417                <1> 	je .equals_char
  1611                              <1> 
  1612 00003516 A0007B              <1> 	mov byte al, [token]
  1613 00003519 E8000F              <1> 	call is_letter
  1614 0000351C 721D                <1> 	jc .equals_var
  1615                              <1> 
  1616 0000351E BE007B              <1> 	mov si, token				; Otherwise it's, eg 'X = 1' (a number)
  1617 00003521 E87DF3              <1> 	call os_string_to_int
  1618                              <1> 
  1619 00003524 39D0                <1> 	cmp ax, dx				; On to the THEN bit if 'X = num' matches
  1620 00003526 0F847701            <1> 	je .on_to_then
  1621                              <1> 
  1622 0000352A E99C01              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  1623                              <1> 
  1624                              <1> 
  1625                              <1> .equals_char:
  1626 0000352D 0FB606007B          <1> 	movzx ax, byte [token]
  1627                              <1> 
  1628 00003532 39D0                <1> 	cmp ax, dx
  1629 00003534 0F846901            <1> 	je .on_to_then
  1630                              <1> 
  1631 00003538 E98E01              <1> 	jmp .finish_line
  1632                              <1> 
  1633                              <1> 
  1634                              <1> .equals_var:
  1635 0000353B 0FB606007B          <1> 	movzx ax, byte [token]
  1636                              <1> 
  1637 00003540 E8B00D              <1> 	call get_var
  1638                              <1> 
  1639 00003543 39D0                <1> 	cmp ax, dx				; Do the variables match?
  1640 00003545 0F845801            <1> 	je .on_to_then				; On to the THEN bit if so
  1641                              <1> 
  1642 00003549 E97D01              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  1643                              <1> 
  1644                              <1> .not_equals:
  1645 0000354C A0017B              <1> 	mov byte al, [token + 1]
  1646 0000354F 3C3D                <1> 	cmp al, '='
  1647 00003551 0F858A01            <1> 	jne .error
  1648                              <1> 
  1649 00003555 E8B70D              <1> 	call get_token
  1650                              <1> 
  1651 00003558 83F806              <1> 	cmp ax, CHAR
  1652 0000355B 7410                <1> 	je .not_equals_char
  1653                              <1> 
  1654 0000355D 83F801              <1> 	cmp ax, VARIABLE
  1655 00003560 741A                <1> 	je .not_equals_var
  1656                              <1> 
  1657 00003562 83F803              <1> 	cmp ax, NUMBER
  1658 00003565 7427                <1> 	je .not_equals_number
  1659                              <1> 
  1660 00003567 BE1400              <1> 	mov si, err_syntax
  1661 0000356A E9BB0E              <1> 	jmp error
  1662                              <1> 
  1663                              <1> .not_equals_char:
  1664 0000356D B80000              <1> 	mov ax, 0
  1665 00003570 A0007B              <1> 	mov byte al, [token]
  1666                              <1> 
  1667 00003573 39D0                <1> 	cmp ax, dx
  1668 00003575 0F852801            <1> 	jne near .on_to_then
  1669                              <1> 
  1670 00003579 E94D01              <1> 	jmp .finish_line
  1671                              <1> 
  1672                              <1> .not_equals_var:
  1673 0000357C B80000              <1> 	mov ax, 0
  1674 0000357F A0007B              <1> 	mov byte al, [token]
  1675                              <1> 
  1676 00003582 E86E0D              <1> 	call get_var
  1677                              <1> 
  1678 00003585 39D0                <1> 	cmp ax, dx
  1679 00003587 0F851601            <1> 	jne near .on_to_then
  1680                              <1> 
  1681 0000358B E93B01              <1> 	jmp .finish_line
  1682                              <1> 
  1683                              <1> .not_equals_number:
  1684 0000358E BE007B              <1> 	mov si, token
  1685 00003591 E80DF3              <1> 	call os_string_to_int
  1686                              <1> 
  1687 00003594 39D0                <1> 	cmp ax, dx
  1688 00003596 0F850701            <1> 	jne near .on_to_then
  1689                              <1> 
  1690 0000359A E92C01              <1> 	jmp .finish_line
  1691                              <1> 
  1692                              <1> 
  1693                              <1> .greater:
  1694 0000359D A0017B              <1> 	mov byte al, [token + 1]	; Greater than or equal?
  1695 000035A0 3C3D                <1> 	cmp al, '='
  1696 000035A2 742B                <1> 	je .greater_equal
  1697                              <1> 
  1698 000035A4 E8680D              <1> 	call get_token				; Greater than a variable or number?
  1699 000035A7 A0007B              <1> 	mov byte al, [token]
  1700 000035AA E86F0E              <1> 	call is_letter
  1701 000035AD 720F                <1> 	jc .greater_var
  1702                              <1> 
  1703 000035AF BE007B              <1> 	mov si, token				; Must be a number here...
  1704 000035B2 E8ECF2              <1> 	call os_string_to_int
  1705                              <1> 
  1706 000035B5 39D0                <1> 	cmp ax, dx
  1707 000035B7 0F8CE600            <1> 	jl .on_to_then
  1708                              <1> 
  1709 000035BB E90B01              <1> 	jmp .finish_line
  1710                              <1> 
  1711                              <1> .greater_var:					; Variable in this case
  1712 000035BE 0FB606007B          <1> 	movzx ax, byte [token]
  1713                              <1> 
  1714 000035C3 E82D0D              <1> 	call get_var
  1715                              <1> 
  1716 000035C6 39D0                <1> 	cmp ax, dx				; Make the comparison!
  1717 000035C8 0F8CD500            <1> 	jl .on_to_then
  1718                              <1> 
  1719 000035CC E9FA00              <1> 	jmp .finish_line
  1720                              <1> 
  1721                              <1> .greater_equal:
  1722 000035CF E83D0D              <1> 	call get_token				; Greater than a variable or number?
  1723 000035D2 A0007B              <1> 	mov byte al, [token]
  1724 000035D5 E8440E              <1> 	call is_letter
  1725 000035D8 720F                <1> 	jc .greater_equal_var
  1726                              <1> 
  1727 000035DA BE007B              <1> 	mov si, token				; Must be a number here...
  1728 000035DD E8C1F2              <1> 	call os_string_to_int
  1729                              <1> 
  1730 000035E0 39D0                <1> 	cmp ax, dx
  1731 000035E2 0F8EBB00            <1> 	jle .on_to_then
  1732                              <1> 
  1733 000035E6 E9E000              <1> 	jmp .finish_line
  1734                              <1> 
  1735                              <1> .greater_equal_var:					; Variable in this case
  1736 000035E9 0FB606007B          <1> 	movzx ax, byte [token]
  1737                              <1> 
  1738 000035EE E8020D              <1> 	call get_var
  1739                              <1> 
  1740 000035F1 39D0                <1> 	cmp ax, dx				; Make the comparison!
  1741 000035F3 0F8EAA00            <1> 	jle .on_to_then
  1742                              <1> 
  1743 000035F7 E9CF00              <1> 	jmp .finish_line
  1744                              <1> 
  1745                              <1> .less:
  1746 000035FA A0017B              <1> 	mov byte al, [token + 1]	; Less than or equal?
  1747 000035FD 3C3D                <1> 	cmp al, '='
  1748 000035FF 7429                <1> 	je .less_equal
  1749                              <1> 
  1750 00003601 E80B0D              <1> 	call get_token
  1751 00003604 A0007B              <1> 	mov byte al, [token]
  1752 00003607 E8120E              <1> 	call is_letter
  1753 0000360A 720F                <1> 	jc .less_var
  1754                              <1> 
  1755 0000360C BE007B              <1> 	mov si, token
  1756 0000360F E88FF2              <1> 	call os_string_to_int
  1757                              <1> 
  1758 00003612 39D0                <1> 	cmp ax, dx
  1759 00003614 0F8F8900            <1> 	jg .on_to_then
  1760                              <1> 
  1761 00003618 E9AE00              <1> 	jmp .finish_line
  1762                              <1> 
  1763                              <1> .less_var:
  1764 0000361B 0FB606007B          <1> 	movzx ax, byte [token]
  1765                              <1> 
  1766 00003620 E8D00C              <1> 	call get_var
  1767                              <1> 
  1768 00003623 39D0                <1> 	cmp ax, dx
  1769 00003625 7F7A                <1> 	jg .on_to_then
  1770                              <1> 
  1771 00003627 E99F00              <1> 	jmp .finish_line
  1772                              <1> 
  1773                              <1> .less_equal:
  1774 0000362A E8E20C              <1> 	call get_token
  1775 0000362D A0007B              <1> 	mov byte al, [token]
  1776 00003630 E8E90D              <1> 	call is_letter
  1777 00003633 720D                <1> 	jc .less_equal_var
  1778                              <1> 
  1779 00003635 BE007B              <1> 	mov si, token
  1780 00003638 E866F2              <1> 	call os_string_to_int
  1781                              <1> 
  1782 0000363B 39D0                <1> 	cmp ax, dx
  1783 0000363D 7D62                <1> 	jge .on_to_then
  1784                              <1> 
  1785 0000363F E98700              <1> 	jmp .finish_line
  1786                              <1> 
  1787                              <1> .less_equal_var:
  1788 00003642 0FB606007B          <1> 	movzx ax, byte [token]
  1789                              <1> 
  1790 00003647 E8A90C              <1> 	call get_var
  1791                              <1> 
  1792 0000364A 39D0                <1> 	cmp ax, dx
  1793 0000364C 7D53                <1> 	jge .on_to_then
  1794                              <1> 
  1795 0000364E EB79                <1> 	jmp .finish_line
  1796                              <1> 
  1797                              <1> 
  1798                              <1> .string_var:
  1799 00003650 881E[E436]          <1> 	mov byte [.tmp_string_var], bl
  1800                              <1> 
  1801 00003654 E8B80C              <1> 	call get_token
  1802                              <1> 
  1803 00003657 A0007B              <1> 	mov byte al, [token]
  1804 0000365A 3C3D                <1> 	cmp al, '='
  1805 0000365C 0F857F00            <1> 	jne .error
  1806                              <1> 
  1807 00003660 E8AC0C              <1> 	call get_token
  1808 00003663 83F802              <1> 	cmp ax, STRING_VAR
  1809 00003666 7419                <1> 	je .second_is_string_var
  1810                              <1> 
  1811 00003668 83F805              <1> 	cmp ax, QUOTE
  1812 0000366B 7572                <1> 	jne .error
  1813                              <1> 
  1814 0000366D BE007C              <1> 	mov si, string_vars
  1815 00003670 B88000              <1> 	mov ax, 128
  1816 00003673 F7E3                <1> 	mul bx
  1817 00003675 01C6                <1> 	add si, ax
  1818 00003677 BF007B              <1> 	mov di, token
  1819 0000367A E8D0F1              <1> 	call os_string_compare
  1820 0000367D 7422                <1> 	je .on_to_then
  1821                              <1> 
  1822 0000367F EB48                <1> 	jmp .finish_line
  1823                              <1> 
  1824                              <1> 
  1825                              <1> .second_is_string_var:
  1826 00003681 BE007C              <1> 	mov si, string_vars
  1827 00003684 B88000              <1> 	mov ax, 128
  1828 00003687 F7E3                <1> 	mul bx
  1829 00003689 01C6                <1> 	add si, ax
  1830                              <1> 
  1831 0000368B BF007C              <1> 	mov di, string_vars
  1832 0000368E 0FB61E[E436]        <1> 	movzx bx, byte [.tmp_string_var]
  1833 00003693 B88000              <1> 	mov ax, 128
  1834 00003696 F7E3                <1> 	mul bx
  1835 00003698 01C7                <1> 	add di, ax
  1836                              <1> 
  1837 0000369A E8B0F1              <1> 	call os_string_compare
  1838 0000369D 7202                <1> 	jc .on_to_then
  1839                              <1> 
  1840 0000369F EB28                <1> 	jmp .finish_line
  1841                              <1> 
  1842                              <1> 
  1843                              <1> .on_to_then:
  1844 000036A1 E86B0C              <1> 	call get_token
  1845                              <1> 
  1846 000036A4 BE007B              <1> 	mov si, token			; Look for AND for more comparison
  1847 000036A7 BF[B945]            <1> 	mov di, and_keyword
  1848 000036AA E8A0F1              <1> 	call os_string_compare
  1849 000036AD 0F8220FE            <1> 	jc do_if
  1850                              <1> 
  1851 000036B1 BE007B              <1> 	mov si, token			; Look for THEN to perform more operations
  1852 000036B4 BF[BD45]            <1> 	mov di, then_keyword
  1853 000036B7 E893F1              <1> 	call os_string_compare
  1854 000036BA 7205                <1> 	jc .then_present
  1855                              <1> 
  1856 000036BC B314                <1> 	mov bl, err_syntax
  1857 000036BE E9670D              <1> 	jmp error
  1858                              <1> 
  1859                              <1> .then_present:				; Continue rest of line like any other command!
  1860 000036C1 C606[9644]01        <1> 	mov byte [last_if_true], 1
  1861 000036C6 E924F4              <1> 	jmp mainloop
  1862                              <1> 
  1863                              <1> 
  1864                              <1> .finish_line:				; IF wasn't fulfilled, so skip rest of line
  1865 000036C9 8B36[8E44]          <1> 	mov word si, [prog]
  1866 000036CD 8A04                <1> 	mov byte al, [si]
  1867 000036CF FF06[8E44]          <1> 	inc word [prog]
  1868 000036D3 3C0A                <1> 	cmp al, 10
  1869 000036D5 75F2                <1> 	jne .finish_line
  1870                              <1> 
  1871 000036D7 C606[9644]00        <1> 	mov byte [last_if_true], 0
  1872 000036DC E90EF4              <1> 	jmp mainloop
  1873                              <1> 
  1874                              <1> 
  1875                              <1> .error:
  1876 000036DF B314                <1> 	mov bl, err_syntax
  1877 000036E1 E9440D              <1> 	jmp error
  1878                              <1> 
  1879                              <1> 
  1880 000036E4 00                  <1> 	.tmp_string_var		db 0
  1881                              <1> 
  1882                              <1> 
  1883                              <1> ; ------------------------------------------------------------------
  1884                              <1> ; INCLUDE
  1885                              <1> 
  1886                              <1> do_include:
  1887 000036E5 E8270C              <1> 	call get_token
  1888 000036E8 83F805              <1> 	cmp ax, QUOTE
  1889 000036EB 7406                <1> 	je .is_ok
  1890                              <1> 
  1891 000036ED BE1400              <1> 	mov si, err_syntax
  1892 000036F0 E9350D              <1> 	jmp error
  1893                              <1> 
  1894                              <1> .is_ok:
  1895 000036F3 B8007B              <1> 	mov ax, token
  1896 000036F6 8B0E[9044]          <1> 	mov word cx, [prog_end]
  1897 000036FA 41                  <1> 	inc cx				; Add a bit of space after original code
  1898 000036FB 41                  <1> 	inc cx
  1899 000036FC 41                  <1> 	inc cx
  1900 000036FD 51                  <1> 	push cx
  1901 000036FE E816D4              <1> 	call os_load_file
  1902 00003701 720A                <1> 	jc .load_fail
  1903                              <1> 
  1904 00003703 59                  <1> 	pop cx
  1905 00003704 01D9                <1> 	add cx, bx
  1906 00003706 890E[9044]          <1> 	mov word [prog_end], cx
  1907                              <1> 
  1908 0000370A E9E0F3              <1> 	jmp mainloop
  1909                              <1> 
  1910                              <1> 
  1911                              <1> .load_fail:
  1912 0000370D 59                  <1> 	pop cx
  1913 0000370E BE0400              <1> 	mov si, err_file_notfound
  1914 00003711 E9140D              <1> 	jmp error
  1915                              <1> 
  1916                              <1> 
  1917                              <1> ; ------------------------------------------------------------------
  1918                              <1> ; INK
  1919                              <1> 
  1920                              <1> do_ink:
  1921 00003714 E8F80B              <1> 	call get_token				; Get column
  1922                              <1> 
  1923 00003717 83F801              <1> 	cmp ax, VARIABLE
  1924 0000371A 740C                <1> 	je .first_is_var
  1925                              <1> 
  1926 0000371C BE007B              <1> 	mov si, token
  1927 0000371F E87FF1              <1> 	call os_string_to_int
  1928 00003722 A2[9744]            <1> 	mov byte [ink_colour], al
  1929 00003725 E9C5F3              <1> 	jmp mainloop
  1930                              <1> 
  1931                              <1> .first_is_var:
  1932                              <1> 	clr ax
    31 00003728 31C0                <2>  xor %1, %1
  1933 0000372A A0007B              <1> 	mov byte al, [token]
  1934 0000372D E8C30B              <1> 	call get_var
  1935 00003730 A2[9744]            <1> 	mov byte [ink_colour], al
  1936 00003733 E9B7F3              <1> 	jmp mainloop
  1937                              <1> 
  1938                              <1> 
  1939                              <1> ; ------------------------------------------------------------------
  1940                              <1> ; INPUT
  1941                              <1> 
  1942                              <1> do_input:
  1943                              <1> 	clr al					; Clear string from previous usage
    31 00003736 30C0                <2>  xor %1, %1
  1944 00003738 BF807A              <1> 	mov di, .tmpstring
  1945 0000373B B98000              <1> 	mov cx, 128
  1946 0000373E F3AA                <1> 	rep stosb
  1947                              <1> 
  1948 00003740 E8CC0B              <1> 	call get_token
  1949                              <1> 
  1950 00003743 83F801              <1> 	cmp ax, VARIABLE			; We can only INPUT to variables!
  1951 00003746 740B                <1> 	je .number_var
  1952                              <1> 
  1953 00003748 83F802              <1> 	cmp ax, STRING_VAR
  1954 0000374B 7436                <1> 	je .string_var
  1955                              <1> 
  1956 0000374D BE1400              <1> 	mov si, err_syntax
  1957 00003750 E9D50C              <1> 	jmp error
  1958                              <1> 
  1959                              <1> .number_var:
  1960 00003753 B8807A              <1> 	mov ax, .tmpstring			; Get input from the user
  1961 00003756 E8FCE8              <1> 	call os_input_string
  1962                              <1> 
  1963 00003759 B8807A              <1> 	mov ax, .tmpstring
  1964 0000375C E80CF0              <1> 	call os_string_length
  1965 0000375F 85C0                <1> 	test ax, ax
  1966 00003761 750A                <1> 	jnz .char_entered
  1967                              <1> 
  1968 00003763 C606807A30          <1> 	mov byte [.tmpstring], '0'		; If enter hit, fill variable with zero
  1969 00003768 C606817A00          <1> 	mov byte [.tmpstring + 1], 0
  1970                              <1> 
  1971                              <1> .char_entered:
  1972 0000376D BE807A              <1> 	mov si, .tmpstring			; Convert to integer format
  1973 00003770 E82EF1              <1> 	call os_string_to_int
  1974 00003773 89C3                <1> 	mov bx, ax
  1975                              <1> 
  1976 00003775 0FB606007B          <1> 	movzx ax, byte [token]
  1977 0000377A E8830B              <1> 	call set_var				; ...and store it!
  1978                              <1> 
  1979 0000377D E8D2E6              <1> 	call os_print_newline
  1980                              <1> 
  1981 00003780 E96AF3              <1> 	jmp mainloop
  1982                              <1> 
  1983                              <1> 
  1984                              <1> .string_var:
  1985 00003783 53                  <1> 	push bx
  1986                              <1> 
  1987 00003784 B8807A              <1> 	mov ax, .tmpstring
  1988 00003787 E8CBE8              <1> 	call os_input_string
  1989                              <1> 
  1990 0000378A BE807A              <1> 	mov si, .tmpstring
  1991 0000378D BF007C              <1> 	mov di, string_vars
  1992                              <1> 
  1993 00003790 5B                  <1> 	pop bx
  1994                              <1> 
  1995 00003791 B88000              <1> 	mov ax, 128
  1996 00003794 F7E3                <1> 	mul bx
  1997                              <1> 
  1998 00003796 01C7                <1> 	add di, ax
  1999 00003798 E855F0              <1> 	call os_string_copy
  2000                              <1> 
  2001 0000379B E8B4E6              <1> 	call os_print_newline
  2002                              <1> 
  2003 0000379E E94CF3              <1> 	jmp mainloop
  2004                              <1> 
  2005                              <1> 
  2006                              <1> ;	.tmpstring	times 128 db 0
  2007                              <1> 	.tmpstring	equ 32768-1024-256-128
  2008                              <1> 
  2009                              <1> ; -----------------------------------------------------------
  2010                              <1> ; LEN
  2011                              <1> 
  2012                              <1> do_len:
  2013 000037A1 E86B0B              <1> 	call get_token
  2014 000037A4 83F802              <1> 	cmp ax, STRING_VAR
  2015 000037A7 7538                <1> 	jne .error
  2016                              <1>  
  2017 000037A9 BE007C              <1> 	mov si, string_vars
  2018 000037AC B88000              <1> 	mov ax, 128
  2019 000037AF F7E3                <1> 	mul bx
  2020 000037B1 01C6                <1> 	add si, ax
  2021                              <1> 
  2022 000037B3 89F0                <1> 	mov ax, si
  2023 000037B5 E8B3EF              <1> 	call os_string_length
  2024 000037B8 A3[E737]            <1> 	mov word [.num1], ax
  2025                              <1> 
  2026 000037BB E8510B              <1> 	call get_token
  2027 000037BE 83F801              <1> 	cmp ax, VARIABLE
  2028 000037C1 7406                <1> 	je .is_ok
  2029                              <1> 	
  2030 000037C3 BE1400              <1> 	mov si, err_syntax
  2031 000037C6 E95F0C              <1> 	jmp error
  2032                              <1> 
  2033                              <1> .is_ok:
  2034 000037C9 0FB606007B          <1> 	movzx ax, byte [token]
  2035 000037CE 88C3                <1> 	mov bl, al
  2036 000037D0 EB00                <1> 	jmp .finish
  2037                              <1> 
  2038                              <1> .finish:	
  2039 000037D2 8B1E[E737]          <1> 	mov bx, [.num1]
  2040 000037D6 A0007B              <1> 	mov byte al, [token]
  2041 000037D9 E8240B              <1> 	call set_var
  2042 000037DC 31C0                <1> 	xor ax, ax
  2043 000037DE E90CF3              <1> 	jmp mainloop
  2044                              <1>  
  2045                              <1> .error:
  2046 000037E1 BE1400              <1> 	mov si, err_syntax
  2047 000037E4 E9410C              <1> 	jmp error
  2048                              <1> 
  2049                              <1> 
  2050 000037E7 0000                <1> 	.num1 dw 0
  2051                              <1> 
  2052                              <1> 
  2053                              <1> ; ------------------------------------------------------------------
  2054                              <1> ; LISTBOX
  2055                              <1> 
  2056                              <1> do_listbox:
  2057 000037E9 8A3E[9844]          <1> 	mov bh, [work_page]			; Store the cursor position
  2058 000037ED B403                <1> 	mov ah, 03h
  2059 000037EF CD10                <1> 	int 10h
  2060                              <1> 	
  2061 000037F1 E81B0B              <1> 	call get_token
  2062 000037F4 83F802              <1> 	cmp ax, STRING_VAR
  2063 000037F7 757C                <1> 	jne .error
  2064                              <1> 
  2065 000037F9 BE007C              <1> 	mov si, string_vars
  2066 000037FC B88000              <1> 	mov ax, 128
  2067 000037FF F7E3                <1> 	mul bx
  2068 00003801 01C6                <1> 	add si, ax
  2069                              <1> 
  2070 00003803 8936[7B38]          <1> 	mov word [.s1], si
  2071                              <1> 
  2072 00003807 E8050B              <1> 	call get_token
  2073 0000380A 83F802              <1> 	cmp ax, STRING_VAR
  2074 0000380D 7566                <1> 	jne .error
  2075                              <1> 
  2076 0000380F BE007C              <1> 	mov si, string_vars
  2077 00003812 B88000              <1> 	mov ax, 128
  2078 00003815 F7E3                <1> 	mul bx
  2079 00003817 01C6                <1> 	add si, ax
  2080                              <1> 
  2081 00003819 8936[7D38]          <1> 	mov word [.s2], si
  2082                              <1> 
  2083 0000381D E8EF0A              <1> 	call get_token
  2084 00003820 83F802              <1> 	cmp ax, STRING_VAR
  2085 00003823 7550                <1> 	jne .error
  2086                              <1> 
  2087 00003825 BE007C              <1> 	mov si, string_vars
  2088 00003828 B88000              <1> 	mov ax, 128
  2089 0000382B F7E3                <1> 	mul bx
  2090 0000382D 01C6                <1> 	add si, ax
  2091                              <1> 
  2092 0000382F 8936[7F38]          <1> 	mov word [.s3], si
  2093                              <1> 
  2094                              <1> 
  2095 00003833 E8D90A              <1> 	call get_token
  2096 00003836 83F801              <1> 	cmp ax, VARIABLE
  2097 00003839 753A                <1> 	jne .error
  2098                              <1> 
  2099 0000383B A0007B              <1> 	mov byte al, [token]
  2100 0000383E A2[8138]            <1> 	mov byte [.var], al
  2101                              <1> 
  2102 00003841 A1[7B38]            <1> 	mov word ax, [.s1]
  2103 00003844 8B1E[7D38]          <1> 	mov word bx, [.s2]
  2104 00003848 8B0E[7F38]          <1> 	mov word cx, [.s3]
  2105                              <1> 
  2106 0000384C E858E2              <1> 	call os_list_dialog
  2107 0000384F 7217                <1> 	jc .esc_pressed
  2108                              <1> 
  2109 00003851 60                  <1> 	pusha
  2110 00003852 8A3E[9844]          <1> 	mov bh, [work_page]			; Move the cursor back
  2111 00003856 B402                <1> 	mov ah, 02h
  2112 00003858 CD10                <1> 	int 10h
  2113 0000385A 61                  <1> 	popa
  2114                              <1> 
  2115 0000385B 89C3                <1> 	mov bx, ax
  2116 0000385D 0FB606[8138]        <1> 	movzx ax, byte [.var]
  2117 00003862 E89B0A              <1> 	call set_var
  2118                              <1> 
  2119 00003865 E985F2              <1> 	jmp mainloop
  2120                              <1> 
  2121                              <1> 
  2122                              <1> .esc_pressed:
  2123 00003868 0FB606[8138]        <1> 	movzx ax, byte [.var]
  2124 0000386D 31DB                <1> 	xor bx, bx
  2125 0000386F E88E0A              <1> 	call set_var
  2126 00003872 E978F2              <1> 	jmp mainloop
  2127                              <1> 
  2128                              <1> 
  2129                              <1> .error:
  2130 00003875 BE1400              <1> 	mov si, err_syntax
  2131 00003878 E9AD0B              <1> 	jmp error
  2132                              <1> 
  2133 0000387B 0000                <1> 	.s1 dw 0
  2134 0000387D 0000                <1> 	.s2 dw 0
  2135 0000387F 0000                <1> 	.s3 dw 0
  2136 00003881 00                  <1> 	.var db 0
  2137                              <1> 
  2138                              <1> 
  2139                              <1> ; ------------------------------------------------------------------
  2140                              <1> ; LOAD
  2141                              <1> 
  2142                              <1> do_load:
  2143 00003882 E88A0A              <1> 	call get_token
  2144 00003885 83F805              <1> 	cmp ax, QUOTE
  2145 00003888 7411                <1> 	je .is_quote
  2146                              <1> 
  2147 0000388A 83F802              <1> 	cmp ax, STRING_VAR
  2148 0000388D 755F                <1> 	jne .error
  2149                              <1> 
  2150 0000388F BE007C              <1> 	mov si, string_vars
  2151 00003892 B88000              <1> 	mov ax, 128
  2152 00003895 F7E3                <1> 	mul bx
  2153 00003897 01C6                <1> 	add si, ax
  2154 00003899 EB03                <1> 	jmp .get_position
  2155                              <1> 
  2156                              <1> .is_quote:
  2157 0000389B BE007B              <1> 	mov si, token
  2158                              <1> 
  2159                              <1> .get_position:
  2160 0000389E 89F0                <1> 	mov ax, si
  2161 000038A0 E823D5              <1> 	call os_file_exists
  2162 000038A3 7239                <1> 	jc .file_not_exists
  2163                              <1> 
  2164 000038A5 89C2                <1> 	mov dx, ax			; Store for now
  2165                              <1> 
  2166 000038A7 E8650A              <1> 	call get_token
  2167                              <1> 
  2168 000038AA 83F801              <1> 	cmp ax, VARIABLE
  2169 000038AD 7425                <1> 	je .second_is_var
  2170                              <1> 
  2171 000038AF 83F803              <1> 	cmp ax, NUMBER
  2172 000038B2 753A                <1> 	jne .error
  2173                              <1> 
  2174 000038B4 BE007B              <1> 	mov si, token
  2175 000038B7 E8E7EF              <1> 	call os_string_to_int
  2176                              <1> 
  2177                              <1> .load_part:
  2178 000038BA 89C1                <1> 	mov cx, ax
  2179                              <1> 
  2180 000038BC 89D0                <1> 	mov ax, dx
  2181                              <1> 
  2182 000038BE E856D2              <1> 	call os_load_file
  2183                              <1> 
  2184 000038C1 31C0                <1> 	xor ax, ax
  2185 000038C3 B053                <1> 	mov byte al, 'S'
  2186 000038C5 E8380A              <1> 	call set_var
  2187                              <1> 
  2188 000038C8 31C0                <1> 	xor ax, ax
  2189 000038CA B052                <1> 	mov byte al, 'R'
  2190 000038CC 31DB                <1> 	xor bx, bx
  2191 000038CE E82F0A              <1> 	call set_var
  2192                              <1> 
  2193 000038D1 E919F2              <1> 	jmp mainloop
  2194                              <1> 
  2195                              <1> 
  2196                              <1> .second_is_var:
  2197 000038D4 0FB606007B          <1> 	movzx ax, byte [token]
  2198 000038D9 E8170A              <1> 	call get_var
  2199 000038DC EBDC                <1> 	jmp .load_part
  2200                              <1> 
  2201                              <1> 
  2202                              <1> .file_not_exists:
  2203 000038DE 31C0                <1> 	xor ax, ax
  2204 000038E0 B052                <1> 	mov byte al, 'R'
  2205 000038E2 BB0100              <1> 	mov bx, 1
  2206 000038E5 E8180A              <1> 	call set_var
  2207                              <1> 
  2208 000038E8 E8240A              <1> 	call get_token				; Skip past the loading point -- unnecessary now
  2209                              <1> 
  2210 000038EB E9FFF1              <1> 	jmp mainloop
  2211                              <1> 
  2212                              <1> 
  2213                              <1> .error:
  2214 000038EE BE1400              <1> 	mov si, err_syntax
  2215 000038F1 E9340B              <1> 	jmp error
  2216                              <1> 
  2217                              <1> 
  2218                              <1> ; ------------------------------------------------------------------
  2219                              <1> ; LOOP
  2220                              <1> 
  2221                              <1> do_loop:
  2222 000038F4 803E[9544]00        <1> 	cmp byte [loop_in], 0
  2223 000038F9 0F84CA00            <1> 	je .no_do
  2224                              <1> 
  2225 000038FD 802E[9544]02        <1> 	sub byte [loop_in], 2
  2226                              <1> 
  2227 00003902 31D2                <1> 	xor dx, dx
  2228                              <1> 
  2229 00003904 E8080A              <1> 	call get_token
  2230 00003907 BF007B              <1> 	mov di, token
  2231                              <1> 	
  2232 0000390A BE[DF39]            <1> 	mov si, .endless_word
  2233 0000390D E83DEF              <1> 	call os_string_compare
  2234 00003910 0F829C00            <1> 	jc .loop_back
  2235                              <1> 	
  2236 00003914 BE[D339]            <1> 	mov si, .while_word
  2237 00003917 E833EF              <1> 	call os_string_compare
  2238 0000391A 0F82A300            <1> 	jc .while_set
  2239                              <1> 	
  2240 0000391E BE[D939]            <1> 	mov si, .until_word
  2241 00003921 E829EF              <1> 	call os_string_compare
  2242 00003924 0F83A500            <1> 	jnc .error
  2243                              <1> 	
  2244                              <1> .get_first_var:
  2245 00003928 E8E409              <1> 	call get_token
  2246 0000392B 83F801              <1> 	cmp ax, VARIABLE
  2247 0000392E 0F859B00            <1> 	jne .error
  2248                              <1> 	
  2249 00003932 A0007B              <1> 	mov al, [token]
  2250 00003935 E8BB09              <1> 	call get_var
  2251 00003938 89C1                <1> 	mov cx, ax
  2252                              <1> 	
  2253                              <1> .check_equals:
  2254 0000393A E8D209              <1> 	call get_token
  2255 0000393D 83F807              <1> 	cmp ax, UNKNOWN
  2256 00003940 0F858900            <1> 	jne .error
  2257                              <1> 
  2258 00003944 A1007B              <1> 	mov ax, [token]
  2259 00003947 3C3D                <1> 	cmp al, '='
  2260 00003949 740A                <1> 	je .sign_ok
  2261 0000394B 3C3E                <1> 	cmp al, '>'
  2262 0000394D 7406                <1> 	je .sign_ok
  2263 0000394F 3C3C                <1> 	cmp al, '<'
  2264 00003951 7402                <1> 	je .sign_ok
  2265 00003953 EB78                <1> 	jmp .error
  2266                              <1> 	.sign_ok:
  2267 00003955 A2[E739]            <1> 	mov byte [.sign], al
  2268                              <1> 	
  2269                              <1> .get_second_var:
  2270 00003958 E8B409              <1>  	call get_token
  2271                              <1> 
  2272 0000395B 83F803              <1> 	cmp ax, NUMBER
  2273 0000395E 7419                <1> 	je .second_is_num
  2274                              <1> 
  2275 00003960 83F801              <1> 	cmp ax, VARIABLE
  2276 00003963 740C                <1> 	je .second_is_var
  2277                              <1> 
  2278 00003965 83F806              <1> 	cmp ax, CHAR
  2279 00003968 7563                <1> 	jne .error
  2280                              <1> 
  2281                              <1> .second_is_char:
  2282                              <1> 	clr ah
    31 0000396A 30E4                <2>  xor %1, %1
  2283 0000396C A0007B              <1> 	mov al, [token]
  2284 0000396F EB0E                <1> 	jmp .check_true
  2285                              <1> 	
  2286                              <1> .second_is_var:
  2287 00003971 A0007B              <1> 	mov al, [token]
  2288 00003974 E87C09              <1> 	call get_var
  2289 00003977 EB06                <1> 	jmp .check_true
  2290                              <1> 	
  2291                              <1> .second_is_num:
  2292 00003979 BE007B              <1> 	mov si, token
  2293 0000397C E822EF              <1> 	call os_string_to_int
  2294                              <1> 	
  2295                              <1> .check_true:
  2296 0000397F 8A1E[E739]          <1> 	mov byte bl, [.sign]
  2297 00003983 80FB3D              <1> 	cmp bl, '='
  2298 00003986 7407                <1> 	je .sign_equals
  2299                              <1> 	
  2300 00003988 80FB3E              <1> 	cmp bl, '>'
  2301 0000398B 7408                <1> 	je .sign_greater
  2302                              <1> 	
  2303 0000398D EB0C                <1> 	jmp .sign_lesser
  2304                              <1> 	
  2305                              <1> .sign_equals:
  2306 0000398F 39C8                <1> 	cmp ax, cx
  2307 00003991 7516                <1> 	jne .false
  2308 00003993 EB0C                <1> 	jmp .true
  2309                              <1> 	
  2310                              <1> .sign_greater:
  2311 00003995 39C8                <1> 	cmp ax, cx
  2312 00003997 7D10                <1> 	jge .false
  2313 00003999 EB06                <1> 	jmp .true
  2314                              <1> 	
  2315                              <1> .sign_lesser:
  2316 0000399B 39C8                <1> 	cmp ax, cx
  2317 0000399D 7E0A                <1> 	jle .false
  2318 0000399F EB00                <1> 	jmp .true
  2319                              <1> .true:
  2320 000039A1 83FA01              <1> 	cmp dx, 1
  2321 000039A4 740A                <1> 	je .loop_back
  2322 000039A6 E944F1              <1> 	jmp mainloop
  2323                              <1> .false:
  2324 000039A9 83FA01              <1> 	cmp dx, 1
  2325 000039AC 0F843DF1            <1> 	je mainloop
  2326                              <1> 	
  2327                              <1> .loop_back:	
  2328 000039B0 BED079              <1> 	mov word si, do_loop_store
  2329 000039B3 A0[9544]            <1> 	mov byte al, [loop_in]
  2330                              <1> 	clr ah
    31 000039B6 30E4                <2>  xor %1, %1
  2331 000039B8 01C6                <1> 	add si, ax
  2332 000039BA AD                  <1> 	lodsw
  2333 000039BB A3[8E44]            <1> 	mov word [prog], ax
  2334 000039BE E92CF1              <1> 	jmp mainloop
  2335                              <1> 	
  2336                              <1> .while_set:
  2337 000039C1 BA0100              <1> 	mov dx, 1
  2338 000039C4 E961FF              <1> 	jmp .get_first_var
  2339                              <1> 	
  2340                              <1> .no_do:
  2341 000039C7 BE0900              <1> 	mov si, err_loop
  2342 000039CA E95B0A              <1> 	jmp error
  2343                              <1> 
  2344                              <1> .error:
  2345 000039CD BE1400              <1> 	mov si, err_syntax
  2346 000039D0 E9550A              <1> 	jmp error
  2347                              <1> 	
  2348                              <1> .data:
  2349 000039D3 5748494C4500        <1> 	.while_word			db "WHILE", 0
  2350 000039D9 554E54494C00        <1> 	.until_word			db "UNTIL", 0
  2351 000039DF 454E444C45535300    <1> 	.endless_word			db "ENDLESS", 0
  2352 000039E7 00                  <1> 	.sign				db 0
  2353                              <1> 	
  2354                              <1> 	
  2355                              <1> ; ------------------------------------------------------------------
  2356                              <1> ; MOVE
  2357                              <1> 
  2358                              <1> do_move:
  2359 000039E8 E82409              <1> 	call get_token
  2360                              <1> 
  2361 000039EB 83F801              <1> 	cmp ax, VARIABLE
  2362 000039EE 740A                <1> 	je .first_is_var
  2363                              <1> 
  2364 000039F0 BE007B              <1> 	mov si, token
  2365 000039F3 E8ABEE              <1> 	call os_string_to_int
  2366 000039F6 88C2                <1> 	mov dl, al
  2367 000039F8 EB0A                <1> 	jmp .onto_second
  2368                              <1> 
  2369                              <1> .first_is_var:
  2370 000039FA 0FB606007B          <1> 	movzx ax, byte [token]
  2371 000039FF E8F108              <1> 	call get_var
  2372 00003A02 88C2                <1> 	mov dl, al
  2373                              <1> 
  2374                              <1> .onto_second:
  2375 00003A04 E80809              <1> 	call get_token
  2376                              <1> 
  2377 00003A07 83F801              <1> 	cmp ax, VARIABLE
  2378 00003A0A 740A                <1> 	je .second_is_var
  2379                              <1> 
  2380 00003A0C BE007B              <1> 	mov si, token
  2381 00003A0F E88FEE              <1> 	call os_string_to_int
  2382 00003A12 88C6                <1> 	mov dh, al
  2383 00003A14 EB0A                <1> 	jmp .finish
  2384                              <1> 
  2385                              <1> .second_is_var:
  2386 00003A16 0FB606007B          <1> 	movzx ax, byte [token]
  2387 00003A1B E8D508              <1> 	call get_var
  2388 00003A1E 88C6                <1> 	mov dh, al
  2389                              <1> 
  2390                              <1> .finish:
  2391 00003A20 8A3E[9844]          <1> 	mov byte bh, [work_page]
  2392 00003A24 B402                <1> 	mov ah, 2
  2393 00003A26 CD10                <1> 	int 10h
  2394                              <1> 
  2395 00003A28 E9C2F0              <1> 	jmp mainloop
  2396                              <1> 
  2397                              <1> 
  2398                              <1> ; ------------------------------------------------------------------
  2399                              <1> ; NEXT
  2400                              <1> 
  2401                              <1> do_next:
  2402 00003A2B E8E108              <1> 	call get_token
  2403                              <1> 
  2404 00003A2E 83F801              <1> 	cmp ax, VARIABLE			; NEXT must be followed by a variable
  2405 00003A31 753F                <1> 	jne .error
  2406                              <1> 
  2407 00003A33 0FB606007B          <1> 	movzx ax, byte [token]
  2408 00003A38 E8B808              <1> 	call get_var
  2409                              <1> 
  2410 00003A3B 40                  <1> 	inc ax					; NEXT increments the variable, of course!
  2411                              <1> 
  2412 00003A3C 89C3                <1> 	mov bx, ax
  2413                              <1> 
  2414 00003A3E 0FB606007B          <1> 	movzx ax, byte [token]
  2415                              <1> 
  2416 00003A43 2C41                <1> 	sub al, 65
  2417 00003A45 BE187A              <1> 	mov si, for_variables
  2418 00003A48 01C6                <1> 	add si, ax
  2419 00003A4A 01C6                <1> 	add si, ax
  2420 00003A4C AD                  <1> 	lodsw					; Get the target number from the table
  2421                              <1> 
  2422 00003A4D 40                  <1> 	inc ax					; (Make the loop inclusive of target number)
  2423 00003A4E 39D8                <1> 	cmp ax, bx				; Do the variable and target match?
  2424 00003A50 741D                <1> 	je .loop_finished
  2425                              <1> 
  2426 00003A52 0FB606007B          <1> 	movzx ax, byte [token]
  2427 00003A57 E8A608              <1> 	call set_var
  2428                              <1> 
  2429 00003A5A 0FB606007B          <1> 	movzx ax, byte [token]
  2430 00003A5F 2C41                <1> 	sub al, 65
  2431 00003A61 BEE479              <1> 	mov si, for_code_points
  2432 00003A64 01C6                <1> 	add si, ax
  2433 00003A66 01C6                <1> 	add si, ax
  2434 00003A68 AD                  <1> 	lodsw
  2435                              <1> 
  2436 00003A69 A3[8E44]            <1> 	mov word [prog], ax
  2437 00003A6C E97EF0              <1> 	jmp mainloop
  2438                              <1> 
  2439                              <1> 
  2440                              <1> .loop_finished:
  2441 00003A6F E97BF0              <1> 	jmp mainloop
  2442                              <1> 
  2443                              <1> .error:
  2444 00003A72 BE1400              <1> 	mov si, err_syntax
  2445 00003A75 E9B009              <1> 	jmp error
  2446                              <1> 
  2447                              <1> 
  2448                              <1> 
  2449                              <1> ;-------------------------------------------------------------------
  2450                              <1> ; NUMBER
  2451                              <1> 
  2452                              <1> do_number:
  2453 00003A78 E89408              <1> 	call get_token			; Check if it's string to number, or number to string
  2454                              <1> 
  2455 00003A7B 83F802              <1> 	cmp ax, STRING_VAR
  2456 00003A7E 7407                <1> 	je .is_string
  2457                              <1> 
  2458 00003A80 83F801              <1> 	cmp ax, VARIABLE
  2459 00003A83 742C                <1> 	je .is_variable
  2460                              <1> 
  2461 00003A85 EB54                <1> 	jmp .error
  2462                              <1> 
  2463                              <1> .is_string:
  2464                              <1> 
  2465 00003A87 BE007C              <1> 	mov si, string_vars
  2466 00003A8A B88000              <1> 	mov ax, 128
  2467 00003A8D F7E3                <1> 	mul bx
  2468 00003A8F 01C6                <1> 	add si, ax
  2469 00003A91 8936[E13A]          <1> 	mov [.tmp], si
  2470                              <1> 
  2471 00003A95 E87708              <1> 	call get_token
  2472                              <1> 
  2473 00003A98 8B36[E13A]          <1> 	mov si, [.tmp]
  2474                              <1> 
  2475 00003A9C 83F801              <1> 	cmp ax, VARIABLE
  2476 00003A9F 753A                <1> 	jne .error
  2477                              <1> 
  2478 00003AA1 E8FDED              <1> 	call os_string_to_int
  2479 00003AA4 89C3                <1> 	mov bx, ax
  2480                              <1> 
  2481 00003AA6 0FB606007B          <1> 	movzx ax, byte [token]
  2482 00003AAB E85208              <1> 	call set_var
  2483                              <1> 
  2484 00003AAE E93CF0              <1> 	jmp mainloop
  2485                              <1> 
  2486                              <1> .is_variable:
  2487 00003AB1 0FB606007B          <1> 	movzx ax, byte [token]
  2488 00003AB6 E83A08              <1> 	call get_var
  2489                              <1> 
  2490 00003AB9 E81EEE              <1> 	call os_int_to_string		; Convert to a string
  2491 00003ABC A3[E13A]            <1> 	mov [.tmp], ax
  2492                              <1> 
  2493 00003ABF E84D08              <1> 	call get_token			; Get the second parameter
  2494                              <1> 
  2495 00003AC2 8B36[E13A]          <1> 	mov si, [.tmp]
  2496                              <1> 
  2497 00003AC6 83F802              <1> 	cmp ax, STRING_VAR		; Make sure it's a string variable
  2498 00003AC9 7510                <1> 	jne .error
  2499                              <1> 
  2500 00003ACB BF007C              <1> 	mov di, string_vars		; Locate string variable
  2501 00003ACE B88000              <1> 	mov ax, 128
  2502 00003AD1 F7E3                <1> 	mul bx
  2503 00003AD3 01C7                <1> 	add di, ax
  2504                              <1> 
  2505 00003AD5 E818ED              <1> 	call os_string_copy		; Save converted string
  2506                              <1> 
  2507 00003AD8 E912F0              <1> 	jmp mainloop
  2508                              <1> 
  2509                              <1> .error:
  2510 00003ADB BE1400              <1> 	mov si, err_syntax
  2511 00003ADE E94709              <1> 	jmp error
  2512                              <1> 
  2513                              <1> 
  2514 00003AE1 0000                <1> 	.tmp		dw 	0
  2515                              <1> 
  2516                              <1> 
  2517                              <1> ;-------------------------------------------------------------------
  2518                              <1> ; PAGE
  2519                              <1> 
  2520                              <1> do_page:
  2521 00003AE3 E82908              <1> 	call get_token
  2522 00003AE6 83F803              <1> 	cmp ax, NUMBER
  2523 00003AE9 7521                <1> 	jne .error
  2524                              <1> 
  2525 00003AEB BE007B              <1> 	mov si, token
  2526 00003AEE E8B0ED              <1> 	call os_string_to_int
  2527 00003AF1 A2[9844]            <1> 	mov byte [work_page], al	; Set work page variable
  2528                              <1> 
  2529 00003AF4 E81808              <1> 	call get_token
  2530 00003AF7 83F803              <1> 	cmp ax, NUMBER
  2531 00003AFA 7510                <1> 	jne .error
  2532                              <1> 
  2533 00003AFC BE007B              <1> 	mov si, token
  2534 00003AFF E89FED              <1> 	call os_string_to_int
  2535 00003B02 A2[9944]            <1> 	mov byte [disp_page], al	; Set display page variable
  2536                              <1> 
  2537                              <1> 	; Change display page -- AL should already be present from the os_string_to_int
  2538 00003B05 B405                <1> 	mov ah, 5
  2539 00003B07 CD10                <1> 	int 10h
  2540                              <1> 
  2541 00003B09 E9E1EF              <1> 	jmp mainloop
  2542                              <1> 
  2543                              <1> .error:
  2544 00003B0C BE1400              <1> 	mov si, err_syntax
  2545 00003B0F E91609              <1> 	jmp error
  2546                              <1> 
  2547                              <1> 
  2548                              <1> ; ------------------------------------------------------------------
  2549                              <1> ; PAUSE
  2550                              <1> 
  2551                              <1> do_pause:
  2552 00003B12 E8FA07              <1> 	call get_token
  2553                              <1> 
  2554 00003B15 83F801              <1> 	cmp ax, VARIABLE
  2555 00003B18 7408                <1> 	je .is_var
  2556                              <1> 
  2557 00003B1A BE007B              <1> 	mov si, token
  2558 00003B1D E881ED              <1> 	call os_string_to_int
  2559 00003B20 EB08                <1> 	jmp .finish
  2560                              <1> 
  2561                              <1> .is_var:
  2562 00003B22 0FB606007B          <1> 	movzx ax, byte [token]
  2563 00003B27 E8C907              <1> 	call get_var
  2564                              <1> 
  2565                              <1> .finish:
  2566 00003B2A E8FB0A              <1> 	call os_pause
  2567 00003B2D E9BDEF              <1> 	jmp mainloop
  2568                              <1> 
  2569                              <1> 
  2570                              <1> ; ------------------------------------------------------------------
  2571                              <1> ; PEEK
  2572                              <1> 
  2573                              <1> do_peek:
  2574 00003B30 E8DC07              <1> 	call get_token
  2575                              <1> 
  2576 00003B33 83F801              <1> 	cmp ax, VARIABLE
  2577 00003B36 7533                <1> 	jne .error
  2578                              <1> 
  2579 00003B38 0FB606007B          <1> 	movzx ax, byte [token]
  2580 00003B3D A2[713B]            <1> 	mov byte [.tmp_var], al
  2581                              <1> 
  2582 00003B40 E8CC07              <1> 	call get_token
  2583                              <1> 
  2584 00003B43 83F801              <1> 	cmp ax, VARIABLE
  2585 00003B46 741B                <1> 	je .dereference
  2586                              <1> 
  2587 00003B48 83F803              <1> 	cmp ax, NUMBER
  2588 00003B4B 751E                <1> 	jne .error
  2589                              <1> 
  2590 00003B4D BE007B              <1> 	mov si, token
  2591 00003B50 E84EED              <1> 	call os_string_to_int
  2592                              <1> 
  2593                              <1> .store:
  2594 00003B53 89C6                <1> 	mov si, ax
  2595 00003B55 0FB61C              <1> 	movzx bx, byte [si]
  2596 00003B58 0FB606[713B]        <1> 	movzx ax, byte [.tmp_var]
  2597 00003B5D E8A007              <1> 	call set_var
  2598                              <1> 
  2599 00003B60 E98AEF              <1> 	jmp mainloop
  2600                              <1> 
  2601                              <1> .dereference:
  2602 00003B63 A0007B              <1> 	mov byte al, [token]
  2603 00003B66 E88A07              <1> 	call get_var
  2604 00003B69 EBE8                <1> 	jmp .store
  2605                              <1> 
  2606                              <1> .error:
  2607 00003B6B BE1400              <1> 	mov si, err_syntax
  2608 00003B6E E9B708              <1> 	jmp error
  2609                              <1> 
  2610                              <1> 
  2611 00003B71 00                  <1> 	.tmp_var	db 0
  2612                              <1> 	
  2613                              <1> 	
  2614                              <1> 	
  2615                              <1> ; ------------------------------------------------------------------
  2616                              <1> ; PEEKINT
  2617                              <1> 
  2618                              <1> do_peekint:
  2619 00003B72 E89A07              <1> 	call get_token
  2620                              <1> 	
  2621 00003B75 83F801              <1> 	cmp ax, VARIABLE
  2622 00003B78 752C                <1> 	jne .error
  2623                              <1> 
  2624                              <1> .get_second:
  2625 00003B7A A0007B              <1> 	mov al, [token]
  2626 00003B7D 89C1                <1> 	mov cx, ax
  2627                              <1> 	
  2628 00003B7F E88D07              <1> 	call get_token
  2629                              <1> 	
  2630 00003B82 83F801              <1> 	cmp ax, VARIABLE
  2631 00003B85 740D                <1> 	je .address_is_var
  2632                              <1> 	
  2633 00003B87 83F803              <1> 	cmp ax, NUMBER
  2634 00003B8A 751A                <1> 	jne .error
  2635                              <1> 	
  2636                              <1> .address_is_number:
  2637 00003B8C BE007B              <1> 	mov si, token
  2638 00003B8F E80FED              <1> 	call os_string_to_int
  2639 00003B92 EB06                <1> 	jmp .load_data
  2640                              <1> 	
  2641                              <1> .address_is_var:
  2642 00003B94 A0007B              <1> 	mov al, [token]
  2643 00003B97 E85907              <1> 	call get_var
  2644                              <1> 	
  2645                              <1> .load_data:
  2646 00003B9A 89C6                <1> 	mov si, ax
  2647 00003B9C 8B1C                <1> 	mov bx, [si]
  2648 00003B9E 89C8                <1> 	mov ax, cx
  2649 00003BA0 E85D07              <1> 	call set_var
  2650                              <1> 	
  2651 00003BA3 E947EF              <1> 	jmp mainloop
  2652                              <1> 	
  2653                              <1> .error:
  2654 00003BA6 BE1400              <1> 	mov si, err_syntax
  2655 00003BA9 E97C08              <1> 	jmp error
  2656                              <1> 
  2657                              <1> 
  2658                              <1> 
  2659                              <1> ; ------------------------------------------------------------------
  2660                              <1> ; POKE
  2661                              <1> 
  2662                              <1> do_poke:
  2663 00003BAC E86007              <1> 	call get_token
  2664                              <1> 
  2665 00003BAF 83F801              <1> 	cmp ax, VARIABLE
  2666 00003BB2 7415                <1> 	je .first_is_var
  2667                              <1> 
  2668 00003BB4 83F803              <1> 	cmp ax, NUMBER
  2669 00003BB7 7544                <1> 	jne .error
  2670                              <1> 
  2671 00003BB9 BE007B              <1> 	mov si, token
  2672 00003BBC E8E2EC              <1> 	call os_string_to_int
  2673                              <1> 
  2674 00003BBF 3DFF00              <1> 	cmp ax, 255
  2675 00003BC2 7F39                <1> 	jg .error
  2676                              <1> 
  2677 00003BC4 A2[033C]            <1> 	mov byte [.first_value], al
  2678 00003BC7 EB0B                <1> 	jmp .onto_second
  2679                              <1> 
  2680                              <1> 
  2681                              <1> .first_is_var:
  2682 00003BC9 0FB606007B          <1> 	movzx ax, byte [token]
  2683 00003BCE E82207              <1> 	call get_var
  2684                              <1> 
  2685 00003BD1 A2[033C]            <1> 	mov byte [.first_value], al
  2686                              <1> 
  2687                              <1> .onto_second:
  2688 00003BD4 E83807              <1> 	call get_token
  2689                              <1> 
  2690 00003BD7 83F801              <1> 	cmp ax, VARIABLE
  2691 00003BDA 7417                <1> 	je .second_is_var
  2692                              <1> 
  2693 00003BDC 83F803              <1> 	cmp ax, NUMBER
  2694 00003BDF 751C                <1> 	jne .error
  2695                              <1> 
  2696 00003BE1 BE007B              <1> 	mov si, token
  2697 00003BE4 E8BAEC              <1> 	call os_string_to_int
  2698                              <1> 
  2699                              <1> .got_value:
  2700 00003BE7 89C7                <1> 	mov di, ax
  2701 00003BE9 0FB606[033C]        <1> 	movzx ax, byte [.first_value]
  2702 00003BEE 8805                <1> 	mov byte [di], al
  2703                              <1> 
  2704 00003BF0 E9FAEE              <1> 	jmp mainloop
  2705                              <1> 
  2706                              <1> .second_is_var:
  2707 00003BF3 0FB606007B          <1> 	movzx ax, byte [token]
  2708 00003BF8 E8F806              <1> 	call get_var
  2709 00003BFB EBEA                <1> 	jmp .got_value
  2710                              <1> 
  2711                              <1> .error:
  2712 00003BFD BE1400              <1> 	mov si, err_syntax
  2713 00003C00 E92508              <1> 	jmp error
  2714                              <1> 
  2715                              <1> 
  2716 00003C03 00                  <1> 	.first_value	db 0
  2717                              <1> 
  2718                              <1> 
  2719                              <1> 
  2720                              <1> 
  2721                              <1> ; ------------------------------------------------------------------
  2722                              <1> ; POKEINT
  2723                              <1> 
  2724                              <1> do_pokeint:
  2725 00003C04 E80807              <1> 	call get_token
  2726                              <1> 	
  2727 00003C07 83F801              <1> 	cmp ax, VARIABLE
  2728 00003C0A 740D                <1> 	je .data_is_var
  2729                              <1> 	
  2730 00003C0C 83F803              <1> 	cmp ax, NUMBER
  2731 00003C0F 7532                <1> 	jne .error
  2732                              <1> 
  2733                              <1> .data_is_num:
  2734 00003C11 BE007B              <1> 	mov si, token
  2735 00003C14 E88AEC              <1> 	call os_string_to_int
  2736 00003C17 EB06                <1> 	jmp .get_second
  2737                              <1> 	
  2738                              <1> .data_is_var:
  2739 00003C19 A0007B              <1> 	mov al, [token]
  2740 00003C1C E8D406              <1> 	call get_var
  2741                              <1> 	
  2742                              <1> .get_second:
  2743 00003C1F 89C1                <1> 	mov cx, ax
  2744                              <1> 	
  2745 00003C21 E8EB06              <1> 	call get_token
  2746                              <1> 	
  2747 00003C24 83F801              <1> 	cmp ax, VARIABLE
  2748 00003C27 740D                <1> 	je .address_is_var
  2749                              <1> 	
  2750 00003C29 83F803              <1> 	cmp ax, NUMBER
  2751 00003C2C 7515                <1> 	jne .error
  2752                              <1> 	
  2753                              <1> .address_is_num:
  2754 00003C2E BE007B              <1> 	mov si, token
  2755 00003C31 E86DEC              <1> 	call os_string_to_int
  2756 00003C34 EB06                <1> 	jmp .save_data
  2757                              <1> 	
  2758                              <1> .address_is_var:
  2759 00003C36 A0007B              <1> 	mov al, [token]
  2760 00003C39 E8B706              <1> 	call get_var
  2761                              <1> 	
  2762                              <1> .save_data:
  2763 00003C3C 89C6                <1> 	mov si, ax
  2764 00003C3E 890C                <1> 	mov [si], cx
  2765                              <1> 	
  2766 00003C40 E9AAEE              <1> 	jmp mainloop
  2767                              <1> 	
  2768                              <1> .error:
  2769 00003C43 BE1400              <1> 	mov si, err_syntax
  2770 00003C46 E9DF07              <1> 	jmp error
  2771                              <1> 
  2772                              <1> 
  2773                              <1> 
  2774                              <1> 
  2775                              <1> ; ------------------------------------------------------------------
  2776                              <1> ; PORT
  2777                              <1> 
  2778                              <1> do_port:
  2779 00003C49 E8C306              <1> 	call get_token
  2780 00003C4C BE007B              <1> 	mov si, token
  2781                              <1> 
  2782 00003C4F BF[C43C]            <1> 	mov di, .out_cmd
  2783 00003C52 E8F8EB              <1> 	call os_string_compare
  2784 00003C55 720A                <1> 	jc .do_out_cmd
  2785                              <1> 
  2786 00003C57 BF[C83C]            <1> 	mov di, .in_cmd
  2787 00003C5A E8F0EB              <1> 	call os_string_compare
  2788 00003C5D 7237                <1> 	jc .do_in_cmd
  2789                              <1> 
  2790 00003C5F EB5D                <1> 	jmp .error
  2791                              <1> 
  2792                              <1> 
  2793                              <1> .do_out_cmd:
  2794 00003C61 E8AB06              <1> 	call get_token
  2795 00003C64 83F803              <1> 	cmp ax, NUMBER
  2796 00003C67 7555                <1> 	jne .error
  2797                              <1> 
  2798 00003C69 BE007B              <1> 	mov si, token
  2799 00003C6C E832EC              <1> 	call os_string_to_int		; Now AX = port number
  2800 00003C6F 89C2                <1> 	mov dx, ax
  2801                              <1> 
  2802 00003C71 E89B06              <1> 	call get_token
  2803 00003C74 83F803              <1> 	cmp ax, NUMBER
  2804 00003C77 7407                <1> 	je .out_is_num
  2805                              <1> 
  2806 00003C79 83F801              <1> 	cmp ax, VARIABLE
  2807 00003C7C 740C                <1> 	je .out_is_var
  2808                              <1> 
  2809 00003C7E EB3E                <1> 	jmp .error
  2810                              <1> 
  2811                              <1> .out_is_num:
  2812 00003C80 BE007B              <1> 	mov si, token
  2813 00003C83 E81BEC              <1> 	call os_string_to_int
  2814 00003C86 EE                  <1> 	out dx, al
  2815 00003C87 E963EE              <1> 	jmp mainloop
  2816                              <1> 
  2817                              <1> .out_is_var:
  2818 00003C8A 0FB606007B          <1> 	movzx ax, byte [token]
  2819 00003C8F E86106              <1> 	call get_var
  2820                              <1> 
  2821 00003C92 EE                  <1> 	out dx, al
  2822 00003C93 E957EE              <1> 	jmp mainloop
  2823                              <1> 
  2824                              <1> 
  2825                              <1> .do_in_cmd:
  2826 00003C96 E87606              <1> 	call get_token
  2827 00003C99 83F803              <1> 	cmp ax, NUMBER
  2828 00003C9C 7520                <1> 	jne .error
  2829                              <1> 
  2830 00003C9E BE007B              <1> 	mov si, token
  2831 00003CA1 E8FDEB              <1> 	call os_string_to_int
  2832 00003CA4 89C2                <1> 	mov dx, ax
  2833                              <1> 
  2834 00003CA6 E86606              <1> 	call get_token
  2835 00003CA9 83F801              <1> 	cmp ax, VARIABLE
  2836 00003CAC 7510                <1> 	jne .error
  2837                              <1> 
  2838 00003CAE 8A0E007B            <1> 	mov byte cl, [token]
  2839                              <1> 
  2840 00003CB2 EC                  <1> 	in al, dx
  2841 00003CB3 0FB6D8              <1> 	movzx bx, al
  2842                              <1> 
  2843 00003CB6 88C8                <1> 	mov al, cl
  2844 00003CB8 E84506              <1> 	call set_var
  2845                              <1> 
  2846 00003CBB E92FEE              <1> 	jmp mainloop
  2847                              <1> 
  2848                              <1> 
  2849                              <1> .error:
  2850 00003CBE BE1400              <1> 	mov si, err_syntax
  2851 00003CC1 E96407              <1> 	jmp error
  2852                              <1> 
  2853                              <1> 
  2854 00003CC4 4F555400            <1> 	.out_cmd	db "OUT", 0
  2855 00003CC8 494E00              <1> 	.in_cmd		db "IN", 0
  2856                              <1> 
  2857                              <1> 
  2858                              <1> ; ------------------------------------------------------------------
  2859                              <1> ; PRINT
  2860                              <1> 
  2861                              <1> do_print:
  2862 00003CCB E84106              <1> 	call get_token				; Get part after PRINT
  2863                              <1> 
  2864 00003CCE 83F805              <1> 	cmp ax, QUOTE				; What type is it?
  2865 00003CD1 7423                <1> 	je .print_quote
  2866                              <1> 
  2867 00003CD3 83F801              <1> 	cmp ax, VARIABLE			; Numerical variable (eg X)
  2868 00003CD6 7410                <1> 	je .print_var
  2869                              <1> 
  2870 00003CD8 83F802              <1> 	cmp ax, STRING_VAR			; String variable (eg $1)
  2871 00003CDB 7452                <1> 	je .print_string_var
  2872                              <1> 
  2873 00003CDD 83F804              <1> 	cmp ax, STRING				; Special keyword (eg CHR or HEX)
  2874 00003CE0 7459                <1> 	je .print_keyword
  2875                              <1> 
  2876 00003CE2 BE1000              <1> 	mov si, err_print_type			; We only print quoted strings and vars!
  2877 00003CE5 E94007              <1> 	jmp error
  2878                              <1> 
  2879                              <1> 
  2880                              <1> .print_var:
  2881 00003CE8 0FB606007B          <1> 	movzx ax, byte [token]
  2882 00003CED E80306              <1> 	call get_var				; Get its value
  2883                              <1> 
  2884 00003CF0 E846E3              <1> 	call os_print_int
  2885                              <1> 
  2886 00003CF3 E9C500              <1> 	jmp .newline_or_not
  2887                              <1> 
  2888                              <1> 
  2889                              <1> .print_quote:					; If it's quoted text, print it
  2890 00003CF6 BE007B              <1> 	mov si, token
  2891                              <1> .print_quote_loop:
  2892 00003CF9 AC                  <1> 	lodsb
  2893 00003CFA 84C0                <1> 	test al, al
  2894 00003CFC 0F84BB00            <1> 	jz .newline_or_not
  2895                              <1> 
  2896 00003D00 B409                <1> 	mov ah, 09h
  2897 00003D02 8A1E[9744]          <1> 	mov byte bl, [ink_colour]
  2898 00003D06 8A3E[9844]          <1> 	mov byte bh, [work_page]
  2899 00003D0A B90100              <1> 	mov cx, 1
  2900 00003D0D CD10                <1> 	int 10h
  2901                              <1> 
  2902 00003D0F B403                <1> 	mov ah, 3
  2903 00003D11 CD10                <1> 	int 10h
  2904                              <1> 
  2905 00003D13 80FA4F              <1> 	cmp dl, 79
  2906 00003D16 7D0C                <1> 	jge .quote_newline
  2907 00003D18 FEC2                <1> 	inc dl
  2908                              <1> 
  2909                              <1> .move_cur_quote:
  2910 00003D1A 8A3E[9844]          <1> 	mov byte bh, [work_page]
  2911 00003D1E B402                <1> 	mov ah, 02h
  2912 00003D20 CD10                <1> 	int 10h
  2913 00003D22 EBD5                <1> 	jmp .print_quote_loop
  2914                              <1> 
  2915                              <1> 
  2916                              <1> .quote_newline:
  2917 00003D24 80FE18              <1> 	cmp dh, 24
  2918 00003D27 74F1                <1> 	je .move_cur_quote
  2919                              <1> 	clr dl
    31 00003D29 30D2                <2>  xor %1, %1
  2920 00003D2B FEC6                <1> 	inc dh
  2921 00003D2D EBEB                <1> 	jmp .move_cur_quote
  2922                              <1> 
  2923                              <1> .print_string_var:
  2924 00003D2F BE007C              <1> 	mov si, string_vars
  2925 00003D32 B88000              <1> 	mov ax, 128
  2926 00003D35 F7E3                <1> 	mul bx
  2927 00003D37 01C6                <1> 	add si, ax
  2928                              <1> 
  2929 00003D39 EBBE                <1> 	jmp .print_quote_loop
  2930                              <1> 
  2931                              <1> 
  2932                              <1> .print_keyword:
  2933 00003D3B BE007B              <1> 	mov si, token
  2934 00003D3E BF[C245]            <1> 	mov di, chr_keyword
  2935 00003D41 E809EB              <1> 	call os_string_compare
  2936 00003D44 720E                <1> 	jc .is_chr
  2937                              <1> 
  2938 00003D46 BF[C645]            <1> 	mov di, hex_keyword
  2939 00003D49 E801EB              <1> 	call os_string_compare
  2940 00003D4C 7243                <1> 	jc .is_hex
  2941                              <1> 
  2942 00003D4E BE1400              <1> 	mov si, err_syntax
  2943 00003D51 E9D406              <1> 	jmp error
  2944                              <1> 
  2945                              <1> .is_chr:
  2946 00003D54 E8B805              <1> 	call get_token
  2947                              <1> 
  2948 00003D57 83F801              <1> 	cmp ax, VARIABLE
  2949 00003D5A 7405                <1> 	je .is_chr_variable
  2950                              <1> 	
  2951 00003D5C 83F803              <1> 	cmp ax, NUMBER
  2952 00003D5F 740A                <1> 	je .is_chr_number
  2953                              <1> 
  2954                              <1> .is_chr_variable:
  2955 00003D61 0FB606007B          <1> 	movzx ax, byte [token]
  2956 00003D66 E88A05              <1> 	call get_var
  2957 00003D69 EB06                <1> 	jmp .print_chr
  2958                              <1> 	
  2959                              <1> .is_chr_number:
  2960 00003D6B BE007B              <1> 	mov si, token
  2961 00003D6E E830EB              <1> 	call os_string_to_int
  2962                              <1> 
  2963                              <1> .print_chr:
  2964 00003D71 B409                <1> 	mov ah, 09h
  2965 00003D73 8A1E[9744]          <1> 	mov byte bl, [ink_colour]
  2966 00003D77 8A3E[9844]          <1> 	mov byte bh, [work_page]
  2967 00003D7B B90100              <1> 	mov cx, 1
  2968 00003D7E CD10                <1> 	int 10h
  2969                              <1> 
  2970 00003D80 B403                <1> 	mov ah, 3		; Move the cursor forward
  2971 00003D82 CD10                <1> 	int 10h
  2972 00003D84 FEC2                <1> 	inc dl
  2973 00003D86 80FA4F              <1> 	cmp dl, 79
  2974 00003D89 7F1B                <1> 	jg .end_line		; If it's over the end of the line
  2975                              <1> .move_cur:
  2976 00003D8B B402                <1> 	mov ah, 2
  2977 00003D8D CD10                <1> 	int 10h
  2978                              <1> 
  2979 00003D8F EB2A                <1> 	jmp .newline_or_not
  2980                              <1> 
  2981                              <1> 
  2982                              <1> .is_hex:
  2983 00003D91 E87B05              <1> 	call get_token
  2984                              <1> 
  2985 00003D94 83F801              <1> 	cmp ax, VARIABLE
  2986 00003D97 751C                <1> 	jne .error
  2987                              <1> 
  2988 00003D99 0FB606007B          <1> 	movzx ax, byte [token]
  2989 00003D9E E85205              <1> 	call get_var
  2990                              <1> 
  2991 00003DA1 E871E2              <1> 	call os_print_2hex
  2992                              <1> 
  2993 00003DA4 EB15                <1> 	jmp .newline_or_not
  2994                              <1> 
  2995                              <1> .end_line:
  2996                              <1> 	clr dl
    31 00003DA6 30D2                <2>  xor %1, %1
  2997 00003DA8 FEC6                <1> 	inc dh
  2998 00003DAA 80FE19              <1> 	cmp dh, 25
  2999 00003DAD 7CDC                <1> 	jl .move_cur
  3000 00003DAF B618                <1> 	mov dh, 24
  3001 00003DB1 B24F                <1> 	mov dl, 79
  3002 00003DB3 EBD6                <1> 	jmp .move_cur
  3003                              <1> 
  3004                              <1> .error:
  3005 00003DB5 BE1400              <1> 	mov si, err_syntax
  3006 00003DB8 E96D06              <1> 	jmp error
  3007                              <1> 	
  3008                              <1> 
  3009                              <1> 
  3010                              <1> .newline_or_not:
  3011                              <1> 	; We want to see if the command ends with ';' -- which means that
  3012                              <1> 	; we shouldn't print a newline after it finishes. So we store the
  3013                              <1> 	; current program location to pop ahead and see if there's the ';'
  3014                              <1> 	; character -- otherwise we put the program location back and resume
  3015                              <1> 	; the main loop
  3016                              <1> 
  3017 00003DBB A1[8E44]            <1> 	mov word ax, [prog]
  3018 00003DBE A3[F13D]            <1> 	mov word [.tmp_loc], ax
  3019                              <1> 
  3020 00003DC1 E84B05              <1> 	call get_token
  3021 00003DC4 83F807              <1> 	cmp ax, UNKNOWN
  3022 00003DC7 750C                <1> 	jne .ignore
  3023                              <1> 
  3024 00003DC9 0FB606007B          <1> 	movzx ax, byte [token]
  3025 00003DCE 3C3B                <1> 	cmp al, ';'
  3026 00003DD0 7503                <1> 	jne .ignore
  3027                              <1> 
  3028 00003DD2 E918ED              <1> 	jmp mainloop				; And go back to interpreting the code!
  3029                              <1> 
  3030                              <1> .ignore:
  3031 00003DD5 B405                <1> 	mov ah, 5
  3032 00003DD7 A0[9844]            <1> 	mov al, [work_page]
  3033 00003DDA CD10                <1> 	int 10h
  3034                              <1> 
  3035 00003DDC 8A3E[9844]          <1> 	mov bh, [work_page]
  3036 00003DE0 E86FE0              <1> 	call os_print_newline
  3037                              <1> 
  3038 00003DE3 B405                <1> 	mov ah, 5
  3039 00003DE5 A0[9944]            <1> 	mov al, [disp_page]
  3040                              <1> 
  3041 00003DE8 A1[F13D]            <1> 	mov word ax, [.tmp_loc]
  3042 00003DEB A3[8E44]            <1> 	mov word [prog], ax
  3043                              <1> 
  3044 00003DEE E9FCEC              <1> 	jmp mainloop
  3045                              <1> 
  3046                              <1> 
  3047 00003DF1 0000                <1> 	.tmp_loc	dw 0
  3048                              <1> 
  3049                              <1> 
  3050                              <1> ; ------------------------------------------------------------------
  3051                              <1> ; RAND
  3052                              <1> 
  3053                              <1> do_rand:
  3054 00003DF3 E81905              <1> 	call get_token
  3055 00003DF6 83F801              <1> 	cmp ax, VARIABLE
  3056 00003DF9 7544                <1> 	jne .error
  3057                              <1> 
  3058 00003DFB A0007B              <1> 	mov byte al, [token]
  3059 00003DFE A2[3A3E]            <1> 	mov byte [.tmp], al
  3060                              <1> 
  3061 00003E01 E80B05              <1> 	call get_token
  3062 00003E04 83F803              <1> 	cmp ax, NUMBER
  3063 00003E07 7536                <1> 	jne .error
  3064                              <1> 
  3065 00003E09 BE007B              <1> 	mov si, token
  3066 00003E0C E892EA              <1> 	call os_string_to_int
  3067 00003E0F A3[3B3E]            <1> 	mov word [.num1], ax
  3068                              <1> 
  3069 00003E12 E8FA04              <1> 	call get_token
  3070 00003E15 83F803              <1> 	cmp ax, NUMBER
  3071 00003E18 7525                <1> 	jne .error
  3072                              <1> 
  3073 00003E1A BE007B              <1> 	mov si, token
  3074 00003E1D E881EA              <1> 	call os_string_to_int
  3075 00003E20 A3[3D3E]            <1> 	mov word [.num2], ax
  3076                              <1> 
  3077 00003E23 A1[3B3E]            <1> 	mov word ax, [.num1]
  3078 00003E26 8B1E[3D3E]          <1> 	mov word bx, [.num2]
  3079 00003E2A E885D4              <1> 	call os_get_random
  3080                              <1> 
  3081 00003E2D 89CB                <1> 	mov bx, cx
  3082 00003E2F 0FB606[3A3E]        <1> 	movzx ax, byte [.tmp]
  3083 00003E34 E8C904              <1> 	call set_var
  3084                              <1> 
  3085 00003E37 E9B3EC              <1> 	jmp mainloop
  3086                              <1> 
  3087                              <1> 
  3088 00003E3A 00                  <1> 	.tmp	db 0
  3089 00003E3B 0000                <1> 	.num1	dw 0
  3090 00003E3D 0000                <1> 	.num2	dw 0
  3091                              <1> 
  3092                              <1> 
  3093                              <1> .error:
  3094 00003E3F BE1400              <1> 	mov si, err_syntax
  3095 00003E42 E9E305              <1> 	jmp error
  3096                              <1> 
  3097                              <1> 
  3098                              <1> ; ------------------------------------------------------------------
  3099                              <1> ; READ
  3100                              <1> 
  3101                              <1> do_read:
  3102 00003E45 E8C704              <1> 	call get_token				; Get the next token
  3103                              <1> 
  3104 00003E48 83F804              <1> 	cmp ax, STRING				; Check for a label
  3105 00003E4B 7406                <1> 	je .is_ok
  3106                              <1> 
  3107 00003E4D BE0500              <1> 	mov si, err_goto_notlabel
  3108 00003E50 E9D505              <1> 	jmp error
  3109                              <1> 
  3110                              <1> .is_ok:
  3111 00003E53 BE007B              <1> 	mov si, token				; Back up this label
  3112 00003E56 BFE27A              <1> 	mov di, .tmp_token
  3113 00003E59 E894E9              <1> 	call os_string_copy
  3114                              <1> 
  3115 00003E5C B8E27A              <1> 	mov ax, .tmp_token
  3116 00003E5F E809E9              <1> 	call os_string_length
  3117                              <1> 
  3118 00003E62 BFE27A              <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  3119 00003E65 01C7                <1> 	add di, ax
  3120 00003E67 B03A                <1> 	mov al, ':'
  3121 00003E69 AA                  <1> 	stosb
  3122                              <1> 	clr al
    31 00003E6A 30C0                <2>  xor %1, %1
  3123 00003E6C AA                  <1> 	stosb
  3124                              <1> 
  3125 00003E6D E89F04              <1> 	call get_token				; Now get the offset variable
  3126 00003E70 83F801              <1> 	cmp ax, VARIABLE
  3127 00003E73 7406                <1> 	je .second_part_is_var
  3128                              <1> 
  3129 00003E75 BE1400              <1> 	mov si, err_syntax
  3130 00003E78 E9AD05              <1> 	jmp error
  3131                              <1> 
  3132                              <1> 
  3133                              <1> .second_part_is_var:
  3134 00003E7B 0FB606007B          <1> 	movzx ax, byte [token]
  3135 00003E80 E87004              <1> 	call get_var
  3136                              <1> 
  3137 00003E83 83F800              <1> 	cmp ax, 0				; Want to be searching for at least the first byte!
  3138 00003E86 7F06                <1> 	jg .var_bigger_than_zero
  3139                              <1> 
  3140 00003E88 BE1400              <1> 	mov si, err_syntax
  3141 00003E8B E99A05              <1> 	jmp error
  3142                              <1> 
  3143                              <1> 
  3144                              <1> .var_bigger_than_zero:
  3145 00003E8E A3[183F]            <1> 	mov word [.to_skip], ax
  3146                              <1> 
  3147                              <1> 
  3148 00003E91 E87B04              <1> 	call get_token				; And now the var to store result into
  3149 00003E94 83F801              <1> 	cmp ax, VARIABLE
  3150 00003E97 7406                <1> 	je .third_part_is_var
  3151                              <1> 
  3152 00003E99 BE1400              <1> 	mov si, err_syntax
  3153 00003E9C E98905              <1> 	jmp error
  3154                              <1> 
  3155                              <1> 
  3156                              <1> .third_part_is_var:				; Keep it for later
  3157 00003E9F 0FB606007B          <1> 	movzx ax, byte [token]
  3158 00003EA4 A2[1A3F]            <1> 	mov byte [.var_to_use], al
  3159                              <1> 
  3160                              <1> 
  3161                              <1> 
  3162                              <1> 	; OK, so now we have all the stuff we need. Let's search for the label
  3163                              <1> 
  3164 00003EA7 A1[8E44]            <1> 	mov word ax, [prog]			; Store current location
  3165 00003EAA A3[163F]            <1> 	mov word [.curr_location], ax
  3166                              <1> 
  3167 00003EAD A1[9244]            <1> 	mov word ax, [load_point]
  3168 00003EB0 A3[8E44]            <1> 	mov word [prog], ax			; Return to start of program to find label
  3169                              <1> 
  3170                              <1> .loop:
  3171 00003EB3 E85904              <1> 	call get_token
  3172                              <1> 
  3173 00003EB6 83F808              <1> 	cmp ax, LABEL
  3174 00003EB9 750B                <1> 	jne .line_loop
  3175                              <1> 
  3176 00003EBB BE007B              <1> 	mov si, token
  3177 00003EBE BFE27A              <1> 	mov di, .tmp_token
  3178 00003EC1 E889E9              <1> 	call os_string_compare
  3179 00003EC4 7221                <1> 	jc .found_label
  3180                              <1> 
  3181                              <1> .line_loop:					; Go to end of line
  3182 00003EC6 8B36[8E44]          <1> 	mov word si, [prog]
  3183 00003ECA 8A04                <1> 	mov byte al, [si]
  3184 00003ECC FF06[8E44]          <1> 	inc word [prog]
  3185                              <1> 
  3186 00003ED0 3C0A                <1> 	cmp al, 10
  3187 00003ED2 75F2                <1> 	jne .line_loop
  3188                              <1> 
  3189 00003ED4 A1[8E44]            <1> 	mov word ax, [prog]
  3190 00003ED7 8B1E[9044]          <1> 	mov word bx, [prog_end]
  3191 00003EDB 39D8                <1> 	cmp ax, bx
  3192 00003EDD 7F02                <1> 	jg .past_end
  3193                              <1> 
  3194 00003EDF EBD2                <1> 	jmp .loop
  3195                              <1> 
  3196                              <1> .past_end:
  3197 00003EE1 BE0600              <1> 	mov si, err_label_notfound
  3198 00003EE4 E94105              <1> 	jmp error
  3199                              <1> 
  3200                              <1> 
  3201                              <1> .found_label:
  3202 00003EE7 8B0E[183F]          <1> 	mov word cx, [.to_skip]			; Skip requested number of data entries
  3203                              <1> 
  3204                              <1> .data_skip_loop:
  3205 00003EEB 51                  <1> 	push cx
  3206 00003EEC E82004              <1> 	call get_token
  3207 00003EEF 59                  <1> 	pop cx
  3208 00003EF0 E2F9                <1> 	loop .data_skip_loop
  3209                              <1> 
  3210 00003EF2 83F803              <1> 	cmp ax, NUMBER
  3211 00003EF5 7406                <1> 	je .data_is_num
  3212                              <1> 
  3213 00003EF7 BE1400              <1> 	mov si, err_syntax
  3214 00003EFA E92B05              <1> 	jmp error
  3215                              <1> 
  3216                              <1> .data_is_num:
  3217 00003EFD BE007B              <1> 	mov si, token
  3218 00003F00 E89EE9              <1> 	call os_string_to_int
  3219                              <1> 
  3220 00003F03 89C3                <1> 	mov bx, ax
  3221 00003F05 0FB606[1A3F]        <1> 	movzx ax, byte [.var_to_use]
  3222 00003F0A E8F303              <1> 	call set_var
  3223                              <1> 
  3224 00003F0D A1[163F]            <1> 	mov word ax, [.curr_location]
  3225 00003F10 A3[8E44]            <1> 	mov word [prog], ax
  3226                              <1> 
  3227 00003F13 E9D7EB              <1> 	jmp mainloop
  3228                              <1> 
  3229                              <1> 
  3230 00003F16 0000                <1> 	.curr_location	dw 0
  3231                              <1> 
  3232 00003F18 0000                <1> 	.to_skip	dw 0
  3233 00003F1A 00                  <1> 	.var_to_use	db 0
  3234                              <1> ;	.tmp_token 	times 30 db 0
  3235                              <1> 	.tmp_token 	equ 32768-1024-256-30
  3236                              <1> 
  3237                              <1> 
  3238                              <1> ; ------------------------------------------------------------------
  3239                              <1> ; REM
  3240                              <1> 
  3241                              <1> do_rem:
  3242 00003F1B 8B36[8E44]          <1> 	mov word si, [prog]
  3243 00003F1F 8A04                <1> 	mov byte al, [si]
  3244 00003F21 FF06[8E44]          <1> 	inc word [prog]
  3245 00003F25 3C0A                <1> 	cmp al, 10			; Find end of line after REM
  3246 00003F27 75F2                <1> 	jne do_rem
  3247                              <1> 
  3248 00003F29 E9C1EB              <1> 	jmp mainloop
  3249                              <1> 
  3250                              <1> 
  3251                              <1> ; ------------------------------------------------------------------
  3252                              <1> ; RENAME
  3253                              <1> 
  3254                              <1> do_rename:
  3255 00003F2C E8E003              <1> 	call get_token
  3256                              <1> 
  3257 00003F2F 83F802              <1> 	cmp ax, STRING_VAR		; Is it a string or a quote?
  3258 00003F32 7407                <1> 	je .first_is_string
  3259                              <1> 
  3260 00003F34 83F805              <1> 	cmp ax, QUOTE
  3261 00003F37 740E                <1> 	je .first_is_quote
  3262                              <1> 
  3263 00003F39 EB61                <1> 	jmp .error
  3264                              <1> 
  3265                              <1> .first_is_string:
  3266 00003F3B BE007C              <1> 	mov si, string_vars		; Locate string
  3267 00003F3E B88000              <1> 	mov ax, 128
  3268 00003F41 F7E3                <1> 	mul bx
  3269 00003F43 01C6                <1> 	add si, ax
  3270                              <1> 
  3271 00003F45 EB03                <1> 	jmp .save_file1
  3272                              <1> 
  3273                              <1> .first_is_quote:
  3274 00003F47 BE007B              <1> 	mov si, token			; The location of quotes is provided
  3275                              <1> 
  3276                              <1> .save_file1:
  3277 00003F4A BF[C93F]            <1> 	mov word di, .file1		; The filename is saved to temporary strings because
  3278 00003F4D E8A0E8              <1> 	call os_string_copy		; getting a second quote will overwrite the previous
  3279                              <1> 	
  3280                              <1> .get_second:
  3281 00003F50 E8BC03              <1> 	call get_token
  3282                              <1> 
  3283 00003F53 83F802              <1> 	cmp ax, STRING_VAR
  3284 00003F56 7407                <1> 	je .second_is_string
  3285                              <1> 
  3286 00003F58 83F805              <1> 	cmp ax, QUOTE
  3287 00003F5B 740E                <1> 	je .second_is_quote
  3288                              <1> 
  3289 00003F5D EB3D                <1> 	jmp .error
  3290                              <1> 
  3291                              <1> .second_is_string:
  3292 00003F5F BE007C              <1> 	mov si, string_vars		; Locate second string
  3293 00003F62 B88000              <1> 	mov ax, 128
  3294 00003F65 F7E3                <1> 	mul bx
  3295 00003F67 01C6                <1> 	add si, ax
  3296                              <1> 
  3297 00003F69 EB03                <1> 	jmp .save_file2
  3298                              <1> 
  3299                              <1> .second_is_quote:
  3300 00003F6B BE007B              <1> 	mov si, token
  3301                              <1> 
  3302                              <1> .save_file2:
  3303 00003F6E BF[D53F]            <1> 	mov word di, .file2
  3304 00003F71 E87CE8              <1> 	call os_string_copy
  3305                              <1> 	
  3306                              <1> .check_exists:
  3307 00003F74 B8[C93F]            <1> 	mov word ax, .file1		; Check if the source file exists
  3308 00003F77 E84CCE              <1> 	call os_file_exists
  3309 00003F7A 7226                <1> 	jc .file_not_found		; If it doesn't exists set "R = 1"
  3310                              <1> 
  3311 00003F7C F8                  <1> 	clc
  3312 00003F7D B8[D53F]            <1> 	mov ax, .file2			; The second file is the destination and should not exist
  3313 00003F80 E843CE              <1> 	call os_file_exists
  3314 00003F83 7337                <1> 	jnc .file_exists		; If it exists set "R = 3"
  3315                              <1> 	
  3316                              <1> .rename:
  3317 00003F85 B8[C93F]            <1> 	mov word ax, .file1		; Seem to be okay, lets rename
  3318 00003F88 BB[D53F]            <1> 	mov word bx, .file2
  3319 00003F8B E8A2CF              <1> 	call os_rename_file
  3320                              <1> 
  3321 00003F8E 721F                <1> 	jc .rename_failed		; If it failed set "R = 2", usually caused by a read-only disk
  3322                              <1> 
  3323 00003F90 31C0                <1> 	xor ax, ax			; It worked sucessfully, so set "R = 0" to indicate no error
  3324 00003F92 B052                <1> 	mov byte al, 'R'
  3325 00003F94 31DB                <1> 	xor bx, bx
  3326 00003F96 E86703              <1> 	call set_var
  3327                              <1> 
  3328 00003F99 E951EB              <1> 	jmp mainloop
  3329                              <1> 
  3330                              <1> .error:
  3331 00003F9C BE1400              <1> 	mov si, err_syntax
  3332 00003F9F E98604              <1> 	jmp error
  3333                              <1> 
  3334                              <1> .file_not_found:
  3335 00003FA2 31C0                <1> 	xor ax, ax			; Set R variable to 1
  3336 00003FA4 B052                <1> 	mov byte al, 'R'
  3337 00003FA6 BB0100              <1> 	mov bx, 1
  3338 00003FA9 E85403              <1> 	call set_var
  3339                              <1> 
  3340 00003FAC E93EEB              <1> 	jmp mainloop
  3341                              <1> 
  3342                              <1> .rename_failed:
  3343 00003FAF 31C0                <1> 	xor ax, ax			; Set R variable to 2
  3344 00003FB1 B052                <1> 	mov byte al, 'R'
  3345 00003FB3 BB0200              <1> 	mov bx, 2
  3346 00003FB6 E84703              <1> 	call set_var
  3347                              <1> 
  3348 00003FB9 E931EB              <1> 	jmp mainloop
  3349                              <1> 
  3350                              <1> .file_exists:
  3351 00003FBC 31C0                <1> 	xor ax, ax
  3352 00003FBE B052                <1> 	mov byte al, 'R'		; Set R variable to 3
  3353 00003FC0 BB0300              <1> 	mov bx, 3
  3354 00003FC3 E83A03              <1> 	call set_var
  3355                              <1> 
  3356 00003FC6 E924EB              <1> 	jmp mainloop
  3357                              <1> 
  3358                              <1> .data:
  3359 00003FC9 00<rep Ch>          <1> 	.file1				times 12 db 0
  3360 00003FD5 00<rep Ch>          <1> 	.file2				times 12 db 0
  3361                              <1> 
  3362                              <1> 
  3363                              <1> ; ------------------------------------------------------------------
  3364                              <1> ; RETURN
  3365                              <1> 
  3366                              <1> do_return:
  3367 00003FE1 0FB606[0546]        <1> 	movzx ax, byte [gosub_depth]
  3368 00003FE6 84C0                <1> 	test al, al
  3369 00003FE8 7506                <1> 	jnz .is_ok
  3370                              <1> 
  3371 00003FEA BE1200              <1> 	mov si, err_return
  3372 00003FED E93804              <1> 	jmp error
  3373                              <1> 
  3374                              <1> .is_ok:
  3375 00003FF0 BEBC79              <1> 	mov si, gosub_points
  3376 00003FF3 01C6                <1> 	add si, ax				; Table is words (not bytes)
  3377 00003FF5 01C6                <1> 	add si, ax
  3378 00003FF7 AD                  <1> 	lodsw
  3379 00003FF8 A3[8E44]            <1> 	mov word [prog], ax
  3380 00003FFB FE0E[0546]          <1> 	dec byte [gosub_depth]
  3381                              <1> 
  3382 00003FFF E9EBEA              <1> 	jmp mainloop	
  3383                              <1> 
  3384                              <1> 
  3385                              <1> ; ------------------------------------------------------------------
  3386                              <1> ; SAVE
  3387                              <1> 
  3388                              <1> do_save:
  3389 00004002 E80A03              <1> 	call get_token
  3390 00004005 83F805              <1> 	cmp ax, QUOTE
  3391 00004008 7413                <1> 	je .is_quote
  3392                              <1> 
  3393 0000400A 83F802              <1> 	cmp ax, STRING_VAR
  3394 0000400D 0F859500            <1> 	jne .error
  3395                              <1> 
  3396 00004011 BE007C              <1> 	mov si, string_vars
  3397 00004014 B88000              <1> 	mov ax, 128
  3398 00004017 F7E3                <1> 	mul bx
  3399 00004019 01C6                <1> 	add si, ax
  3400 0000401B EB03                <1> 	jmp .get_position
  3401                              <1> 
  3402                              <1> .is_quote:
  3403 0000401D BE007B              <1> 	mov si, token
  3404                              <1> 
  3405                              <1> .get_position:
  3406 00004020 BF[B240]            <1> 	mov di, .tmp_filename
  3407 00004023 E8CAE7              <1> 	call os_string_copy
  3408                              <1> 
  3409 00004026 E8E602              <1> 	call get_token
  3410                              <1> 
  3411 00004029 83F801              <1> 	cmp ax, VARIABLE
  3412 0000402C 744A                <1> 	je .second_is_var
  3413                              <1> 
  3414 0000402E 83F803              <1> 	cmp ax, NUMBER
  3415 00004031 7573                <1> 	jne .error
  3416                              <1> 
  3417 00004033 BE007B              <1> 	mov si, token
  3418 00004036 E868E8              <1> 	call os_string_to_int
  3419                              <1> 
  3420                              <1> .set_data_loc:
  3421 00004039 A3[AE40]            <1> 	mov word [.data_loc], ax
  3422                              <1> 
  3423 0000403C E8D002              <1> 	call get_token
  3424                              <1> 
  3425 0000403F 83F801              <1> 	cmp ax, VARIABLE
  3426 00004042 743E                <1> 	je .third_is_var
  3427                              <1> 
  3428 00004044 83F803              <1> 	cmp ax, NUMBER
  3429 00004047 755D                <1> 	jne .error
  3430                              <1> 
  3431 00004049 BE007B              <1> 	mov si, token
  3432 0000404C E852E8              <1> 	call os_string_to_int
  3433                              <1> 
  3434                              <1> .check_exists:
  3435 0000404F A3[B040]            <1> 	mov word [.data_size], ax
  3436 00004052 B8[B240]            <1> 	mov word ax, .tmp_filename
  3437 00004055 E86ECD              <1> 	call os_file_exists
  3438 00004058 7202                <1> 	jc .write_file
  3439 0000405A EB30                <1> 	jmp .file_exists_fail
  3440                              <1> 	
  3441                              <1> .write_file:
  3442                              <1> 
  3443 0000405C B8[B240]            <1> 	mov word ax, .tmp_filename
  3444 0000405F 8B1E[AE40]          <1> 	mov word bx, [.data_loc]
  3445 00004063 8B0E[B040]          <1> 	mov word cx, [.data_size]
  3446                              <1> 	
  3447 00004067 E8A0CB              <1> 	call os_write_file
  3448 0000406A 722D                <1> 	jc .save_failure
  3449                              <1> 
  3450 0000406C 31C0                <1> 	xor ax, ax
  3451 0000406E B052                <1> 	mov byte al, 'R'
  3452 00004070 31DB                <1> 	xor bx, bx
  3453 00004072 E88B02              <1> 	call set_var
  3454                              <1> 
  3455 00004075 E975EA              <1> 	jmp mainloop
  3456                              <1> 
  3457                              <1> 
  3458                              <1> .second_is_var:
  3459 00004078 0FB606007B          <1> 	movzx ax, byte [token]
  3460 0000407D E87302              <1> 	call get_var
  3461 00004080 EBB7                <1> 	jmp .set_data_loc
  3462                              <1> 
  3463                              <1> 
  3464                              <1> .third_is_var:
  3465 00004082 0FB606007B          <1> 	movzx ax, byte [token]
  3466 00004087 E86902              <1> 	call get_var
  3467 0000408A EBC3                <1> 	jmp .check_exists
  3468                              <1> 
  3469                              <1> .file_exists_fail:
  3470 0000408C 31C0                <1> 	xor ax, ax
  3471 0000408E B052                <1> 	mov byte al, 'R'
  3472 00004090 BB0200              <1> 	mov bx, 2
  3473 00004093 E86A02              <1> 	call set_var
  3474 00004096 E954EA              <1> 	jmp mainloop
  3475                              <1> 	
  3476                              <1> .save_failure:
  3477 00004099 31C0                <1> 	xor ax, ax
  3478 0000409B B052                <1> 	mov byte al, 'R'
  3479 0000409D BB0100              <1> 	mov bx, 1
  3480 000040A0 E85D02              <1> 	call set_var
  3481                              <1> 
  3482 000040A3 E947EA              <1> 	jmp mainloop
  3483                              <1> 
  3484                              <1> .error:
  3485 000040A6 BE1400              <1> 	mov si, err_syntax
  3486 000040A9 E97C03              <1> 	jmp error
  3487                              <1> 
  3488                              <1> 
  3489 000040AC 0000                <1> 	.filename_loc	dw 0
  3490 000040AE 0000                <1> 	.data_loc	dw 0
  3491 000040B0 0000                <1> 	.data_size	dw 0
  3492                              <1> 
  3493 000040B2 00<rep Fh>          <1> 	.tmp_filename	times 15 db 0
  3494                              <1> 
  3495                              <1> 
  3496                              <1> ; ------------------------------------------------------------------
  3497                              <1> ; SERIAL
  3498                              <1> 
  3499                              <1> do_serial:
  3500 000040C1 E84B02              <1> 	call get_token
  3501 000040C4 BE007B              <1> 	mov si, token
  3502                              <1> 
  3503 000040C7 BF[5941]            <1> 	mov di, .on_cmd
  3504 000040CA E880E7              <1> 	call os_string_compare
  3505 000040CD 7212                <1> 	jc .do_on_cmd
  3506                              <1> 
  3507 000040CF BF[5C41]            <1> 	mov di, .send_cmd
  3508 000040D2 E878E7              <1> 	call os_string_compare
  3509 000040D5 7237                <1> 	jc .do_send_cmd
  3510                              <1> 
  3511 000040D7 BF[6141]            <1> 	mov di, .rec_cmd
  3512 000040DA E870E7              <1> 	call os_string_compare
  3513 000040DD 7258                <1> 	jc .do_rec_cmd
  3514                              <1> 
  3515 000040DF EB72                <1> 	jmp .error
  3516                              <1> 
  3517                              <1> .do_on_cmd:
  3518 000040E1 E82B02              <1> 	call get_token
  3519 000040E4 83F803              <1> 	cmp ax, NUMBER
  3520 000040E7 7402                <1> 	je .do_on_cmd_ok
  3521 000040E9 EB68                <1> 	jmp .error
  3522                              <1> 
  3523                              <1> .do_on_cmd_ok:
  3524 000040EB BE007B              <1> 	mov si, token
  3525 000040EE E8B0E7              <1> 	call os_string_to_int
  3526 000040F1 3DB004              <1> 	cmp ax, 1200
  3527 000040F4 740F                <1> 	je .on_cmd_slow_mode
  3528 000040F6 3D8025              <1> 	cmp ax, 9600
  3529 000040F9 7402                <1> 	je .on_cmd_fast_mode
  3530                              <1> 
  3531 000040FB EB56                <1> 	jmp .error
  3532                              <1> 
  3533                              <1> .on_cmd_fast_mode:
  3534 000040FD 31C0                <1> 	xor ax, ax
  3535 000040FF E896D5              <1> 	call os_serial_port_enable
  3536 00004102 E9E8E9              <1> 	jmp mainloop
  3537                              <1> 
  3538                              <1> .on_cmd_slow_mode:
  3539 00004105 B80100              <1> 	mov ax, 1
  3540 00004108 E88DD5              <1> 	call os_serial_port_enable
  3541 0000410B E9DFE9              <1> 	jmp mainloop
  3542                              <1> 
  3543                              <1> 
  3544                              <1> .do_send_cmd:
  3545 0000410E E8FE01              <1> 	call get_token
  3546 00004111 83F803              <1> 	cmp ax, NUMBER
  3547 00004114 7407                <1> 	je .send_number
  3548                              <1> 
  3549 00004116 83F801              <1> 	cmp ax, VARIABLE
  3550 00004119 740E                <1> 	je .send_variable
  3551                              <1> 
  3552 0000411B EB36                <1> 	jmp .error
  3553                              <1> 
  3554                              <1> .send_number:
  3555 0000411D BE007B              <1> 	mov si, token
  3556 00004120 E87EE7              <1> 	call os_string_to_int
  3557 00004123 E886D5              <1> 	call os_send_via_serial
  3558 00004126 E9C4E9              <1> 	jmp mainloop
  3559                              <1> 
  3560                              <1> .send_variable:
  3561 00004129 0FB606007B          <1> 	movzx ax, byte [token]
  3562 0000412E E8C201              <1> 	call get_var
  3563 00004131 E878D5              <1> 	call os_send_via_serial
  3564 00004134 E9B6E9              <1> 	jmp mainloop
  3565                              <1> 
  3566                              <1> 
  3567                              <1> .do_rec_cmd:
  3568 00004137 E8D501              <1> 	call get_token
  3569 0000413A 83F801              <1> 	cmp ax, VARIABLE
  3570 0000413D 7514                <1> 	jne .error
  3571                              <1> 
  3572 0000413F A0007B              <1> 	mov byte al, [token]
  3573                              <1> 
  3574 00004142 0FB6C8              <1> 	movzx cx, al
  3575 00004145 E878D5              <1> 	call os_get_via_serial
  3576                              <1> 
  3577 00004148 0FB6D8              <1> 	movzx bx, al
  3578 0000414B 88C8                <1> 	mov al, cl
  3579 0000414D E8B001              <1> 	call set_var
  3580                              <1> 
  3581 00004150 E99AE9              <1> 	jmp mainloop
  3582                              <1> 
  3583                              <1> 
  3584                              <1> .error:
  3585 00004153 BE1400              <1> 	mov si, err_syntax
  3586 00004156 E9CF02              <1> 	jmp error
  3587                              <1> 
  3588                              <1> 
  3589 00004159 4F4E00              <1> 	.on_cmd		db "ON", 0
  3590 0000415C 53454E4400          <1> 	.send_cmd	db "SEND", 0
  3591 00004161 52454300            <1> 	.rec_cmd	db "REC", 0
  3592                              <1> 
  3593                              <1> 
  3594                              <1> ; ------------------------------------------------------------------
  3595                              <1> ; SIZE
  3596                              <1> 
  3597                              <1> do_size:
  3598 00004165 E8A701              <1> 	call get_token
  3599                              <1> 
  3600 00004168 83F802              <1> 	cmp ax, STRING_VAR
  3601 0000416B 7407                <1> 	je .is_string
  3602                              <1> 
  3603 0000416D 83F805              <1> 	cmp ax, QUOTE
  3604 00004170 7410                <1> 	je .is_quote
  3605                              <1> 
  3606 00004172 EB29                <1> 	jmp .error
  3607                              <1> 
  3608                              <1> .is_string:
  3609 00004174 BE007C              <1> 	mov si, string_vars
  3610 00004177 B88000              <1> 	mov ax, 128
  3611 0000417A F7E3                <1> 	mul bx
  3612 0000417C 01C6                <1> 	add si, ax
  3613                              <1> 
  3614 0000417E 89F0                <1> 	mov ax, si
  3615 00004180 EB03                <1> 	jmp .get_size
  3616                              <1> 
  3617                              <1> .is_quote:
  3618 00004182 B8007B              <1> 	mov ax, token
  3619                              <1> 
  3620                              <1> .get_size:
  3621 00004185 E8DACD              <1> 	call os_get_file_size
  3622 00004188 7219                <1> 	jc .file_not_found
  3623                              <1> 
  3624 0000418A 31C0                <1> 	xor ax, ax
  3625 0000418C B053                <1> 	mov al, 'S'
  3626 0000418E E86F01              <1> 	call set_var
  3627                              <1> 
  3628 00004191 31C0                <1> 	xor ax, ax
  3629 00004193 B052                <1> 	mov al, 'R'
  3630 00004195 31DB                <1> 	xor bx, bx
  3631 00004197 E86601              <1> 	call set_var
  3632                              <1> 
  3633 0000419A E950E9              <1> 	jmp mainloop
  3634                              <1> 
  3635                              <1> .error:
  3636 0000419D BE1400              <1> 	mov si, err_syntax
  3637 000041A0 E98502              <1> 	jmp error
  3638                              <1> 
  3639                              <1> .file_not_found:
  3640 000041A3 0FB606007B          <1> 	movzx ax, byte [token]
  3641 000041A8 89DB                <1> 	mov bx, bx
  3642 000041AA E85301              <1> 	call set_var
  3643                              <1> 
  3644 000041AD 31C0                <1> 	xor ax, ax
  3645 000041AF B052                <1> 	mov al, 'R'
  3646 000041B1 BB0100              <1> 	mov bx, 1
  3647 000041B4 E84901              <1>  	call set_var
  3648                              <1>  	
  3649 000041B7 E933E9              <1> 	jmp mainloop
  3650                              <1> 
  3651                              <1> 
  3652                              <1> 
  3653                              <1> ; ------------------------------------------------------------------
  3654                              <1> ; SOUND
  3655                              <1> 
  3656                              <1> do_sound:
  3657 000041BA E85201              <1> 	call get_token
  3658                              <1> 
  3659 000041BD 83F801              <1> 	cmp ax, VARIABLE
  3660 000041C0 7408                <1> 	je .first_is_var
  3661                              <1> 
  3662 000041C2 BE007B              <1> 	mov si, token
  3663 000041C5 E8D9E6              <1> 	call os_string_to_int
  3664 000041C8 EB08                <1> 	jmp .done_first
  3665                              <1> 
  3666                              <1> .first_is_var:
  3667 000041CA 0FB606007B          <1> 	movzx ax, byte [token]
  3668 000041CF E82101              <1> 	call get_var
  3669                              <1> 
  3670                              <1> .done_first:
  3671 000041D2 E8D9E1              <1> 	call os_speaker_tone
  3672                              <1> 
  3673 000041D5 E83701              <1> 	call get_token
  3674                              <1> 
  3675 000041D8 83F801              <1> 	cmp ax, VARIABLE
  3676 000041DB 7408                <1> 	je .second_is_var
  3677                              <1> 
  3678 000041DD BE007B              <1> 	mov si, token
  3679 000041E0 E8BEE6              <1> 	call os_string_to_int
  3680 000041E3 EB08                <1> 	jmp .finish
  3681                              <1> 
  3682                              <1> .second_is_var:
  3683 000041E5 0FB606007B          <1> 	movzx ax, byte [token]
  3684 000041EA E80601              <1> 	call get_var
  3685                              <1> 
  3686                              <1> .finish:
  3687 000041ED E83804              <1> 	call os_pause
  3688 000041F0 E81DE2              <1> 	call os_speaker_off
  3689                              <1> 
  3690 000041F3 E9F7E8              <1> 	jmp mainloop
  3691                              <1> 
  3692                              <1> 
  3693                              <1> ;-------------------------------------------------------------------
  3694                              <1> ; STRING
  3695                              <1> do_string:
  3696 000041F6 E81601              <1> 	call get_token			; The first parameter is the word 'GET' or 'SET'
  3697 000041F9 BE007B              <1> 	mov si, token
  3698                              <1> 	
  3699 000041FC BF[9F42]            <1> 	mov di, .get_cmd
  3700 000041FF E84BE6              <1> 	call os_string_compare
  3701 00004202 720B                <1> 	jc .set_str
  3702                              <1> 		
  3703 00004204 BF[A342]            <1> 	mov di, .set_cmd
  3704 00004207 E843E6              <1> 	call os_string_compare
  3705 0000420A 7208                <1> 	jc .get_str
  3706                              <1> 	
  3707 0000420C E98400              <1> 	jmp .error
  3708                              <1> 	
  3709                              <1> 	.set_str:
  3710 0000420F B90100              <1> 	mov cx, 1
  3711 00004212 EB03                <1> 	jmp .check_second
  3712                              <1> 	.get_str:
  3713 00004214 B90200              <1> 	mov cx, 2
  3714                              <1> 
  3715                              <1> .check_second:
  3716 00004217 E8F500              <1> 	call get_token			; The next should be a string variable, locate it
  3717                              <1> 	
  3718 0000421A 83F802              <1> 	cmp ax, STRING_VAR
  3719 0000421D 7574                <1> 	jne .error
  3720                              <1> 	
  3721 0000421F BE007C              <1> 	mov si, string_vars
  3722 00004222 B88000              <1> 	mov ax, 128
  3723 00004225 F7E3                <1> 	mul bx
  3724 00004227 01C6                <1> 	add si, ax
  3725 00004229 8936[A742]          <1> 	mov word [.string_loc], si
  3726                              <1> 	
  3727                              <1> .check_third:
  3728 0000422D E8DF00              <1> 	call get_token			; Now there should be a number
  3729                              <1> 	
  3730 00004230 83F803              <1> 	cmp ax, NUMBER
  3731 00004233 7407                <1> 	je .third_is_number
  3732                              <1> 	
  3733 00004235 83F801              <1> 	cmp ax, VARIABLE
  3734 00004238 740A                <1> 	je .third_is_variable
  3735                              <1> 	
  3736 0000423A EB57                <1> 	jmp .error
  3737                              <1> 	
  3738                              <1> .third_is_number:	
  3739 0000423C BE007B              <1> 	mov si, token
  3740 0000423F E85FE6              <1> 	call os_string_to_int
  3741 00004242 EB0A                <1> 	jmp .got_number	
  3742                              <1> 
  3743                              <1> .third_is_variable:
  3744                              <1> 	clr ah
    31 00004244 30E4                <2>  xor %1, %1
  3745 00004246 A0007B              <1> 	mov al, [token]
  3746 00004249 E8A700              <1> 	call get_var
  3747 0000424C EB00                <1> 	jmp .got_number
  3748                              <1> 
  3749                              <1> .got_number:
  3750 0000424E 3D8000              <1> 	cmp ax, 128
  3751 00004251 7F46                <1> 	jg .outrange
  3752 00004253 85C0                <1> 	test ax, ax
  3753 00004255 7442                <1> 	jz .outrange
  3754 00004257 83E801              <1> 	sub ax, 1
  3755 0000425A 89C2                <1> 	mov dx, ax
  3756                              <1> 	
  3757                              <1> .check_forth:
  3758 0000425C E8B000              <1> 	call get_token			; Next a numerical variable
  3759                              <1> 	
  3760 0000425F 83F801              <1> 	cmp ax, VARIABLE
  3761 00004262 752F                <1> 	jne .error
  3762                              <1> 	
  3763 00004264 A0007B              <1> 	mov byte al, [token]
  3764 00004267 A2[A942]            <1> 	mov byte [.tmp], al
  3765                              <1> 	
  3766 0000426A 83F902              <1> 	cmp cx, 2
  3767 0000426D 7414                <1> 	je .set_var
  3768                              <1> 	
  3769                              <1> .get_var:
  3770 0000426F 8B36[A742]          <1> 	mov word si, [.string_loc]	; Move to string location
  3771 00004273 01D6                <1> 	add si, dx			; Add offset
  3772 00004275 AC                  <1> 	lodsb				; Load data
  3773                              <1> 	clr ah
    31 00004276 30E4                <2>  xor %1, %1
  3774 00004278 89C3                <1> 	mov bx, ax			; Set data in numerical variable
  3775 0000427A A0[A942]            <1> 	mov byte al, [.tmp]
  3776 0000427D E88000              <1> 	call set_var
  3777 00004280 E96AE8              <1> 	jmp mainloop
  3778                              <1> 	
  3779                              <1> .set_var:
  3780 00004283 A0[A942]            <1> 	mov byte al, [.tmp]		; Retrieve the variable
  3781 00004286 E86A00              <1> 	call get_var			; Get it's value
  3782 00004289 8B3E[A742]          <1> 	mov di, [.string_loc]		; Locate the string
  3783 0000428D 01D7                <1> 	add di, dx			; Add the offset
  3784 0000428F AA                  <1> 	stosb				; Store data
  3785 00004290 E95AE8              <1> 	jmp mainloop
  3786                              <1> 	
  3787                              <1> .error:
  3788 00004293 BE1400              <1> 	mov si, err_syntax
  3789 00004296 E98F01              <1> 	jmp error
  3790                              <1> 	
  3791                              <1> .outrange:
  3792 00004299 BE1300              <1> 	mov si, err_string_range
  3793 0000429C E98901              <1> 	jmp error
  3794                              <1> 
  3795                              <1> .data:
  3796 0000429F 47455400            <1> 	.get_cmd		db "GET", 0
  3797 000042A3 53455400            <1> 	.set_cmd		db "SET", 0
  3798 000042A7 0000                <1> 	.string_loc		dw 0
  3799 000042A9 00                  <1> 	.tmp			db 0
  3800                              <1> 
  3801                              <1> 
  3802                              <1> 
  3803                              <1> ; ------------------------------------------------------------------
  3804                              <1> ; WAITKEY
  3805                              <1> 
  3806                              <1> do_waitkey:
  3807 000042AA E86200              <1> 	call get_token
  3808 000042AD 83F801              <1> 	cmp ax, VARIABLE
  3809 000042B0 7406                <1> 	je .is_variable
  3810                              <1> 
  3811 000042B2 BE1400              <1> 	mov si, err_syntax
  3812 000042B5 E97001              <1> 	jmp error
  3813                              <1> 
  3814                              <1> .is_variable:
  3815 000042B8 0FB606007B          <1> 	movzx ax, byte [token]
  3816                              <1> 
  3817 000042BD 50                  <1> 	push ax
  3818                              <1> 
  3819 000042BE E8C4CE              <1> 	call os_wait_for_key
  3820                              <1> 
  3821 000042C1 80FC48              <1> 	cmp ah, 48h
  3822 000042C4 7419                <1> 	je .up_pressed
  3823                              <1> 	
  3824 000042C6 80FC50              <1> 	cmp ah, 50h
  3825 000042C9 7419                <1> 	je .down_pressed
  3826                              <1> 
  3827 000042CB 80FC4B              <1> 	cmp ah, 4Bh
  3828 000042CE 7419                <1> 	je .left_pressed
  3829                              <1> 
  3830 000042D0 80FC4D              <1> 	cmp ah, 4Dh
  3831 000042D3 7419                <1> 	je .right_pressed
  3832                              <1> 
  3833                              <1> .store:
  3834 000042D5 0FB6D8              <1> 	movzx bx, al
  3835                              <1> 
  3836 000042D8 58                  <1> 	pop ax
  3837                              <1> 
  3838 000042D9 E82400              <1> 	call set_var
  3839                              <1> 
  3840 000042DC E90EE8              <1> 	jmp mainloop
  3841                              <1> 
  3842                              <1> 
  3843                              <1> .up_pressed:
  3844 000042DF B80100              <1> 	mov ax, 1
  3845 000042E2 EBF1                <1> 	jmp .store
  3846                              <1> 
  3847                              <1> .down_pressed:
  3848 000042E4 B80200              <1> 	mov ax, 2
  3849 000042E7 EBEC                <1> 	jmp .store
  3850                              <1> 
  3851                              <1> .left_pressed:
  3852 000042E9 B80300              <1> 	mov ax, 3
  3853 000042EC EBE7                <1> 	jmp .store
  3854                              <1> 
  3855                              <1> .right_pressed:
  3856 000042EE B80400              <1> 	mov ax, 4
  3857 000042F1 EBE2                <1> 	jmp .store
  3858                              <1> 
  3859                              <1> 
  3860                              <1> ; ==================================================================
  3861                              <1> ; INTERNAL ROUTINES FOR INTERPRETER
  3862                              <1> 
  3863                              <1> ; ------------------------------------------------------------------
  3864                              <1> ; Get value of variable character specified in AL (eg 'A')
  3865                              <1> 
  3866                              <1> get_var:
  3867                              <1> 	clr ah
    31 000042F3 30E4                <2>  xor %1, %1
  3868 000042F5 2C41                <1> 	sub al, 65
  3869 000042F7 BE4C7A              <1> 	mov si, variables
  3870 000042FA 01C6                <1> 	add si, ax
  3871 000042FC 01C6                <1> 	add si, ax
  3872 000042FE AD                  <1> 	lodsw
  3873 000042FF C3                  <1> 	ret
  3874                              <1> 
  3875                              <1> 
  3876                              <1> ; ------------------------------------------------------------------
  3877                              <1> ; Set value of variable character specified in AL (eg 'A')
  3878                              <1> ; with number specified in BX
  3879                              <1> 
  3880                              <1> set_var:
  3881                              <1> 	clr ah
    31 00004300 30E4                <2>  xor %1, %1
  3882 00004302 2C41                <1> 	sub al, 65				; Remove ASCII codes before 'A'
  3883                              <1> 
  3884 00004304 BF4C7A              <1> 	mov di, variables			; Find position in table (of words)
  3885 00004307 01C7                <1> 	add di, ax
  3886 00004309 01C7                <1> 	add di, ax
  3887 0000430B 89D8                <1> 	mov ax, bx
  3888 0000430D AB                  <1> 	stosw
  3889 0000430E C3                  <1> 	ret
  3890                              <1> 
  3891                              <1> 
  3892                              <1> ; ------------------------------------------------------------------
  3893                              <1> ; Get token from current position in prog
  3894                              <1> 
  3895                              <1> get_token:
  3896 0000430F 8B36[8E44]          <1> 	mov word si, [prog]
  3897 00004313 AC                  <1> 	lodsb
  3898                              <1> 
  3899 00004314 3C0A                <1> 	cmp al, 10
  3900 00004316 741A                <1> 	je .newline
  3901                              <1> 
  3902 00004318 3C20                <1> 	cmp al, ' '
  3903 0000431A 7416                <1> 	je .newline
  3904                              <1> 
  3905 0000431C E8F100              <1> 	call is_number
  3906 0000431F 7217                <1> 	jc get_number_token
  3907                              <1> 
  3908 00004321 3C22                <1> 	cmp al, '"'
  3909 00004323 745F                <1> 	je get_quote_token
  3910                              <1> 
  3911 00004325 3C27                <1> 	cmp al, 39			; Quote mark (')
  3912 00004327 7438                <1> 	je get_char_token
  3913                              <1> 
  3914 00004329 3C24                <1> 	cmp al, '$'
  3915 0000432B 0F848000            <1> 	je get_string_var_token
  3916                              <1> 
  3917 0000432F E99000              <1> 	jmp get_string_token
  3918                              <1> 
  3919                              <1> 
  3920                              <1> .newline:
  3921 00004332 FF06[8E44]          <1> 	inc word [prog]
  3922 00004336 EBD7                <1> 	jmp get_token
  3923                              <1> 
  3924                              <1> 
  3925                              <1> 
  3926                              <1> get_number_token:
  3927 00004338 8B36[8E44]          <1> 	mov word si, [prog]
  3928 0000433C BF007B              <1> 	mov di, token
  3929                              <1> 
  3930                              <1> .loop:
  3931 0000433F AC                  <1> 	lodsb
  3932 00004340 3C0A                <1> 	cmp al, 10
  3933 00004342 7416                <1> 	je .done
  3934 00004344 3C20                <1> 	cmp al, ' '
  3935 00004346 7412                <1> 	je .done
  3936 00004348 E8C500              <1> 	call is_number
  3937 0000434B 7206                <1> 	jc .fine
  3938                              <1> 
  3939 0000434D BE0000              <1> 	mov si, err_char_in_num
  3940 00004350 E9D500              <1> 	jmp error
  3941                              <1> 
  3942                              <1> .fine:
  3943 00004353 AA                  <1> 	stosb
  3944 00004354 FF06[8E44]          <1> 	inc word [prog]
  3945 00004358 EBE5                <1> 	jmp .loop
  3946                              <1> 
  3947                              <1> .done:
  3948                              <1> 	clr al				; Zero-terminate the token
    31 0000435A 30C0                <2>  xor %1, %1
  3949 0000435C AA                  <1> 	stosb
  3950                              <1> 
  3951 0000435D B80300              <1> 	mov ax, NUMBER			; Pass back the token type
  3952 00004360 C3                  <1> 	ret
  3953                              <1> 
  3954                              <1> 
  3955                              <1> get_char_token:
  3956 00004361 FF06[8E44]          <1> 	inc word [prog]			; Move past first quote (')
  3957                              <1> 
  3958 00004365 8B36[8E44]          <1> 	mov word si, [prog]
  3959 00004369 AC                  <1> 	lodsb
  3960                              <1> 
  3961 0000436A A2007B              <1> 	mov byte [token], al
  3962                              <1> 
  3963 0000436D AC                  <1> 	lodsb
  3964 0000436E 3C27                <1> 	cmp al, 39			; Needs to finish with another quote
  3965 00004370 7406                <1> 	je .is_ok
  3966                              <1> 
  3967 00004372 BE1100              <1> 	mov si, err_quote_term
  3968 00004375 E9B000              <1> 	jmp error
  3969                              <1> 
  3970                              <1> .is_ok:
  3971 00004378 FF06[8E44]          <1> 	inc word [prog]
  3972 0000437C FF06[8E44]          <1> 	inc word [prog]
  3973                              <1> 
  3974 00004380 B80600              <1> 	mov ax, CHAR
  3975 00004383 C3                  <1> 	ret
  3976                              <1> 
  3977                              <1> 
  3978                              <1> get_quote_token:
  3979 00004384 FF06[8E44]          <1> 	inc word [prog]			; Move past first quote (") char
  3980 00004388 8B36[8E44]          <1> 	mov word si, [prog]
  3981 0000438C BF007B              <1> 	mov di, token
  3982                              <1> .loop:
  3983 0000438F AC                  <1> 	lodsb
  3984 00004390 3C22                <1> 	cmp al, '"'
  3985 00004392 740B                <1> 	je .done
  3986 00004394 3C0A                <1> 	cmp al, 10
  3987 00004396 7412                <1> 	je .error
  3988 00004398 AA                  <1> 	stosb
  3989 00004399 FF06[8E44]          <1> 	inc word [prog]
  3990 0000439D EBF0                <1> 	jmp .loop
  3991                              <1> 
  3992                              <1> .done:
  3993                              <1> 	clr al				; Zero-terminate the token
    31 0000439F 30C0                <2>  xor %1, %1
  3994 000043A1 AA                  <1> 	stosb
  3995 000043A2 FF06[8E44]          <1> 	inc word [prog]			; Move past final quote
  3996                              <1> 
  3997 000043A6 B80500              <1> 	mov ax, QUOTE			; Pass back token type
  3998 000043A9 C3                  <1> 	ret
  3999                              <1> 
  4000                              <1> .error:
  4001 000043AA BE1100              <1> 	mov si, err_quote_term
  4002 000043AD EB79                <1> 	jmp error
  4003                              <1> 
  4004                              <1> 
  4005                              <1> get_string_var_token:
  4006 000043AF AC                  <1> 	lodsb
  4007 000043B0 0FB6D8              <1> 	movzx bx, al
  4008 000043B3 80EB31              <1> 	sub bl, 49
  4009                              <1> 
  4010 000043B6 FF06[8E44]          <1> 	inc word [prog]
  4011 000043BA FF06[8E44]          <1> 	inc word [prog]
  4012                              <1> 
  4013 000043BE B80200              <1> 	mov ax, STRING_VAR
  4014 000043C1 C3                  <1> 	ret
  4015                              <1> 	
  4016                              <1> 
  4017                              <1> get_string_token:
  4018 000043C2 8B36[8E44]          <1> 	mov word si, [prog]
  4019 000043C6 BF007B              <1> 	mov di, token
  4020                              <1> .loop:
  4021 000043C9 AC                  <1> 	lodsb
  4022 000043CA 3C0A                <1> 	cmp al, 10
  4023 000043CC 740B                <1> 	je .done
  4024 000043CE 3C20                <1> 	cmp al, ' '
  4025 000043D0 7407                <1> 	je .done
  4026 000043D2 AA                  <1> 	stosb
  4027 000043D3 FF06[8E44]          <1> 	inc word [prog]
  4028 000043D7 EBF0                <1> 	jmp .loop
  4029                              <1> .done:
  4030                              <1> 	clr al				; Zero-terminate the token
    31 000043D9 30C0                <2>  xor %1, %1
  4031 000043DB AA                  <1> 	stosb
  4032                              <1> 
  4033 000043DC B8007B              <1> 	mov ax, token
  4034 000043DF E8D4E3              <1> 	call os_string_uppercase
  4035                              <1> 
  4036 000043E2 B8007B              <1> 	mov ax, token
  4037 000043E5 E883E3              <1> 	call os_string_length		; How long was the token?
  4038 000043E8 83F801              <1> 	cmp ax, 1			; If 1 char, it's a variable or delimiter
  4039 000043EB 7413                <1> 	je .is_not_string
  4040                              <1> 
  4041 000043ED BE007B              <1> 	mov si, token			; If the token ends with ':', it's a label
  4042 000043F0 01C6                <1> 	add si, ax
  4043 000043F2 4E                  <1> 	dec si
  4044 000043F3 AC                  <1> 	lodsb
  4045 000043F4 3C3A                <1> 	cmp al, ':'
  4046 000043F6 7404                <1> 	je .is_label
  4047                              <1> 
  4048 000043F8 B80400              <1> 	mov ax, STRING			; Otherwise it's a general string of characters
  4049 000043FB C3                  <1> 	ret
  4050                              <1> 
  4051                              <1> .is_label:
  4052 000043FC B80800              <1> 	mov ax, LABEL
  4053 000043FF C3                  <1> 	ret
  4054                              <1> 
  4055                              <1> 
  4056                              <1> .is_not_string:
  4057 00004400 A0007B              <1> 	mov byte al, [token]
  4058 00004403 E81600              <1> 	call is_letter
  4059 00004406 7204                <1> 	jc .is_var
  4060                              <1> 
  4061 00004408 B80700              <1> 	mov ax, UNKNOWN
  4062 0000440B C3                  <1> 	ret
  4063                              <1> 
  4064                              <1> .is_var:
  4065 0000440C B80100              <1> 	mov ax, VARIABLE		; Otherwise probably a variable
  4066 0000440F C3                  <1> 	ret
  4067                              <1> 
  4068                              <1> 
  4069                              <1> ; ------------------------------------------------------------------
  4070                              <1> ; Set carry flag if AL contains ASCII number
  4071                              <1> 
  4072                              <1> is_number:
  4073 00004410 3C30                <1> 	cmp al, 48
  4074 00004412 7C06                <1> 	jl .not_number
  4075 00004414 3C39                <1> 	cmp al, 57
  4076 00004416 7F02                <1> 	jg .not_number
  4077 00004418 F9                  <1> 	stc
  4078 00004419 C3                  <1> 	ret
  4079                              <1> .not_number:
  4080 0000441A F8                  <1> 	clc
  4081 0000441B C3                  <1> 	ret
  4082                              <1> 
  4083                              <1> 
  4084                              <1> ; ------------------------------------------------------------------
  4085                              <1> ; Set carry flag if AL contains ASCII letter
  4086                              <1> 
  4087                              <1> is_letter:
  4088 0000441C 3C41                <1> 	cmp al, 65
  4089 0000441E 7C06                <1> 	jl .not_letter
  4090 00004420 3C5A                <1> 	cmp al, 90
  4091 00004422 7F02                <1> 	jg .not_letter
  4092 00004424 F9                  <1> 	stc
  4093 00004425 C3                  <1> 	ret
  4094                              <1> 
  4095                              <1> .not_letter:
  4096 00004426 F8                  <1> 	clc
  4097 00004427 C3                  <1> 	ret
  4098                              <1> 
  4099                              <1> 
  4100                              <1> ; ------------------------------------------------------------------
  4101                              <1> ; Print error message and quit out
  4102                              <1> 
  4103                              <1> error:
  4104 00004428 B80005              <1> 	mov ax, 5 * 256			; Revert display page
  4105 0000442B CD10                <1> 	int 10h
  4106                              <1> 
  4107 0000442D E822DA              <1> 	call os_print_newline
  4108 00004430 BE[6F44]            <1> 	mov si, err_msg
  4109 00004433 E8B4D2              <1> 	call os_print_string
  4110                              <1> 	
  4111 00004436 88D8                <1> 	mov al, bl
  4112 00004438 E8DADB              <1> 	call os_print_2hex
  4113                              <1> 	
  4114 0000443B C606[9844]00        <1> 	mov byte [work_page], 0
  4115 00004440 C606[9944]00        <1> 	mov byte [disp_page], 0
  4116                              <1> 
  4117 00004445 BE[8344]            <1> 	mov si, line_num_starter
  4118 00004448 E89FD2              <1> 	call os_print_string
  4119                              <1> 
  4120                              <1> 
  4121                              <1> 	; And now print the line number where the error occurred. We do this
  4122                              <1> 	; by working from the start of the program to the current point,
  4123                              <1> 	; counting the number of newline characters along the way
  4124                              <1> 
  4125 0000444B 8B36[9244]          <1> 	mov word si, [load_point]
  4126 0000444F 8B1E[8E44]          <1> 	mov word bx, [prog]
  4127 00004453 B90100              <1> 	mov cx, 1
  4128                              <1> 
  4129                              <1> .loop:
  4130 00004456 AC                  <1> 	lodsb
  4131 00004457 3C0A                <1> 	cmp al, 10
  4132 00004459 7501                <1> 	jne .not_newline
  4133 0000445B 41                  <1> 	inc cx
  4134                              <1> .not_newline:
  4135 0000445C 39DE                <1> 	cmp si, bx
  4136 0000445E 7402                <1> 	je .finish
  4137 00004460 EBF4                <1> 	jmp .loop
  4138                              <1> .finish:
  4139                              <1> 
  4140 00004462 89C8                <1> 	mov ax, cx
  4141 00004464 E8D2DB              <1> 	call os_print_int
  4142                              <1> 
  4143 00004467 E8E8D9              <1> 	call os_print_newline
  4144                              <1> 
  4145 0000446A 8B26[8C44]          <1> 	mov word sp, [orig_stack]	; Restore the stack to as it was when BASIC started
  4146                              <1> 
  4147 0000446E C3                  <1> 	ret				; And finish
  4148                              <1> 
  4149                              <1> 
  4150                              <1> 	; Error messages text...
  4151                              <1> 
  4152                              <1> 	err_char_in_num		equ 00h
  4153                              <1> 	err_cmd_unknown		equ 01h
  4154                              <1> 	err_divide_by_zero	equ 02h
  4155                              <1> 	err_doloop_maximum	equ 03h
  4156                              <1> 	err_file_notfound	equ 04h
  4157                              <1> 	err_goto_notlabel	equ 05h
  4158                              <1> 	err_label_notfound	equ 06h
  4159                              <1> 	err_nest_limit		equ 07h
  4160                              <1> 	err_next			equ 08h
  4161                              <1> 	err_loop			equ 09h
  4162                              <1> 	err_print_type		equ 10h
  4163                              <1> 	err_quote_term		equ 11h
  4164                              <1> 	err_return			equ 12h
  4165                              <1> 	err_string_range	equ 13h
  4166                              <1> 	err_syntax			equ 14h
  4167                              <1> 
  4168 0000446F 4572726F722000      <1> 	err_msg				db "Error ", 0
  4169                              <1> 
  4170 00004476 425245414B2043414C- <1> 	err_break			db "BREAK CALLED", 0
  4170 0000447F 4C454400            <1>
  4171                              <1> 
  4172 00004483 202D206C696E652000  <1> 	line_num_starter	db " - line ", 0
  4173                              <1> 
  4174                              <1> 
  4175                              <1> ; ==================================================================
  4176                              <1> ; DATA SECTION
  4177                              <1> 
  4178 0000448C 0000                <1> 	orig_stack		dw 0		; Original stack location when BASIC started
  4179                              <1> 
  4180 0000448E 0000                <1> 	prog			dw 0		; Pointer to current location in BASIC code
  4181 00004490 0000                <1> 	prog_end		dw 0		; Pointer to final byte of BASIC code
  4182                              <1> 
  4183 00004492 0000                <1> 	load_point		dw 0
  4184                              <1> 
  4185 00004494 00                  <1> 	token_type		db 0		; Type of last token read (eg NUMBER, VARIABLE)
  4186                              <1> 	token			equ 32768-1024-256
  4187                              <1> 
  4188                              <1> vars_loc:
  4189                              <1> ;	variables		times 26 dw 0	; Storage space for variables A to Z
  4190                              <1> 	variables		equ 32768-1024-384-52	; Storage space for variables A to Z
  4191                              <1> 
  4192                              <1> ;	for_variables		times 26 dw 0	; Storage for FOR loops
  4193                              <1> 	for_variables		equ 32768-1024-384-104	; Storage for FOR loops
  4194                              <1> ;	for_code_points		times 26 dw 0	; Storage for code positions where FOR loops start
  4195                              <1> 	for_code_points		equ 32768-1024-384-156	; Storage for code positions where FOR loops start
  4196                              <1> 	
  4197                              <1> ;	do_loop_store		times 10 dw 0	; Storage for DO loops
  4198                              <1> 	do_loop_store		equ 32768-1024-384-176	; Storage for DO loops
  4199 00004495 00                  <1> 	loop_in			db 0		; Loop level
  4200                              <1> 
  4201 00004496 01                  <1> 	last_if_true		db 1		; Checking for 'ELSE'
  4202                              <1> 
  4203 00004497 00                  <1> 	ink_colour		db 0		; Text printing colour
  4204 00004498 00                  <1> 	work_page		db 0		; Page to print to
  4205 00004499 00                  <1> 	disp_page		db 0		; Page to display
  4206                              <1> 	
  4207 0000449A 414C45525400        <1> 	alert_cmd			db "ALERT", 0
  4208 000044A0 41534B46494C4500    <1> 	askfile_cmd			db "ASKFILE", 0
  4209 000044A8 425245414B00        <1> 	break_cmd			db "BREAK", 0
  4210 000044AE 43414C4C00          <1> 	call_cmd			db "CALL", 0
  4211 000044B3 4341534500          <1> 	case_cmd			db "CASE", 0
  4212 000044B8 434C5300            <1> 	cls_cmd				db "CLS", 0
  4213 000044BC 435552534F5200      <1> 	cursor_cmd			db "CURSOR", 0
  4214 000044C3 435552534348415200  <1> 	curschar_cmd		db "CURSCHAR", 0
  4215 000044CC 43555253434F4C00    <1> 	curscol_cmd			db "CURSCOL", 0
  4216 000044D4 43555253504F5300    <1> 	curspos_cmd			db "CURSPOS", 0
  4217 000044DC 44454C45544500      <1> 	delete_cmd			db "DELETE", 0
  4218 000044E3 444F00              <1> 	do_cmd				db "DO", 0
  4219 000044E6 454C534500          <1> 	else_cmd			db "ELSE", 0
  4220 000044EB 454E4400            <1> 	end_cmd				db "END", 0
  4221 000044EF 46494C455300        <1> 	files_cmd			db "FILES", 0
  4222 000044F5 464F5200            <1> 	for_cmd 			db "FOR", 0
  4223 000044F9 474F53554200        <1> 	gosub_cmd			db "GOSUB", 0
  4224 000044FF 474F544F00          <1> 	goto_cmd			db "GOTO", 0
  4225 00004504 4745544B455900      <1> 	getkey_cmd			db "GETKEY", 0
  4226 0000450B 494600              <1> 	if_cmd 				db "IF", 0
  4227 0000450E 494E434C55444500    <1> 	include_cmd			db "INCLUDE", 0
  4228 00004516 494E4B00            <1> 	ink_cmd				db "INK", 0
  4229 0000451A 494E50555400        <1> 	input_cmd 			db "INPUT", 0
  4230 00004520 4C454E00            <1> 	len_cmd				db "LEN", 0
  4231 00004524 4C495354424F5800    <1> 	listbox_cmd			db "LISTBOX", 0
  4232 0000452C 4C4F414400          <1> 	load_cmd			db "LOAD", 0
  4233 00004531 4C4F4F5000          <1> 	loop_cmd			db "LOOP", 0
  4234 00004536 4D4F564500          <1> 	move_cmd 			db "MOVE", 0
  4235 0000453B 4E45585400          <1> 	next_cmd 			db "NEXT", 0
  4236 00004540 4E554D42455200      <1> 	number_cmd			db "NUMBER", 0
  4237 00004547 5041474500          <1> 	page_cmd			db "PAGE", 0
  4238 0000454C 504155534500        <1> 	pause_cmd 			db "PAUSE", 0
  4239 00004552 5045454B00          <1> 	peek_cmd			db "PEEK", 0
  4240 00004557 5045454B494E5400    <1> 	peekint_cmd			db "PEEKINT", 0
  4241 0000455F 504F4B4500          <1> 	poke_cmd			db "POKE", 0
  4242 00004564 504F4B45494E5400    <1> 	pokeint_cmd			db "POKEINT", 0
  4243 0000456C 504F525400          <1> 	port_cmd			db "PORT", 0
  4244 00004571 5052494E5400        <1> 	print_cmd 			db "PRINT", 0
  4245 00004577 52414E4400          <1> 	rand_cmd			db "RAND", 0
  4246 0000457C 5245414400          <1> 	read_cmd			db "READ", 0
  4247 00004581 52454D00            <1> 	rem_cmd				db "REM", 0
  4248 00004585 52454E414D4500      <1> 	rename_cmd			db "RENAME", 0
  4249 0000458C 52455455524E00      <1> 	return_cmd			db "RETURN", 0
  4250 00004593 5341564500          <1> 	save_cmd			db "SAVE", 0
  4251 00004598 53455249414C00      <1> 	serial_cmd			db "SERIAL", 0
  4252 0000459F 53495A4500          <1> 	size_cmd			db "SIZE", 0
  4253 000045A4 534F554E4400        <1> 	sound_cmd 			db "SOUND", 0
  4254 000045AA 535452494E4700      <1> 	string_cmd			db "STRING", 0
  4255 000045B1 574149544B455900    <1> 	waitkey_cmd			db "WAITKEY", 0
  4256                              <1> 
  4257 000045B9 414E4400            <1> 	and_keyword			db "AND", 0
  4258 000045BD 5448454E00          <1> 	then_keyword		db "THEN", 0
  4259 000045C2 43485200            <1> 	chr_keyword			db "CHR", 0
  4260 000045C6 48455800            <1> 	hex_keyword			db "HEX", 0
  4261                              <1> 	
  4262 000045CA 4C4F57455200        <1> 	lower_keyword		db "LOWER", 0
  4263 000045D0 555050455200        <1> 	upper_keyword		db "UPPER", 0
  4264                              <1> 
  4265 000045D6 494E4B00            <1> 	ink_keyword			db "INK", 0
  4266 000045DA 50524F475354415254- <1> 	progstart_keyword	db "PROGSTART", 0
  4266 000045E3 00                  <1>
  4267 000045E4 52414D535441525400  <1> 	ramstart_keyword	db "RAMSTART", 0
  4268 000045ED 54494D455200        <1> 	timer_keyword		db "TIMER", 0
  4269 000045F3 5641524941424C4553- <1> 	variables_keyword	db "VARIABLES", 0
  4269 000045FC 00                  <1>
  4270 000045FD 56455253494F4E00    <1> 	version_keyword		db "VERSION", 0
  4271                              <1> 
  4272 00004605 00                  <1> 	gosub_depth		db 0
  4273                              <1> 	gosub_points		equ 32768-1024-384-196	; Points in code to RETURN to
  4274                              <1> 
  4275                              <1> 	string_vars		equ 32768-1024
  4276                              <1> 
  4277                              <1> ; ==================================================================
   530                                  	%INCLUDE "features/int.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Interrupt management & app timer functions
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; -----------------------------------------------------------------
     6                              <1> ; os_modify_int_handler -- Change location of interrupt handler
     7                              <1> ; IN: CL = int number, DI:SI = handler location
     8                              <1> ; OUT: None, registers preserved
     9                              <1> 
    10                              <1> os_modify_int_handler:
    11 00004606 60                  <1> 	pusha
    12                              <1> 
    13                              <1> .no_pusha:
    14 00004607 FA                  <1> 	cli
    15                              <1> 
    16 00004608 0FB6D9              <1> 	movzx bx, cl		; Move supplied int into BX
    17 0000460B C1E302              <1> 	shl bx, 2			; Multiply by four to get position
    18                              <1> 	
    19 0000460E 648937              <1> 	mov [fs:bx], si		; First store offset
    20 00004611 64897F02            <1> 	mov [fs:bx + 2], di	; Then segment of our handler
    21                              <1> 	
    22 00004615 FB                  <1> 	sti
    23 00004616 61                  <1> 	popa
    24 00004617 C3                  <1> 	ret
    25                              <1> 
    26                              <1> ; -----------------------------------------------------------------
    27                              <1> ; os_get_int_handler -- Change location of interrupt handler
    28                              <1> ; IN: CL = int number
    29                              <1> ; OUT: DI:SI = handler location
    30                              <1> 
    31                              <1> os_get_int_handler:
    32 00004618 53                  <1> 	push bx
    33                              <1> 
    34 00004619 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
    35 0000461C C1E302              <1> 	shl bx, 2			; Multiply by four to get position
    36                              <1> 	
    37 0000461F 648B37              <1> 	mov si, [fs:bx]		; First store offset
    38 00004622 648B7F02            <1> 	mov di, [fs:bx + 2]	; Then segment of our handler
    39                              <1> 
    40 00004626 5B                  <1> 	pop bx
    41 00004627 C3                  <1> 	ret
    42                              <1> 
    43                              <1> ; ------------------------------------------------------------------
    44                              <1> ; os_pause -- Delay execution for a specified number of ticks (18.2 Hz by default)
    45                              <1> ; IN: AX = amount of ticks to wait
    46                              <1> ; OUT: None, registers preserved
    47                              <1> 
    48                              <1> os_pause:
    49 00004628 2EA3[7247]          <1> 	mov [cs:pause_timer], ax
    50                              <1> 
    51                              <1> .wait_loop:
    52 0000462C 2E833E[7247]00      <1> 	cmp word [cs:pause_timer], 0
    53 00004632 75F8                <1> 	jne .wait_loop
    54 00004634 C3                  <1> 	ret
    55                              <1> 
    56                              <1> ; -----------------------------------------------------------------
    57                              <1> ; os_attach_app_timer -- Attach a timer interrupt to an application and sets the timer speed
    58                              <1> ; Formula: speed = (105000000 / 88) / frequency
    59                              <1> ; IN: DS:SI = handler location, CX = speed
    60                              <1> ; OUT: None, registers preserved
    61                              <1> 
    62                              <1> os_attach_app_timer:
    63 00004635 60                  <1> 	pusha
    64 00004636 2EC606[6347]00      <1> 	mov byte [cs:timer_application_attached], 0
    65                              <1> 
    66 0000463C 85F6                <1> 	test si, si
    67 0000463E 7428                <1> 	jz os_set_timer_speed.no_pusha
    68                              <1> 
    69 00004640 2E8936[6447]        <1> 	mov [cs:timer_application_offset], si
    70 00004645 2E8C1E[6647]        <1> 	mov [cs:timer_application_segment], ds
    71 0000464A 2EC606[6347]01      <1> 	mov byte [cs:timer_application_attached], 1
    72                              <1> 	
    73 00004650 EB16                <1> 	jmp os_set_timer_speed.no_pusha
    74                              <1> 	
    75                              <1> ; -----------------------------------------------------------------
    76                              <1> ; os_return_app_timer -- Returns the timer interrupt back to the system and resets the timer speed
    77                              <1> ; IN/OUT: None, registers preserved
    78                              <1> 
    79                              <1> os_return_app_timer:
    80 00004652 60                  <1> 	pusha
    81 00004653 2EC606[6347]00      <1> 	mov byte [cs:timer_application_attached], 0
    82                              <1> 	
    83                              <1> 	clr cx
    31 00004659 31C9                <2>  xor %1, %1
    84 0000465B E80900              <1> 	call os_set_timer_speed
    85                              <1> 	
    86 0000465E B11C                <1> 	mov cl, 1Ch					; RTC handler
    87 00004660 BE[F846]            <1> 	mov si, os_compat_int1C
    88 00004663 8CCF                <1> 	mov di, cs
    89 00004665 EBA0                <1> 	jmp os_modify_int_handler.no_pusha
    90                              <1> 	
    91                              <1> ; -----------------------------------------------------------------
    92                              <1> ; os_set_timer_speed -- Sets the timer's trigger speed.
    93                              <1> ; Formula: speed = (105000000 / 88) / frequency
    94                              <1> ; IN: CX = speed
    95                              <1> ; OUT: Nothing, registers preserved
    96                              <1> 
    97                              <1> os_set_timer_speed:
    98 00004667 60                  <1> 	pusha
    99                              <1> 	
   100                              <1> .no_pusha:
   101 00004668 2E890E[6847]        <1> 	mov [cs:current_timer_speed], cx
   102                              <1> 	
   103 0000466D B036                <1> 	mov al, 00110110b	; Timer 0, square wave
   104 0000466F E643                <1> 	out 43h, al
   105 00004671 88C8                <1> 	mov al, cl
   106 00004673 E640                <1> 	out 40h, al
   107 00004675 88E8                <1> 	mov al, ch
   108 00004677 E640                <1> 	out 40h, al
   109                              <1> 
   110 00004679 6660                <1> 	pushad
   111                              <1> 	clr edx
    31 0000467B 6631D2              <2>  xor %1, %1
   112 0000467E 66B8FD634404        <1> 	mov eax, 105000000*60/88	; Ticks per minute
   113                              <1> 
   114 00004684 49                  <1> 	dec cx				; 0x0000 -> 0xFFFF
   115 00004685 660FB7C9            <1> 	movzx ecx, cx
   116 00004689 6641                <1> 	inc ecx				; 0xFFFF -> 0x10000
   117                              <1> 
   118 0000468B 66F7F1              <1> 	div ecx
   119                              <1> 
   120 0000468E 2E66A3[6A47]        <1> 	mov [cs:current_timer_freq], eax
   121 00004693 6661                <1> 	popad
   122                              <1> 
   123 00004695 61                  <1> 	popa
   124 00004696 C3                  <1> 	ret
   125                              <1> 	
   126                              <1> ; -----------------------------------------------------------------
   127                              <1> ; Interrupt call parsers
   128                              <1> 
   129                              <1> ; Division by 0 error handler
   130                              <1> os_compat_int00:
   131 00004697 B8[9D46]            <1> 	mov ax, .msg
   132 0000469A E98ACD              <1> 	jmp os_fatal_error
   133                              <1> 
   134 0000469D 4350553A2044697669- <1> 	.msg db 'CPU: Division by zero error', 0
   134 000046A6 73696F6E206279207A- <1>
   134 000046AF 65726F206572726F72- <1>
   134 000046B8 00                  <1>
   135                              <1> 
   136                              <1> ; Invalid opcode handler
   137                              <1> os_compat_int06:
   138 000046B9 B8[BF46]            <1> 	mov ax, .msg
   139 000046BC E968CD              <1> 	jmp os_fatal_error
   140                              <1> 
   141 000046BF 4350553A20496E7661- <1> 	.msg db 'CPU: Invalid opcode', 0
   141 000046C8 6C6964206F70636F64- <1>
   141 000046D1 6500                <1>
   142                              <1> 
   143                              <1> ; Processor extension error handler
   144                              <1> os_compat_int07:
   145 000046D3 B8[D946]            <1> 	mov ax, .msg
   146 000046D6 E94ECD              <1> 	jmp os_fatal_error
   147                              <1> 
   148 000046D9 4350553A2050726F63- <1> 	.msg db 'CPU: Processor extension error', 0
   148 000046E2 6573736F7220657874- <1>
   148 000046EB 656E73696F6E206572- <1>
   148 000046F4 726F7200            <1>
   149                              <1> 
   150                              <1> ; System timer handler (8253/8254)
   151                              <1> os_compat_int1C:
   152 000046F8 FA                  <1> 	cli
   153 000046F9 6660                <1> 	pushad
   154 000046FB 1E                  <1> 	push ds
   155 000046FC 06                  <1> 	push es
   156                              <1> 	
   157 000046FD 8CC8                <1> 	mov ax, cs
   158 000046FF 8ED8                <1> 	mov ds, ax
   159 00004701 8EC0                <1> 	mov es, ax
   160                              <1> 	
   161 00004703 66833E[6E47]00      <1> 	cmp dword [screensaver_timer], 0
   162 00004709 7405                <1> 	je .no_update_screensaver
   163                              <1> 	
   164 0000470B 66FF0E[6E47]        <1> 	dec dword [screensaver_timer]
   165                              <1> 	
   166                              <1> .no_update_screensaver:
   167 00004710 833E[7247]00        <1> 	cmp word [pause_timer], 0
   168 00004715 7404                <1> 	je .no_update_pause_timer
   169                              <1> 	
   170 00004717 FF0E[7247]          <1> 	dec word [pause_timer]
   171                              <1> 	
   172                              <1> .no_update_pause_timer:
   173 0000471B 803E[6909]01        <1> 	cmp byte [system_ui_state], 1
   174 00004720 7412                <1> 	je .no_update
   175                              <1> 	
   176 00004722 B402                <1> 	mov ah, 02h			; Get the time
   177 00004724 E862CE              <1> 	call os_int_1Ah
   178 00004727 3B0E[4147]          <1> 	cmp cx, [.tmp_time]
   179 0000472B 7407                <1> 	je .no_update
   180 0000472D 890E[4147]          <1> 	mov [.tmp_time], cx
   181                              <1> 
   182 00004731 E835DC              <1> 	call os_print_clock
   183                              <1> 
   184                              <1> .no_update:
   185 00004734 803E[6347]01        <1> 	cmp byte [timer_application_attached], 1
   186 00004739 7408                <1> 	je .app_routine
   187                              <1> 
   188 0000473B 07                  <1> 	pop es
   189 0000473C 1F                  <1> 	pop ds
   190 0000473D 6661                <1> 	popad
   191 0000473F FB                  <1> 	sti
   192 00004740 CF                  <1> 	iret
   193                              <1> 
   194 00004741 0000                <1> 	.tmp_time	dw 0
   195                              <1> 
   196                              <1> .app_routine:
   197 00004743 8E1E[6647]          <1> 	mov ds, [timer_application_segment]
   198                              <1> 	movs es, ds
    39 00004747 1E                  <2>  push %2
    40 00004748 07                  <2>  pop %1
   199 00004749 2EFF1E[6447]        <1> 	call far [cs:timer_application_offset]
   200                              <1> 	
   201 0000474E 07                  <1> 	pop es
   202 0000474F 1F                  <1> 	pop ds	
   203 00004750 6661                <1> 	popad
   204 00004752 CF                  <1> 	iret
   205                              <1> 
   206                              <1> ; Far API call handler
   207                              <1> os_farcall_handler:
   208 00004753 FB                  <1> 	sti
   209                              <1> 	
   210 00004754 FFD5                <1> 	call bp
   211 00004756 9C                  <1> 	pushf
   212 00004757 5D                  <1> 	pop bp
   213                              <1> 
   214 00004758 53                  <1> 	push bx
   215 00004759 89E3                <1> 	mov bx, sp
   216 0000475B 36896F06            <1> 	mov [ss:bx + 6], bp
   217 0000475F 5B                  <1> 	pop bx
   218                              <1> 
   219                              <1> 	clr bp
    31 00004760 31ED                <2>  xor %1, %1
   220 00004762 CF                  <1> 	iret
   221                              <1> 
   222 00004763 00                  <1> 	timer_application_attached	db 0
   223 00004764 0000                <1> 	timer_application_offset	dw 0
   224 00004766 0000                <1> 	timer_application_segment	dw 0
   225                              <1> 	
   226 00004768 0000                <1> 	current_timer_speed			dw 0
   227 0000476A 00000000            <1> 	current_timer_freq			dd 0	; in Hz/64
   228                              <1> 
   229 0000476E 00000000            <1> 	screensaver_timer			dd 0
   230 00004772 0000                <1> 	pause_timer					dw 0
   231                              <1> 
   232                              <1> ; ==================================================================
   531                                  	%INCLUDE "features/graphics.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Graphics functions
     3                              <1> ; Some graphics routines have been borrowed from TachyonOS
     4                              <1> ; ==================================================================
     5                              <1> 
     6                              <1> ; ------------------------------------------------------------------
     7                              <1> ; os_init_graphics_mode -- Initializes graphics mode.
     8                              <1> ; IN/OUT: None, registers preserved
     9                              <1> 
    10                              <1> os_init_graphics_mode:
    11 00004774 60                  <1> 	pusha
    12 00004775 2EC606[6909]01      <1> 	mov byte [cs:system_ui_state], 1
    13                              <1> 
    14 0000477B B81300              <1> 	mov ax, 13h
    15 0000477E CD10                <1> 	int 10h
    16                              <1> 
    17 00004780 06                  <1> 	push es
    18                              <1> 	
    19 00004781 B800A0              <1> 	mov ax, 0xA000
    20 00004784 8EC0                <1> 	mov es, ax
    21                              <1> 
    22 00004786 B300                <1> 	mov bl, 0
    23 00004788 E8B202              <1> 	call os_clear_graphics
    24                              <1> 
    25 0000478B 07                  <1> 	pop es
    26 0000478C 61                  <1> 	popa
    27 0000478D C3                  <1> 	ret
    28                              <1> 
    29                              <1> ; ------------------------------------------------------------------
    30                              <1> ; os_init_text_mode -- Deinitializes graphics mode.
    31                              <1> ; IN/OUT: None, registers preserved
    32                              <1> 
    33                              <1> os_init_text_mode:
    34 0000478E 60                  <1> 	pusha
    35 0000478F B80300              <1> 	mov ax, 3			; Back to text mode
    36                              <1> 	clr bx
    31 00004792 31DB                <2>  xor %1, %1
    37 00004794 CD10                <1> 	int 10h
    38 00004796 B80310              <1> 	mov ax, 1003h		; No blinking text!
    39 00004799 CD10                <1> 	int 10h
    40 0000479B B009                <1> 	mov al, 09h					; Set bright attribute for CGA
    41 0000479D BAD803              <1> 	mov dx, 03D8h
    42 000047A0 EE                  <1> 	out dx, al
    43                              <1> 
    44 000047A1 E80FDB              <1> 	call os_reset_font	
    45 000047A4 E896CF              <1> 	call os_clear_screen
    46 000047A7 61                  <1> 	popa
    47 000047A8 C3                  <1> 	ret
    48                              <1> 
    49                              <1> ; ------------------------------------------------------------------
    50                              <1> ; os_set_pixel -- Sets a pixel on the screen to a given value.
    51                              <1> ; IN: ES = destination memory segment, CX = X coordinate, AX = Y coordinate, BL = color
    52                              <1> ; OUT: None, registers preserved
    53                              <1> 
    54                              <1> os_set_pixel:
    55 000047A9 81F94001            <1> 	cmp cx, 320
    56 000047AD 7713                <1> 	ja .exit
    57                              <1> 
    58 000047AF 3DC800              <1> 	cmp ax, 200
    59 000047B2 770E                <1> 	ja .exit
    60                              <1> 
    61 000047B4 60                  <1> 	pusha
    62                              <1> 
    63 000047B5 BA4001              <1> 	mov dx, 320
    64 000047B8 F7E2                <1> 	mul dx
    65 000047BA 01C8                <1> 	add ax, cx
    66 000047BC 89C7                <1> 	mov di, ax
    67 000047BE 26881D              <1> 	mov [es:di], bl
    68 000047C1 61                  <1> 	popa
    69                              <1> 
    70                              <1> .exit:
    71 000047C2 C3                  <1> 	ret
    72                              <1> 
    73                              <1> ; ------------------------------------------------------------------
    74                              <1> ; os_draw_line -- Draws a line with the Bresenham's line algorithm.
    75                              <1> ; Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
    76                              <1> ; IN: ES = destination memory segment, CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
    77                              <1> ; OUT: None, registers preserved
    78                              <1> 
    79                              <1> os_draw_line:
    80 000047C3 60                  <1> 	pusha				; Save parameters
    81 000047C4 1E                  <1> 	push ds
    82                              <1> 	
    83                              <1> 	movs ds, cs
    39 000047C5 0E                  <2>  push %2
    40 000047C6 1F                  <2>  pop %1
    84                              <1> 	
    85 000047C7 890E[2149]          <1> 	mov [.x1], cx			; Save points
    86 000047CB 890E[2949]          <1> 	mov [.x], cx
    87 000047CF 8916[2349]          <1> 	mov [.y1], dx
    88 000047D3 8916[2B49]          <1> 	mov [.y], dx
    89 000047D7 8936[2549]          <1> 	mov [.x2], si
    90 000047DB 893E[2749]          <1> 	mov [.y2], di
    91                              <1> 	
    92 000047DF 881E[3749]          <1> 	mov [.colour], bl		; Save the colour
    93                              <1> 	
    94 000047E3 8B1E[2549]          <1> 	mov bx, [.x2]
    95 000047E7 A1[2149]            <1> 	mov ax, [.x1]
    96 000047EA 39C3                <1> 	cmp bx, ax
    97 000047EC 7C0E                <1> 	jl .x1gtx2
    98                              <1> 	
    99 000047EE 29C3                <1> 	sub bx, ax
   100 000047F0 891E[2D49]          <1> 	mov [.dx], bx
   101 000047F4 B80100              <1> 	mov ax, 1
   102 000047F7 A3[3149]            <1> 	mov [.incx], ax
   103 000047FA EB0B                <1> 	jmp .test2
   104                              <1> 	
   105                              <1> .x1gtx2:
   106 000047FC 29D8                <1> 	sub ax, bx
   107 000047FE A3[2D49]            <1> 	mov [.dx], ax
   108 00004801 B8FFFF              <1> 	mov ax, -1
   109 00004804 A3[3149]            <1> 	mov [.incx], ax
   110                              <1> 	
   111                              <1> .test2:
   112 00004807 8B1E[2749]          <1> 	mov bx, [.y2]
   113 0000480B A1[2349]            <1> 	mov ax, [.y1]
   114 0000480E 39C3                <1> 	cmp bx, ax
   115 00004810 7C0E                <1> 	jl .y1gty2
   116                              <1> 	
   117 00004812 29C3                <1> 	sub bx, ax
   118 00004814 891E[2F49]          <1> 	mov [.dy], bx
   119 00004818 B80100              <1> 	mov ax, 1
   120 0000481B A3[3349]            <1> 	mov [.incy], ax
   121 0000481E EB0B                <1> 	jmp .test3
   122                              <1> 	
   123                              <1> .y1gty2:
   124 00004820 29D8                <1> 	sub ax, bx
   125 00004822 A3[2F49]            <1> 	mov [.dy], ax
   126 00004825 B8FFFF              <1> 	mov ax, -1
   127 00004828 A3[3349]            <1> 	mov [.incy], ax
   128                              <1> 	
   129                              <1> .test3:
   130 0000482B 8B1E[2D49]          <1> 	mov bx, [.dx]
   131 0000482F A1[2F49]            <1> 	mov ax, [.dy]
   132 00004832 39C3                <1> 	cmp bx, ax
   133 00004834 7C6E                <1> 	jl .dygtdx
   134                              <1> 	
   135 00004836 A1[2F49]            <1> 	mov ax, [.dy]
   136 00004839 D1E0                <1> 	shl ax, 1
   137 0000483B A3[2F49]            <1> 	mov [.dy], ax
   138                              <1> 	
   139 0000483E 8B1E[2D49]          <1> 	mov bx, [.dx]
   140 00004842 29D8                <1> 	sub ax, bx
   141 00004844 A3[3549]            <1> 	mov [.balance], ax
   142                              <1> 	
   143 00004847 D1E3                <1> 	shl bx, 1
   144 00004849 891E[2D49]          <1> 	mov [.dx], bx
   145                              <1> 	
   146                              <1> .xloop:
   147 0000484D A1[2949]            <1> 	mov ax, [.x]
   148 00004850 8B1E[2549]          <1> 	mov bx, [.x2]
   149 00004854 39D8                <1> 	cmp ax, bx
   150 00004856 0F84B600            <1> 	je .done
   151                              <1> 	
   152 0000485A 8B0E[2949]          <1> 	mov cx, [.x]
   153 0000485E A1[2B49]            <1> 	mov ax, [.y]
   154 00004861 8A1E[3749]          <1> 	mov bl, [.colour]
   155 00004865 E841FF              <1> 	call os_set_pixel
   156                              <1> 	
   157 00004868 31F6                <1> 	xor si, si
   158 0000486A 8B3E[3549]          <1> 	mov di, [.balance]
   159 0000486E 39F7                <1> 	cmp di, si
   160 00004870 7C18                <1> 	jl .xloop1
   161                              <1> 	
   162 00004872 A1[2B49]            <1> 	mov ax, [.y]
   163 00004875 8B1E[3349]          <1> 	mov bx, [.incy]
   164 00004879 01D8                <1> 	add ax, bx
   165 0000487B A3[2B49]            <1> 	mov [.y], ax
   166                              <1> 	
   167 0000487E A1[3549]            <1> 	mov ax, [.balance]
   168 00004881 8B1E[2D49]          <1> 	mov bx, [.dx]
   169 00004885 29D8                <1> 	sub ax, bx
   170 00004887 A3[3549]            <1> 	mov [.balance], ax
   171                              <1> 	
   172                              <1> .xloop1:
   173 0000488A A1[3549]            <1> 	mov ax, [.balance]
   174 0000488D 8B1E[2F49]          <1> 	mov bx, [.dy]
   175 00004891 01D8                <1> 	add ax, bx
   176 00004893 A3[3549]            <1> 	mov [.balance], ax
   177                              <1> 	
   178 00004896 A1[2949]            <1> 	mov ax, [.x]
   179 00004899 8B1E[3149]          <1> 	mov bx, [.incx]
   180 0000489D 01D8                <1> 	add ax, bx
   181 0000489F A3[2949]            <1> 	mov [.x], ax
   182                              <1> 	
   183 000048A2 EBA9                <1> 	jmp .xloop
   184                              <1> 	
   185                              <1> .dygtdx:
   186 000048A4 A1[2D49]            <1> 	mov ax, [.dx]
   187 000048A7 D1E0                <1> 	shl ax, 1
   188 000048A9 A3[2D49]            <1> 	mov [.dx], ax
   189                              <1> 	
   190 000048AC 8B1E[2F49]          <1> 	mov bx, [.dy]
   191 000048B0 29D8                <1> 	sub ax, bx
   192 000048B2 A3[3549]            <1> 	mov [.balance], ax
   193                              <1> 	
   194 000048B5 D1E3                <1> 	shl bx, 1
   195 000048B7 891E[2F49]          <1> 	mov [.dy], bx
   196                              <1> 	
   197                              <1> .yloop:
   198 000048BB A1[2B49]            <1> 	mov ax, [.y]
   199 000048BE 8B1E[2749]          <1> 	mov bx, [.y2]
   200 000048C2 39D8                <1> 	cmp ax, bx
   201 000048C4 744A                <1> 	je .done
   202                              <1> 	
   203 000048C6 8B0E[2949]          <1> 	mov cx, [.x]
   204 000048CA A1[2B49]            <1> 	mov ax, [.y]
   205 000048CD 8A1E[3749]          <1> 	mov bl, [.colour]
   206 000048D1 E8D5FE              <1> 	call os_set_pixel
   207                              <1> 	
   208 000048D4 31F6                <1> 	xor si, si
   209 000048D6 8B3E[3549]          <1> 	mov di, [.balance]
   210 000048DA 39F7                <1> 	cmp di, si
   211 000048DC 7C18                <1> 	jl .yloop1
   212                              <1> 	
   213 000048DE A1[2949]            <1> 	mov ax, [.x]
   214 000048E1 8B1E[3149]          <1> 	mov bx, [.incx]
   215 000048E5 01D8                <1> 	add ax, bx
   216 000048E7 A3[2949]            <1> 	mov [.x], ax
   217                              <1> 	
   218 000048EA A1[3549]            <1> 	mov ax, [.balance]
   219 000048ED 8B1E[2F49]          <1> 	mov bx, [.dy]
   220 000048F1 29D8                <1> 	sub ax, bx
   221 000048F3 A3[3549]            <1> 	mov [.balance], ax
   222                              <1> 	
   223                              <1> .yloop1:
   224 000048F6 A1[3549]            <1> 	mov ax, [.balance]
   225 000048F9 8B1E[2D49]          <1> 	mov bx, [.dx]
   226 000048FD 01D8                <1> 	add ax, bx
   227 000048FF A3[3549]            <1> 	mov [.balance], ax
   228                              <1> 	
   229 00004902 A1[2B49]            <1> 	mov ax, [.y]
   230 00004905 8B1E[3349]          <1> 	mov bx, [.incy]
   231 00004909 01D8                <1> 	add ax, bx
   232 0000490B A3[2B49]            <1> 	mov [.y], ax
   233                              <1> 	
   234 0000490E EBAB                <1> 	jmp .yloop
   235                              <1> 	
   236                              <1> .done:
   237 00004910 8B0E[2949]          <1> 	mov cx, [.x]
   238 00004914 A1[2B49]            <1> 	mov ax, [.y]
   239 00004917 8A1E[3749]          <1> 	mov bl, [.colour]
   240 0000491B E88BFE              <1> 	call os_set_pixel
   241                              <1> 	
   242 0000491E 1F                  <1> 	pop ds
   243 0000491F 61                  <1> 	popa
   244 00004920 C3                  <1> 	ret
   245                              <1> 	
   246                              <1> 	
   247 00004921 0000                <1> 	.x1 dw 0
   248 00004923 0000                <1> 	.y1 dw 0
   249 00004925 0000                <1> 	.x2 dw 0
   250 00004927 0000                <1> 	.y2 dw 0
   251                              <1> 	
   252 00004929 0000                <1> 	.x dw 0
   253 0000492B 0000                <1> 	.y dw 0
   254 0000492D 0000                <1> 	.dx dw 0
   255 0000492F 0000                <1> 	.dy dw 0
   256 00004931 0000                <1> 	.incx dw 0
   257 00004933 0000                <1> 	.incy dw 0
   258 00004935 0000                <1> 	.balance dw 0
   259 00004937 00                  <1> 	.colour db 0
   260 00004938 00                  <1> 	.pad db 0
   261                              <1> 
   262                              <1> ; ------------------------------------------------------------------
   263                              <1> ; os_draw_rectangle -- Draws a rectangle.
   264                              <1> ; IN: ES = destination memory segment, CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
   265                              <1> ; OUT: None, registers preserved
   266                              <1> 
   267                              <1> os_draw_rectangle:
   268 00004939 60                  <1> 	pusha
   269 0000493A 1E                  <1> 	push ds
   270                              <1> 
   271                              <1> 	movs ds, cs
    39 0000493B 0E                  <2>  push %2
    40 0000493C 1F                  <2>  pop %1
   272                              <1> 
   273 0000493D 890E[C249]          <1> 	mov word [.x1], cx
   274 00004941 8916[C649]          <1> 	mov word [.y1], dx
   275 00004945 8936[C449]          <1> 	mov word [.x2], si
   276 00004949 893E[C849]          <1> 	mov word [.y2], di
   277 0000494D 724E                <1> 	jc .fill_shape
   278                              <1> 	
   279                              <1> .draw_line:
   280                              <1> 	; top line
   281 0000494F 8B0E[C249]          <1> 	mov cx, [.x1]
   282 00004953 8B16[C649]          <1> 	mov dx, [.y1]
   283 00004957 8B36[C449]          <1> 	mov si, [.x2]
   284 0000495B 8B3E[C649]          <1> 	mov di, [.y1]
   285 0000495F E861FE              <1> 	call os_draw_line
   286                              <1> 	
   287                              <1> 	; left line
   288 00004962 8B0E[C249]          <1> 	mov cx, [.x1]
   289 00004966 8B16[C649]          <1> 	mov dx, [.y1]
   290 0000496A 8B36[C249]          <1> 	mov si, [.x1]
   291 0000496E 8B3E[C849]          <1> 	mov di, [.y2]
   292 00004972 E84EFE              <1> 	call os_draw_line
   293                              <1> 	
   294                              <1> 	; right line
   295 00004975 8B0E[C449]          <1> 	mov cx, [.x2]
   296 00004979 8B16[C649]          <1> 	mov dx, [.y1]
   297 0000497D 8B36[C449]          <1> 	mov si, [.x2]
   298 00004981 8B3E[C849]          <1> 	mov di, [.y2]
   299 00004985 E83BFE              <1> 	call os_draw_line
   300                              <1> 
   301                              <1> 	; bottom line
   302 00004988 8B0E[C249]          <1> 	mov cx, [.x1]
   303 0000498C 8B16[C849]          <1> 	mov dx, [.y2]
   304 00004990 8B36[C449]          <1> 	mov si, [.x2]
   305 00004994 8B3E[C849]          <1> 	mov di, [.y2]
   306 00004998 E828FE              <1> 	call os_draw_line
   307                              <1> 		
   308 0000499B EB22                <1> 	jmp .finished_fill
   309                              <1> 		
   310                              <1> .fill_shape:
   311 0000499D 89D0                <1> 	mov ax, dx
   312                              <1> 
   313 0000499F 39F1                <1> 	cmp cx, si		; Is X1 smaller than X2?
   314 000049A1 7C02                <1> 	jl .x_good
   315 000049A3 87CE                <1> 	xchg cx, si		; If not, exchange them
   316                              <1> 
   317                              <1> .x_good:
   318 000049A5 39F8                <1> 	cmp ax, di		; Is Y1 smaller than Y2?
   319 000049A7 7C01                <1> 	jl .y_good
   320 000049A9 97                  <1> 	xchg ax, di		; If not, exchange them
   321                              <1> 
   322                              <1> .y_good:
   323 000049AA 890E[C249]          <1> 	mov [.x1], cx
   324                              <1> 
   325                              <1> .x_loop:
   326 000049AE E8F8FD              <1> 	call os_set_pixel
   327 000049B1 41                  <1> 	inc cx
   328                              <1> 	
   329 000049B2 39F1                <1> 	cmp cx, si
   330 000049B4 7CF8                <1> 	jl .x_loop
   331                              <1> 	
   332 000049B6 40                  <1> 	inc ax
   333 000049B7 8B0E[C249]          <1> 	mov cx, [.x1]
   334                              <1> 	
   335 000049BB 39F8                <1> 	cmp ax, di
   336 000049BD 7CEF                <1> 	jl .x_loop
   337                              <1> 
   338                              <1> .finished_fill:
   339 000049BF 1F                  <1> 	pop ds
   340 000049C0 61                  <1> 	popa
   341 000049C1 C3                  <1> 	ret
   342                              <1> 	
   343 000049C2 0000                <1> 	.x1				dw 0
   344 000049C4 0000                <1> 	.x2				dw 0
   345 000049C6 0000                <1> 	.y1				dw 0
   346 000049C8 0000                <1> 	.y2				dw 0
   347                              <1> 
   348                              <1> ; ------------------------------------------------------------------
   349                              <1> ; os_draw_polygon -- Draws a freeform shape.
   350                              <1> ; IN: ES = destination memory segment, BH = number of points, BL = colour, SI = location of shape points data
   351                              <1> ; OUT: None, registers preserved
   352                              <1> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
   353                              <1> 
   354                              <1> os_draw_polygon:
   355 000049CA 60                  <1> 	pusha
   356 000049CB 1E                  <1> 	push ds
   357                              <1> 
   358                              <1> 	movs ds, cs
    39 000049CC 0E                  <2>  push %2
    40 000049CD 1F                  <2>  pop %1
   359                              <1> 
   360 000049CE FECF                <1> 	dec bh
   361 000049D0 883E[3C4A]          <1> 	mov byte [.points], bh
   362                              <1> 	
   363 000049D4 3E8B04              <1> 	mov word ax, [ds:si]
   364 000049D7 83C602              <1> 	add si, 2
   365 000049DA A3[344A]            <1> 	mov word [.xi], ax
   366 000049DD A3[384A]            <1> 	mov word [.xl], ax
   367                              <1> 	
   368 000049E0 3E8B04              <1> 	mov word ax, [ds:si]
   369 000049E3 83C602              <1> 	add si, 2
   370 000049E6 A3[364A]            <1> 	mov word [.yi], ax
   371 000049E9 A3[3A4A]            <1> 	mov word [.yl], ax
   372                              <1> 	
   373                              <1> 	.draw_points:
   374 000049EC 8B0E[384A]          <1> 		mov cx, [.xl]
   375 000049F0 8B16[3A4A]          <1> 		mov dx, [.yl]
   376                              <1> 		
   377 000049F4 3E8B04              <1> 		mov word ax, [ds:si]
   378 000049F7 83C602              <1> 		add si, 2
   379 000049FA A3[384A]            <1> 		mov word [.xl], ax
   380                              <1> 		
   381 000049FD 3E8B04              <1> 		mov word ax, [ds:si]
   382 00004A00 83C602              <1> 		add si, 2
   383 00004A03 A3[3A4A]            <1> 		mov word [.yl], ax
   384                              <1> 		
   385 00004A06 56                  <1> 		push si
   386                              <1> 		
   387 00004A07 8B36[384A]          <1> 		mov si, [.xl]
   388 00004A0B 8B3E[3A4A]          <1> 		mov di, [.yl]
   389                              <1> 		
   390 00004A0F E8B1FD              <1> 		call os_draw_line
   391                              <1> 		
   392 00004A12 5E                  <1> 		pop si
   393                              <1> 		
   394 00004A13 FE0E[3C4A]          <1> 		dec byte [.points]
   395 00004A17 803E[3C4A]00        <1> 		cmp byte [.points], 0
   396 00004A1C 75CE                <1> 		jne .draw_points
   397                              <1> 		
   398 00004A1E 8B0E[384A]          <1> 	mov cx, [.xl]
   399 00004A22 8B16[3A4A]          <1> 	mov dx, [.yl]
   400 00004A26 8B36[344A]          <1> 	mov si, [.xi]
   401 00004A2A 8B3E[364A]          <1> 	mov di, [.yi]
   402 00004A2E E892FD              <1> 	call os_draw_line
   403                              <1> 	
   404 00004A31 1F                  <1> 	pop ds
   405 00004A32 61                  <1> 	popa
   406 00004A33 C3                  <1> 	ret
   407                              <1> 	
   408 00004A34 0000                <1> 	.xi				dw 0
   409 00004A36 0000                <1> 	.yi				dw 0
   410 00004A38 0000                <1> 	.xl				dw 0
   411 00004A3A 0000                <1> 	.yl				dw 0
   412 00004A3C 00                  <1> 	.points				db 0
   413                              <1> 	
   414                              <1> 
   415                              <1> ; ------------------------------------------------------------------
   416                              <1> ; os_clear_graphics -- Clears the graphics screen with a given color.
   417                              <1> ; IN: ES = destination memory segment, BL = colour to set
   418                              <1> ; OUT: None, registers preserved
   419                              <1> 
   420                              <1> os_clear_graphics:
   421 00004A3D 60                  <1> 	pusha
   422 00004A3E 88D8                <1> 	mov al, bl
   423                              <1> 	clr di
    31 00004A40 31FF                <2>  xor %1, %1
   424 00004A42 B900FA              <1> 	mov cx, 64000
   425 00004A45 F3AA                <1> 	rep stosb
   426 00004A47 61                  <1> 	popa
   427 00004A48 C3                  <1> 	ret
   428                              <1> 	
   429                              <1> 	
   430                              <1> ; ----------------------------------------
   431                              <1> ; os_draw_circle -- draw a circular shape
   432                              <1> ; IN: ES = destination memory segment, AL = colour, BX = radius, CX = middle X, DX = middle y
   433                              <1> ; OUT: None, registers preserved
   434                              <1> 
   435                              <1> os_draw_circle:
   436 00004A49 60                  <1> 	pusha
   437 00004A4A 1E                  <1> 	push ds
   438                              <1> 
   439                              <1> 	movs ds, cs
    39 00004A4B 0E                  <2>  push %2
    40 00004A4C 1F                  <2>  pop %1
   440                              <1> 
   441 00004A4D A2[114B]            <1> 	mov [.colour], al
   442 00004A50 891E[164B]          <1> 	mov [.radius], bx
   443 00004A54 890E[124B]          <1> 	mov [.x0], cx
   444 00004A58 8916[144B]          <1> 	mov [.y0], dx
   445                              <1> 
   446 00004A5C 891E[184B]          <1> 	mov [.x], bx
   447 00004A60 C706[1A4B]0000      <1> 	mov word [.y], 0
   448 00004A66 B80100              <1> 	mov ax, 1
   449 00004A69 D1E3                <1> 	shl bx, 1
   450 00004A6B 29D8                <1> 	sub ax, bx
   451 00004A6D A3[1C4B]            <1> 	mov [.xChange], ax
   452 00004A70 C706[1E4B]0000      <1> 	mov word [.yChange], 0
   453 00004A76 C706[204B]0000      <1> 	mov word [.radiusError], 0
   454                              <1> 
   455                              <1> .next_point:
   456 00004A7C 8B0E[184B]          <1> 	mov cx, [.x]
   457 00004A80 8B16[1A4B]          <1> 	mov dx, [.y]
   458 00004A84 39D1                <1> 	cmp cx, dx
   459 00004A86 0F8C8400            <1> 	jl .finish
   460                              <1> 
   461                              <1> 	;ax bx - function points
   462                              <1> 	;cx = x 
   463                              <1> 	;dx = y
   464                              <1> 	;si = -x
   465                              <1> 	;di = -y
   466                              <1> 
   467 00004A8A 89CE                <1> 	mov si, cx
   468 00004A8C 83F6FF              <1> 	xor si, 0xFFFF
   469 00004A8F 46                  <1> 	inc si
   470 00004A90 89D7                <1> 	mov di, dx
   471 00004A92 83F7FF              <1> 	xor di, 0xFFFF
   472 00004A95 47                  <1> 	inc di
   473                              <1> 
   474                              <1> 	; (x + x0, y + y0)
   475 00004A96 89C8                <1> 	mov ax, cx
   476 00004A98 89D3                <1> 	mov bx, dx
   477 00004A9A E85B00              <1> 	call .draw_point
   478                              <1> 
   479                              <1> 	; (y + x0, x + y0)
   480 00004A9D 93                  <1> 	xchg ax, bx
   481 00004A9E E85700              <1> 	call .draw_point
   482                              <1> 
   483                              <1> 	; (-x + x0, y + y0)
   484 00004AA1 89F0                <1> 	mov ax, si
   485 00004AA3 89D3                <1> 	mov bx, dx
   486 00004AA5 E85000              <1> 	call .draw_point
   487                              <1> 
   488                              <1> 	; (-y + x0, x + y0)
   489 00004AA8 89F8                <1> 	mov ax, di
   490 00004AAA 89CB                <1> 	mov bx, cx
   491 00004AAC E84900              <1> 	call .draw_point
   492                              <1> 
   493                              <1> 	; (-x + x0, -y + y0)
   494 00004AAF 89F0                <1> 	mov ax, si
   495 00004AB1 89FB                <1> 	mov bx, di
   496 00004AB3 E84200              <1> 	call .draw_point
   497                              <1> 
   498                              <1> 	; (-y + x0, -x + y0)
   499 00004AB6 93                  <1> 	xchg ax, bx
   500 00004AB7 E83E00              <1> 	call .draw_point
   501                              <1> 
   502                              <1> 	; (x + x0, -y + y0)
   503 00004ABA 89C8                <1> 	mov ax, cx
   504 00004ABC 89FB                <1> 	mov bx, di
   505 00004ABE E83700              <1> 	call .draw_point
   506                              <1> 
   507                              <1> 	; (y + x0, -x + y0)
   508 00004AC1 89D0                <1> 	mov ax, dx
   509 00004AC3 89F3                <1> 	mov bx, si
   510 00004AC5 E83000              <1> 	call .draw_point
   511                              <1> 	
   512 00004AC8 FF06[1A4B]          <1> 	inc word [.y]
   513 00004ACC A1[1E4B]            <1> 	mov ax, [.yChange]
   514 00004ACF 0106[204B]          <1> 	add [.radiusError], ax
   515 00004AD3 8306[1E4B]02        <1> 	add word [.yChange], 2
   516                              <1> 	
   517 00004AD8 A1[204B]            <1> 	mov ax, [.radiusError]
   518 00004ADB D1E0                <1> 	shl ax, 1
   519 00004ADD 0306[1C4B]          <1> 	add ax, [.xChange]
   520                              <1> 	
   521 00004AE1 83F800              <1> 	cmp ax, 0
   522 00004AE4 7E96                <1> 	jle .next_point
   523                              <1> 	
   524 00004AE6 FF0E[184B]          <1> 	dec word [.x]
   525 00004AEA A1[1C4B]            <1> 	mov ax, [.xChange]
   526 00004AED 0106[204B]          <1> 	add [.radiusError], ax
   527 00004AF1 8306[1C4B]02        <1> 	add word [.xChange], 2
   528                              <1> 
   529 00004AF6 EB84                <1> 	jmp .next_point
   530                              <1> 
   531                              <1> .draw_point:
   532                              <1> 	; AX = X, BX = Y
   533 00004AF8 60                  <1> 	pusha
   534 00004AF9 0306[124B]          <1> 	add ax, [.x0]
   535 00004AFD 031E[144B]          <1> 	add bx, [.y0]
   536 00004B01 89C1                <1> 	mov cx, ax
   537 00004B03 89D8                <1> 	mov ax, bx
   538 00004B05 8A1E[114B]          <1> 	mov bl, [.colour]
   539 00004B09 E89DFC              <1> 	call os_set_pixel
   540 00004B0C 61                  <1> 	popa
   541 00004B0D C3                  <1> 	ret
   542                              <1> 	
   543                              <1> .finish:
   544 00004B0E 1F                  <1> 	pop ds
   545 00004B0F 61                  <1> 	popa
   546 00004B10 C3                  <1> 	ret
   547                              <1> 	
   548                              <1> 
   549                              <1> 
   550 00004B11 00                  <1> .colour				db 0
   551 00004B12 0000                <1> .x0					dw 0
   552 00004B14 0000                <1> .y0					dw 0
   553 00004B16 0000                <1> .radius				dw 0
   554 00004B18 0000                <1> .x					dw 0
   555 00004B1A 0000                <1> .y					dw 0
   556 00004B1C 0000                <1> .xChange			dw 0
   557 00004B1E 0000                <1> .yChange			dw 0
   558 00004B20 0000                <1> .radiusError		dw 0
   559                              <1> 
   560                              <1> ; ==================================================================
   532                                  	%INCLUDE "features/zx7.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS ZX7 decompression routine
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; Decompresses Einar Saukas' ZX7 compressed stream data in 16-bit real mode.
     6                              <1> ; ZX7 format and original Z80 decompressor by Einar Saukas.
     7                              <1> ; Original Z80 to 8086 conversion, and size-optimized version, by Peter Ferrie.
     8                              <1> ; Speed-optimized code by Peter Ferrie and Jim Leonard.
     9                              <1> ; 20160308
    10                              <1> ;
    11                              <1> ; The source for the conversion was the original "default" Z80 decompression
    12                              <1> ; code provided by Einar.  Further size optimization and unrolling were
    13                              <1> ; independently performed specifically for the 8086.
    14                              <1> ; Source is formatted for Borland Turbo Assembler IDEAL mode and NEAR calls,
    15                              <1> ; however it should be very easy to port to other assemblers if necessary.
    16                              <1> 
    17                              <1> ; ------------------------------------------------------------------
    18                              <1> ; os_decompress_zx7 -- Decompresses ZX7-packed data.
    19                              <1> ; IN: DS:SI = source, ES:DI = destination
    20                              <1> ; OUT: None, registers preserved
    21                              <1> 
    22                              <1> os_decompress_zx7:
    23 00004B22 60                  <1> 	pusha
    24 00004B23 E80200              <1> 	call int_decompress_zx7
    25 00004B26 61                  <1> 	popa
    26 00004B27 C3                  <1> 	ret
    27                              <1> 
    28                              <1> ; ==================================================================
    29                              <1> 
    30                              <1> ; ------------------------------------------------------------------
    31                              <1> ; int_decompress_zx7 -- Decompresses ZX7-packed data.
    32                              <1> ; IN: DS:SI = source, ES:DI = destination
    33                              <1> ; OUT: None, destroys every imaginable register under the sun
    34                              <1> 
    35                              <1> int_decompress_zx7:
    36 00004B28 B080                <1> 	mov al, 80h
    37 00004B2A 31C9                <1> 	xor cx, cx
    38 00004B2C BD[654B]            <1> 	mov bp, .next_bit
    39                              <1> 	
    40                              <1> .copy_byte_loop:
    41 00004B2F A4                  <1> 	movsb					; copy literal byte
    42                              <1> 
    43                              <1> .main_loop:
    44 00004B30 FFD5                <1> 	call bp
    45 00004B32 73FB                <1> 	jnc .copy_byte_loop		; next bit indicates either
    46                              <1> 							; literal or sequence
    47                              <1> 
    48                              <1> 	; determine number of bits used for length (Elias gamma coding)
    49                              <1> 
    50 00004B34 31DB                <1> 	xor bx, bx
    51                              <1> 
    52                              <1> .len_size_loop:
    53 00004B36 43                  <1> 	inc bx
    54 00004B37 FFD5                <1> 	call bp
    55 00004B39 73FB                <1> 	jnc .len_size_loop
    56 00004B3B 80                  <1> 	db 80h ; mask call
    57                              <1> 
    58                              <1> 	; determine length
    59                              <1> 
    60                              <1> .len_value_loop:
    61 00004B3C FFD5                <1> 	call bp
    62                              <1> 
    63                              <1> .len_value_skip:
    64 00004B3E 11C9                <1> 	adc cx, cx
    65 00004B40 722A                <1> 	jb .next_bit_ret 		; check end marker
    66 00004B42 4B                  <1> 	dec bx
    67 00004B43 75F7                <1> 	jnz .len_value_loop
    68 00004B45 41                  <1> 	inc cx					; adjust length
    69                              <1> 
    70                              <1> 	; determine offset
    71                              <1> 
    72 00004B46 8A1C                <1> 	mov bl, [si]			; load offset flag (1 bit) +
    73                              <1> 							; offset value (7 bits)
    74 00004B48 46                  <1> 	inc si
    75 00004B49 F9                  <1> 	stc
    76 00004B4A 10DB                <1> 	adc bl, bl
    77 00004B4C 730A                <1> 	jnc .offset_end 		; if offset flag is set, load
    78                              <1> 							; 4 extra bits
    79 00004B4E B710                <1> 	mov bh, 10h				; bit marker to load 4 bits
    80                              <1> .rld_next_bit:
    81 00004B50 FFD5                <1> 	call bp
    82 00004B52 10FF                <1> 	adc bh, bh				; insert next bit into D
    83 00004B54 73FA                <1> 	jnc .rld_next_bit		; repeat 4 times, until bit
    84                              <1> 							; marker is out
    85 00004B56 FEC7                <1> 	inc bh					; add 128 to DE
    86                              <1> 
    87                              <1> .offset_end:
    88 00004B58 D1EB                <1> 	shr bx, 1				; insert fourth bit into E
    89                              <1> 
    90                              <1> 	; copy previous sequence
    91                              <1> 
    92 00004B5A 56                  <1> 	push si
    93 00004B5B 89FE                <1> 	mov si, di
    94 00004B5D 19DE                <1> 	sbb si, bx				; destination = destination - offset - 1
    95                              <1> 
    96 00004B5F F326A4              <1> 	es rep movsb
    97                              <1> 
    98 00004B62 5E                  <1> 	pop si					; restore source address
    99                              <1> 							; (compressed data)
   100 00004B63 EBCB                <1> 	jmp .main_loop
   101                              <1> 
   102                              <1> .next_bit:
   103 00004B65 00C0                <1> 	add al, al				; check next bit
   104 00004B67 7503                <1> 	jnz .next_bit_ret		; no more bits left?
   105 00004B69 AC                  <1> 	lodsb					; load another group of 8 bits
   106 00004B6A 10C0                <1> 	adc al, al
   107                              <1> 
   108                              <1> .next_bit_ret:
   109 00004B6C C3                  <1> 	ret
   110                              <1> 
   111                              <1> ; ==================================================================
   533                                  	%INCLUDE "features/disk/lowlevel.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Low-level disk driver
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; --------------------------------------------------------------------------
     6                              <1> ; os_int13 -- Perform a BIOS 13h call with extra precautions
     7                              <1> ; IN/OUT: depends on function in AH, high 16 bits of all 32-bit registers preserved, carry set if error
     8                              <1> 
     9                              <1> os_int13:
    10 00004B6D E81100              <1> 	call .roll			; Some BIOSes destroy (16..31) of all 32 bit regs
    11 00004B70 60                  <1> 	pusha
    12                              <1> 	clr ax				; Some BIOSes need the upper word of EAX = 0
    31 00004B71 31C0                <2>  xor %1, %1
    13 00004B73 E80B00              <1> 	call .roll
    14                              <1> 
    15 00004B76 F9                  <1> 	stc					; Some BIOSes do not set CF on error
    16 00004B77 CD13                <1> 	int 13h
    17                              <1> 
    18 00004B79 E80500              <1> 	call .roll
    19 00004B7C 61                  <1> 	popa
    20 00004B7D E80100              <1> 	call .roll
    21 00004B80 C3                  <1> 	ret
    22                              <1> 
    23                              <1> .roll:
    24 00004B81 9C                  <1> 	pushf
    25 00004B82 66C1C810            <1> 	ror eax, 16
    26 00004B86 66C1CB10            <1> 	ror ebx, 16
    27 00004B8A 66C1C910            <1> 	ror ecx, 16
    28 00004B8E 66C1CA10            <1> 	ror edx, 16
    29 00004B92 66C1CE10            <1> 	ror esi, 16
    30 00004B96 66C1CF10            <1> 	ror edi, 16
    31 00004B9A 66C1CD10            <1> 	ror ebp, 16
    32 00004B9E 9D                  <1> 	popf
    33 00004B9F C3                  <1> 	ret
    34                              <1> 
    35                              <1> ; --------------------------------------------------------------------------
    36                              <1> ; os_int13_protected -- Performs a BIOS 13h call with all regs preserved
    37                              <1> ; IN: depends on function in AH
    38                              <1> ; OUT: None, registers preserved
    39                              <1> 
    40                              <1> os_int13_protected:
    41 00004BA0 6660                <1> 	pushad
    42 00004BA2 1E                  <1> 	push ds
    43 00004BA3 06                  <1> 	push es
    44 00004BA4 E8C6FF              <1> 	call os_int13
    45 00004BA7 07                  <1> 	pop es
    46 00004BA8 1F                  <1> 	pop ds
    47 00004BA9 6661                <1> 	popad
    48 00004BAB C3                  <1> 	ret
    49                              <1> 
    50                              <1> ; --------------------------------------------------------------------------
    51                              <1> ; os_int13_failsafe -- Performs a BIOS 13h call 3 times in case of error
    52                              <1> ; IN/OUT: depends on function in AH (DL must be drive number), high 16 bits of all 32-bit registers preserved, carry set if error
    53                              <1> 
    54                              <1> os_int13_failsafe:
    55 00004BAC 60                  <1> 	pusha
    56 00004BAD E8BDFF              <1> 	call os_int13				; Attempt #1
    57 00004BB0 7312                <1> 	jnc .ok
    58 00004BB2 61                  <1> 	popa
    59                              <1> 
    60 00004BB3 E82C00              <1> 	call os_disk_reset_device	; Reset device and try again
    61                              <1> 
    62 00004BB6 60                  <1> 	pusha
    63 00004BB7 E8B3FF              <1> 	call os_int13				; Attempt #2
    64 00004BBA 7308                <1> 	jnc .ok
    65 00004BBC 61                  <1> 	popa
    66                              <1> 
    67 00004BBD E82200              <1> 	call os_disk_reset_device	; Reset device and try again
    68                              <1> 
    69 00004BC0 60                  <1> 	pusha
    70 00004BC1 E8A9FF              <1> 	call os_int13				; Third time's a charm!
    71                              <1> 
    72                              <1> .ok:
    73 00004BC4 83C410              <1> 	add sp, 16					; Restore stack without popping regs
    74 00004BC7 C3                  <1> 	ret
    75                              <1> 
    76                              <1> ; --------------------------------------------------------------------------
    77                              <1> ; os_int13_failsafe_protected -- Performs a BIOS 13h call with all regs preserved 3 times in case of error
    78                              <1> ; IN: depends on function in AH
    79                              <1> ; OUT: None, registers preserved
    80                              <1> 
    81                              <1> os_int13_failsafe_protected:
    82 00004BC8 6660                <1> 	pushad
    83 00004BCA 1E                  <1> 	push ds
    84 00004BCB 06                  <1> 	push es
    85 00004BCC E8DDFF              <1> 	call os_int13_failsafe
    86 00004BCF 07                  <1> 	pop es
    87 00004BD0 1F                  <1> 	pop ds
    88 00004BD1 6661                <1> 	popad
    89 00004BD3 C3                  <1> 	ret
    90                              <1> 
    91                              <1> ; --------------------------------------------------------------------------
    92                              <1> ; os_disk_get_param_table -- Get the pointer to the disk param table
    93                              <1> ; IN: DL = drive number, OUT: DS:DI = pointer to param table
    94                              <1> 
    95                              <1> os_disk_get_param_table:
    96                              <1> 	movs ds, fs					; Segment 0
    39 00004BD4 0FA0                <2>  push %2
    40 00004BD6 1F                  <2>  pop %1
    97                              <1> 
    98 00004BD7 0FB6FA              <1> 	movzx di, dl				; Each entry is 8 bytes wide
    99 00004BDA C1E703              <1> 	shl di, 3
   100                              <1> 
   101 00004BDD 81C7002E            <1> 	add di, DISK_PARAMS			; Add the offset to the table
   102 00004BE1 C3                  <1> 	ret
   103                              <1> 
   104                              <1> ; --------------------------------------------------------------------------
   105                              <1> ; os_disk_reset_device -- Resets a given disk device
   106                              <1> ; IN: DL = drive number, OUT: carry set if error
   107                              <1> 
   108                              <1> os_disk_reset_device:
   109 00004BE2 60                  <1> 	pusha
   110 00004BE3 1E                  <1> 	push ds
   111 00004BE4 E8EDFF              <1> 	call os_disk_get_param_table
   112                              <1> 
   113 00004BE7 807D0100            <1> 	cmp byte [di + 1], 0
   114 00004BEB 7403                <1> 	je .reset_chs
   115                              <1> 
   116                              <1> .exit:
   117 00004BED 1F                  <1> 	pop ds
   118 00004BEE 61                  <1> 	popa
   119 00004BEF C3                  <1> 	ret
   120                              <1> 
   121                              <1> .reset_chs:
   122 00004BF0 B400                <1> 	mov ah, 0				; Perform a reset via legacy CHS
   123 00004BF2 E8ABFF              <1> 	call os_int13_protected
   124 00004BF5 EBF6                <1> 	jmp .exit				; Pass along the carry flag
   125                              <1> 
   126                              <1> ; --------------------------------------------------------------------------
   127                              <1> ; os_disk_detect_drive -- Read basic information about the drive if a change occured
   128                              <1> ; IN: DL = drive number, OUT: carry set if error
   129                              <1> ;
   130                              <1> ; Disk info format:
   131                              <1> ;   00 (byte) = drive number
   132                              <1> ;   01 (byte) = mode (0 = CHS, 1 = LBA)
   133                              <1> ;   If CHS:
   134                              <1> ;     02-03 (word) = number of sectors per track
   135                              <1> ;     04-05 (word) = number of tracks
   136                              <1> ;     06 (byte) = number of heads
   137                              <1> ;   If LBA:
   138                              <1> ;     02-05 (dword) = number of sectors
   139                              <1> ;     06-07 (word) = bytes per sector
   140                              <1> 
   141                              <1> os_disk_detect_drive:
   142 00004BF7 60                  <1> 	pusha
   143 00004BF8 1E                  <1> 	push ds
   144                              <1> 
   145 00004BF9 E8D8FF              <1> 	call os_disk_get_param_table
   146                              <1> 	
   147 00004BFC 8815                <1> 	mov [di], dl			; Start populating the table
   148                              <1> 
   149                              <1> ;	cmp dl, 80h				; Check if we're dealing with a floppy or fixed disk
   150                              <1> ;	jae .fixed_disk			; TODO: CHECK IF LBA ACTUALLY WORKS! (now disabled)
   151                              <1> 
   152                              <1> 	; Floppy (drive number 00-7F)
   153                              <1> 
   154                              <1> .get_chs:
   155 00004BFE 807D01FF            <1> 	cmp byte [di + 1], 0FFh	; Has this drive been initialized at all?
   156 00004C02 7407                <1> 	je .skip_chs_check
   157                              <1> 
   158 00004C04 B416                <1> 	mov ah, 16h				; Check if a disk change occured, if it did, do not re-load the params
   159 00004C06 E897FF              <1> 	call os_int13_protected
   160 00004C09 732E                <1> 	jnc .end
   161                              <1> 
   162                              <1> .skip_chs_check:
   163 00004C0B 57                  <1> 	push di
   164 00004C0C 06                  <1> 	push es
   165 00004C0D B408                <1> 	mov ah, 8				; Get drive parameters
   166 00004C0F E89AFF              <1> 	call os_int13_failsafe
   167 00004C12 07                  <1> 	pop es
   168 00004C13 5F                  <1> 	pop di
   169                              <1> 
   170 00004C14 7223                <1> 	jc .end
   171                              <1> 
   172 00004C16 89C8                <1> 	mov ax, cx				; Number of sectors per track
   173 00004C18 83E03F              <1> 	and ax, 3Fh
   174 00004C1B 741F                <1> 	jz .err
   175 00004C1D 894502              <1> 	mov [di + 2], ax
   176                              <1> 
   177 00004C20 80E1C0              <1> 	and cl, 11000000b		; Number of tracks
   178 00004C23 C0E906              <1> 	shr cl, 6
   179 00004C26 C1C108              <1> 	rol cx, 8
   180 00004C29 41                  <1> 	inc cx
   181 00004C2A 894D04              <1> 	mov [di + 4], cx
   182                              <1> 
   183 00004C2D 88F2                <1> 	mov dl, dh				; Number of heads
   184 00004C2F FEC2                <1> 	inc dl					; Head numbers start at 0 - add 1 for total
   185 00004C31 885506              <1> 	mov [di + 6], dl
   186                              <1> 
   187 00004C34 C6450100            <1> 	mov byte [di + 1], 0	; Mark as CHS drive
   188                              <1> 
   189 00004C38 F8                  <1> 	clc
   190                              <1> 
   191                              <1> .end:
   192 00004C39 1F                  <1> 	pop ds
   193 00004C3A 61                  <1> 	popa
   194 00004C3B C3                  <1> 	ret
   195                              <1> 
   196                              <1> .err:
   197 00004C3C F9                  <1> 	stc
   198 00004C3D EBFA                <1> 	jmp short .end
   199                              <1> 
   200                              <1> .fixed_disk:
   201                              <1> 	; Fixed disk (drive number 80-FF)
   202                              <1> 
   203 00004C3F B441                <1> 	mov ah, 41h				; Detect LBA support
   204 00004C41 BBAA55              <1> 	mov bx, 55AAh
   205 00004C44 E826FF              <1> 	call os_int13
   206                              <1> 
   207 00004C47 72B5                <1> 	jc .get_chs				; Fall back to CHS if not supported
   208                              <1> 
   209 00004C49 807D01FF            <1> 	cmp byte [di + 1], 0FFh	; Has this drive been initialized at all?
   210 00004C4D 7407                <1> 	je .skip_lba_check
   211                              <1> 
   212 00004C4F B449                <1> 	mov ah, 49h				; Check if a disk change occured, if it did, do not re-load the params
   213 00004C51 E84CFF              <1> 	call os_int13_protected
   214 00004C54 73E3                <1> 	jnc .end
   215                              <1> 
   216                              <1> .skip_lba_check:
   217 00004C56 81FB55AA            <1> 	cmp bx, 0AA55h			; Fall back to CHS if signature invalid
   218 00004C5A 75A2                <1> 	jne .get_chs
   219                              <1> 
   220 00004C5C 06                  <1> 	push es
   221                              <1> 
   222                              <1> 	movs es, ds				; DS = BIOS drive param table, ES = our struct
    39 00004C5D 1E                  <2>  push %2
    40 00004C5E 07                  <2>  pop %1
   223                              <1> 
   224 00004C5F B07F                <1> 	mov al, 7Fh				; Allocate a buffer in the disk cache
   225 00004C61 E8EC00              <1> 	call os_disk_cache_alloc_sector
   226                              <1> 
   227 00004C64 B448                <1> 	mov ah, 48h				; Get drive parameters (extended)
   228 00004C66 E843FF              <1> 	call os_int13_failsafe
   229                              <1> 
   230 00004C69 7212                <1> 	jc .lba_end
   231                              <1> 
   232 00004C6B 47                  <1> 	inc di
   233                              <1> 
   234 00004C6C B001                <1> 	mov al, 1				; Mark as LBA drive
   235 00004C6E AA                  <1> 	stosb
   236                              <1> 
   237 00004C6F 66A5                <1> 	movsd					; Number of sectors
   238                              <1> 
   239 00004C71 AD                  <1> 	lodsw					; Check if the drive is under 2^32 sectors
   240 00004C72 85C0                <1> 	test ax, ax
   241 00004C74 750B                <1> 	jnz .lba_err
   242                              <1> 
   243 00004C76 AD                  <1> 	lodsw
   244 00004C77 85C0                <1> 	test ax, ax
   245 00004C79 7506                <1> 	jnz .lba_err
   246                              <1> 
   247 00004C7B A5                  <1> 	movsw					; Bytes per sector
   248                              <1> 
   249 00004C7C F8                  <1> 	clc
   250                              <1> 
   251                              <1> .lba_end:
   252 00004C7D 07                  <1> 	pop es
   253                              <1> 
   254 00004C7E 1F                  <1> 	pop ds
   255 00004C7F 61                  <1> 	popa
   256 00004C80 C3                  <1> 	ret
   257                              <1> 
   258                              <1> .lba_err:
   259 00004C81 F9                  <1> 	stc
   260 00004C82 EBF9                <1> 	jmp .lba_end
   261                              <1> 
   262                              <1> ; --------------------------------------------------------------------------
   263                              <1> ; os_disk_read_sector -- Read a single sector from disk
   264                              <1> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   265                              <1> 
   266                              <1> os_disk_read_sector:
   267 00004C84 6660                <1> 	pushad
   268 00004C86 1E                  <1> 	push ds
   269 00004C87 E86DFF              <1> 	call os_disk_detect_drive			; Detect drive change
   270 00004C8A 720B                <1> 	jc .err
   271                              <1> 
   272 00004C8C E85500              <1> 	call os_disk_init_int13				; Prepare the params
   273 00004C8F 7206                <1> 	jc .err
   274                              <1> 
   275                              <1> ;	call os_dump_registers
   276                              <1> 
   277 00004C91 E834FF              <1> 	call os_int13_failsafe_protected	; Read the sector
   278 00004C94 7201                <1> 	jc .err
   279                              <1> 
   280 00004C96 F8                  <1> 	clc
   281                              <1> 
   282                              <1> .err:
   283 00004C97 1F                  <1> 	pop ds
   284 00004C98 6661                <1> 	popad
   285 00004C9A C3                  <1> 	ret
   286                              <1> 
   287                              <1> ; --------------------------------------------------------------------------
   288                              <1> ; os_disk_read_multiple_sectors -- Read multiple sectors from disk
   289                              <1> ; IN: EAX = sector ID, CX = number of sectors, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   290                              <1> 
   291                              <1> os_disk_read_multiple_sectors:
   292 00004C9B 6660                <1> 	pushad
   293 00004C9D 06                  <1> 	push es
   294                              <1> 
   295                              <1> .loop:
   296 00004C9E E8E3FF              <1> 	call os_disk_read_sector	; Read a single sector
   297 00004CA1 720C                <1> 	jc .end
   298                              <1> 
   299 00004CA3 6640                <1> 	inc eax						; Point to the next one
   300                              <1> 
   301 00004CA5 8CC3                <1> 	mov bx, es					; Advance the memory pointer 512 bytes forward
   302 00004CA7 83C320              <1> 	add bx, 32
   303 00004CAA 8EC3                <1> 	mov es, bx
   304                              <1> 
   305 00004CAC E2F0                <1> 	loop .loop
   306                              <1> 
   307 00004CAE F8                  <1> 	clc
   308                              <1> 
   309                              <1> .end:
   310 00004CAF 07                  <1> 	pop es
   311 00004CB0 6661                <1> 	popad
   312 00004CB2 C3                  <1> 	ret
   313                              <1> 
   314                              <1> ; --------------------------------------------------------------------------
   315                              <1> ; os_disk_write_sector -- Write a single sector to disk
   316                              <1> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   317                              <1> 
   318                              <1> os_disk_write_sector:
   319 00004CB3 6660                <1> 	pushad
   320 00004CB5 1E                  <1> 	push ds
   321 00004CB6 E83EFF              <1> 	call os_disk_detect_drive			; Detect drive change
   322 00004CB9 720D                <1> 	jc .err
   323                              <1> 
   324 00004CBB E82600              <1> 	call os_disk_init_int13				; Prepare the params
   325 00004CBE 7208                <1> 	jc .err
   326                              <1> 
   327 00004CC0 FEC4                <1> 	inc ah								; Select write operation (works for both CHS and LBA)
   328                              <1> 
   329                              <1> ;	call os_dump_registers
   330                              <1> 
   331 00004CC2 E803FF              <1> 	call os_int13_failsafe_protected	; Read the sector
   332 00004CC5 7201                <1> 	jc .err
   333                              <1> 
   334 00004CC7 F8                  <1> 	clc
   335                              <1> 
   336                              <1> .err:
   337 00004CC8 1F                  <1> 	pop ds
   338 00004CC9 6661                <1> 	popad
   339 00004CCB C3                  <1> 	ret
   340                              <1> 
   341                              <1> ; --------------------------------------------------------------------------
   342                              <1> ; os_disk_write_multiple_sectors -- Write multiple sectors to disk
   343                              <1> ; IN: EAX = sector ID, CX = number of sectors, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   344                              <1> 
   345                              <1> os_disk_write_multiple_sectors:
   346 00004CCC 6660                <1> 	pushad
   347 00004CCE 06                  <1> 	push es
   348                              <1> 
   349                              <1> .loop:
   350 00004CCF E8E1FF              <1> 	call os_disk_write_sector	; Write a single sector
   351 00004CD2 720C                <1> 	jc .end
   352                              <1> 
   353 00004CD4 6640                <1> 	inc eax						; Point to the next one
   354                              <1> 
   355 00004CD6 8CC3                <1> 	mov bx, es					; Advance the memory pointer 512 bytes forward
   356 00004CD8 83C320              <1> 	add bx, 32
   357 00004CDB 8EC3                <1> 	mov es, bx
   358                              <1> 
   359 00004CDD E2F0                <1> 	loop .loop
   360                              <1> 
   361 00004CDF F8                  <1> 	clc
   362                              <1> 
   363                              <1> .end:
   364 00004CE0 07                  <1> 	pop es
   365 00004CE1 6661                <1> 	popad
   366 00004CE3 C3                  <1> 	ret
   367                              <1> 
   368                              <1> ; --------------------------------------------------------------------------
   369                              <1> ; os_disk_init_int13 -- Converts a LBA value to the proper INT 13h params
   370                              <1> ; IN: EAX = sector ID, ES:SI = buffer pointer, DL = drive number
   371                              <1> ; OUT: carry set if error
   372                              <1> ;   If CHS:
   373                              <1> ;     ax = 0201h (CHS read - single sector)
   374                              <1> ;     ch/cl/dh = appropriate CHS params
   375                              <1> ;     dl = drive number
   376                              <1> ;     es:bx = pointer to buffer
   377                              <1> ;     destroyed DS, upper 16 bits of EAX, EBX
   378                              <1> ;   If LBA:
   379                              <1> ;     ax = 4200h (extended read)
   380                              <1> ;     dl = drive number
   381                              <1> ;     ds:si = pointer to populated disk packet
   382                              <1> 
   383                              <1> os_disk_init_int13:
   384 00004CE4 57                  <1> 	push di
   385 00004CE5 E8ECFE              <1> 	call os_disk_get_param_table
   386                              <1> 
   387 00004CE8 807D0100            <1> 	cmp byte [di + 1], 0			; Does the disk use CHS addressing?
   388 00004CEC 7409                <1> 	je .init_chs
   389                              <1> 
   390 00004CEE 807D0101            <1> 	cmp byte [di + 1], 1			; Does the disk use LBA?
   391 00004CF2 7432                <1> 	je .init_lba
   392                              <1> 
   393                              <1> .err:
   394 00004CF4 F9                  <1> 	stc								; If neither, the drive is not initialized (which shouldn't happen) - bail out
   395                              <1> 
   396                              <1> .end:
   397 00004CF5 5F                  <1> 	pop di
   398 00004CF6 C3                  <1> 	ret
   399                              <1> 
   400                              <1> .init_chs:
   401                              <1> 	; LBA = (Track * NumberOfHeads + Head) * SectorsPerTrack + Sector - 1
   402 00004CF7 6652                <1> 	push edx
   403                              <1> 
   404                              <1> 	clr edx
    31 00004CF9 6631D2              <2>  xor %1, %1
   405 00004CFC 660FB75D02          <1> 	movzx ebx, word [di + 2]		; Number of sectors per track
   406 00004D01 66F7F3              <1> 	div ebx							; EAX = (Track * NumberOfHeads + Head), (E)DX = Sector - 1 (max 63)
   407                              <1> 
   408 00004D04 42                  <1> 	inc dx							; DX = Sector
   409 00004D05 88D1                <1> 	mov cl, dl						; CL = Sector
   410                              <1> 
   411                              <1> 	clr edx
    31 00004D07 6631D2              <2>  xor %1, %1
   412 00004D0A 660FB65D06          <1> 	movzx ebx, byte [di + 6]		; Number of tracks
   413 00004D0F 66F7F3              <1> 	div ebx							; (E)DX = Track, (E)AX = Head
   414                              <1> 
   415 00004D12 89D3                <1> 	mov bx, dx
   416 00004D14 665A                <1> 	pop edx
   417                              <1> 
   418 00004D16 88DE                <1> 	mov dh, bl						; DH = Head
   419 00004D18 88C5                <1> 	mov ch, al						; CH = Track number (bits 0-7)
   420                              <1> 
   421 00004D1A C0E406              <1> 	shl ah, 6
   422 00004D1D 08E1                <1> 	or cl, ah						; CL(6..7) = Track number (bits 8-9)
   423                              <1> 
   424 00004D1F B80102              <1> 	mov ax, 0201h					; CHS read, sigle sector
   425 00004D22 89F3                <1> 	mov bx, si						; Output buffer pointer
   426 00004D24 EBCF                <1> 	jmp .end
   427                              <1> 
   428                              <1> .init_lba:
   429 00004D26 817D060002          <1> 	cmp word [di + 6], 512			; Check if the drive uses 512-byte sectors
   430 00004D2B 74C7                <1> 	je .err							; If it does not, bail out
   431                              <1> 
   432 00004D2D 56                  <1> 	push si
   433 00004D2E BE[404D]            <1> 	mov si, .packet					; Initialize driver packet pointer
   434                              <1> 	movs ds, cs
    39 00004D31 0E                  <2>  push %2
    40 00004D32 1F                  <2>  pop %1
   435                              <1> 
   436 00004D33 66894408            <1> 	mov [si + 8], eax				; LBA address
   437 00004D37 58                  <1> 	pop ax
   438 00004D38 894404              <1> 	mov [si + 4], ax				; Buffer offset
   439 00004D3B 8C4406              <1> 	mov [si + 6], es				; Buffer segment
   440                              <1> 
   441 00004D3E EBB5                <1> 	jmp .end
   442                              <1> 
   443                              <1> .packet:
   444 00004D40 10                  <1> 	db 10h		; Packet size
   445 00004D41 00                  <1> 	db 0		; Reserved, should be zero
   446 00004D42 0100                <1> 	dw 1		; Number of blocks
   447 00004D44 0000                <1> 	dw 0		; Buffer offset
   448 00004D46 0000                <1> 	dw 0		; Buffer segment
   449 00004D48 0000000000000000    <1> 	dq 0		; LBA address
   534                                  	%INCLUDE "features/disk/cache.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; MichalOS Disk cache driver
     3                              <1> ; ==================================================================
     4                              <1> 
     5                              <1> ; --------------------------------------------------------------------------
     6                              <1> ; os_disk_cache_alloc_sector -- Allocates a free sector in the cache
     7                              <1> ; IN: DL = drive number, OUT: DS:SI = free 512 byte buffer
     8                              <1> 
     9                              <1> os_disk_cache_alloc_sector:
    10                              <1> 	; TODO
    11 00004D50 C3                  <1> 	ret
    12                              <1> 
    13                              <1> ; --------------------------------------------------------------------------
    14                              <1> ; os_disk_cache_read_sector -- Read a single sector from cache or disk, if necessary
    15                              <1> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
    16                              <1> 
    17                              <1> os_disk_cache_read_sector:
    18 00004D51 C3                  <1> 	ret
    19                              <1> 
    20                              <1> ; --------------------------------------------------------------------------
    21                              <1> ; os_disk_cache_write_sector -- Write a single sector to cache or flush disk, if necessary
    22                              <1> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
    23                              <1> 
    24                              <1> os_disk_cache_write_sector:
    25 00004D52 C3                  <1> 	ret
   535                                  
   536                                  ; ==================================================================
   537                                  ; END OF KERNEL
   538                                  ; ==================================================================
   539                                  
   540                                  os_kernel_end:
   541 00004D53 00                      	db 0 ; for kerneltree.py
