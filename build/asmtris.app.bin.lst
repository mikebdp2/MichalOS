     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ;
     3                                  ; aSMtris
     4                                  ;            a Tetris-like game written in x86 assembly language (16 bit)
     5                                  ;
     6                                  ;            by Sebastian Mihai, 2014
     7                                  ;            http://sebastianmihai.com (operational as of March 2014)
     8                                  ;
     9                                  ;            Assemble using NASM via: 
    10                                  ;                                        nasm -f bin -o aSMtris.com aSMtris.asm
    11                                  ;
    12                                  ;            Run directly in Windows XP or older, or via DOSBox
    13                                  ;
    14                                  ;
    15                                  ; After completing an C#/XNA game project, I really wanted to delve down to the
    16                                  ; metal again, and what better way to do so than with assembly language?
    17                                  ; I wrote my last assembly program back in 2000 (it was a Nibbles-like 
    18                                  ; attempt), but did not actually complete it. Fourteen years later, I decided
    19                                  ; that writing a game in assembly language was a loose end that had to be tied.
    20                                  ;
    21                                  ; I tried to keep the code well-documented (hence the large size of this file)
    22                                  ; and I make no claims as to the ultimate efficiency of the algorithms! :)
    23                                  ;
    24                                  ; In terms of program organization, it is split into these main chunks:
    25                                  ;    1. the constants/variables area - basically a "data" area
    26                                  ;    2. initialization - executed once per program run, sets up screen, etc.
    27                                  ;    3. main program - executed in a loop until program exit
    28                                  ;                    - handles pieces falling, piece generation, scoring, etc.
    29                                  ;    4. procedures - subroutines invoked via call statements
    30                                  ;                  - see procedures heading below for more information
    31                                  ;
    32                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    33                                  
    34                                  
    35                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    36                                      ; COM programs are required to have their origin at CS:0100h
    37                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    38                                      %include "include/program.inc"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; Include file for MichalOS program or kernel module development
     3                              <1> ; ------------------------------------------------------------------
     4                              <1> 
     5                              <1> 	BITS 16
     6                              <1> 	ORG 100h
     7                              <1> 	
     8                              <1> 	%include "include/constants.asm"
     1                              <2> ; ------------------------------------------------------------------
     2                              <2> ; Include file for MichalOS kernel/program development - constants & macros
     3                              <2> ; ------------------------------------------------------------------
     4                              <2> 
     5                              <2> ; ------------------------------------------------------------------
     6                              <2> ; COLOURS (eg for os_draw_background and os_draw_block)
     7                              <2> 
     8                              <2> %DEFINE BLACK_ON_WHITE		11110000b
     9                              <2> %DEFINE WHITE_ON_BLACK		00001111b
    10                              <2> 
    11                              <2> ; ------------------------------------------------------------------
    12                              <2> ; KEYS
    13                              <2> 
    14                              <2> %DEFINE KEY_UP		72
    15                              <2> %DEFINE KEY_DOWN	80
    16                              <2> %DEFINE KEY_LEFT	75
    17                              <2> %DEFINE KEY_RIGHT	77
    18                              <2> 
    19                              <2> %DEFINE KEY_ESC		27
    20                              <2> %DEFINE KEY_ENTER	13
    21                              <2> 
    22                              <2> ; ------------------------------------------------------------------
    23                              <2> ; MACROS
    24                              <2> 
    25                              <2> %macro syscall 1
    26                              <2> 	mov bp, %1
    27                              <2> 	call os_syscall
    28                              <2> %endmacro
    29                              <2> 
    30                              <2> %macro clr 1
    31                              <2> 	xor %1, %1
    32                              <2> %endmacro
    33                              <2> 
    34                              <2> %macro mov16 3
    35                              <2> 	mov %1, (%2 + %3 * 256)
    36                              <2> %endmacro
    37                              <2> 
    38                              <2> %macro movs 2
    39                              <2> 	push %2
    40                              <2> 	pop %1
    41                              <2> %endmacro
    42                              <2> 
    43                              <2> ; ------------------------------------------------------------------
    44                              <2> ; MEMORY LOCATIONS
    45                              <2> 
    46                              <2> %define ADLIB_BUFFER 0500h
    47                              <2> %define DESKTOP_BACKGROUND 0600h
    48                              <2> %define SYSTEM_FONT 1600h
    49                              <2> %define FILE_MANAGER 2600h
    50                              <2> %define DISK_PARAMS 2E00h
    51                              <2> 
    52                              <2> %define DISK_BUFFER 0E000h
    53                              <2> %define CONFIG_FILE 57000
    54                              <2> %define CONFIG_FILE_SIZE 83
    55                              <2> 
    56                              <2> ; ------------------------------------------------------------------
    57                              <2> ; CONFIG FILE LOCATIONS
    58                              <2> 
    59                              <2> %define CONFIG(x) (CONFIG_FILE + x)
    60                              <2> 
    61                              <2> ; 0 = Desktop background color (BYTE)
    62                              <2> %define CONFIG_DESKTOP_BG_COLOR CONFIG(0)
    63                              <2> 
    64                              <2> ; 1 = Window background color (BYTE)
    65                              <2> %define CONFIG_WINDOW_BG_COLOR CONFIG(1)
    66                              <2> 
    67                              <2> ; 2 = Password enabled (BYTE)
    68                              <2> %define CONFIG_PASSWORD_ENABLED CONFIG(2)
    69                              <2> 
    70                              <2> ; 3 - 35 = Password data (STRING, 32 chars + '\0')
    71                              <2> %define CONFIG_PASSWORD CONFIG(3)
    72                              <2> %define CFG_PASSWORD_MAX_INPUT_LENGTH 32
    73                              <2> %define CFG_PASSWORD_MAX_LENGTH 33
    74                              <2> 
    75                              <2> ; 36 - 68 = Username (STRING, 32 chars + '\0')
    76                              <2> %define CONFIG_USERNAME CONFIG(36)
    77                              <2> %define CFG_USERNAME_MAX_INPUT_LENGTH 32
    78                              <2> %define CFG_USERNAME_MAX_LENGTH 33
    79                              <2> 
    80                              <2> ; 69 - Sound enabled on startup (BYTE)
    81                              <2> %define CONFIG_SOUND_ENABLED CONFIG(69)
    82                              <2> 
    83                              <2> ; 70 - Adlib driver number
    84                              <2> %define CONFIG_ADLIB_DRIVER CONFIG(70)
    85                              <2> %define CFG_ADLIB_STD_DRIVER 0
    86                              <2> %define CFG_ADLIB_PWM_DRIVER 1
    87                              <2> %define CFG_ADLIB_PWM_LOUD_DRIVER 2
    88                              <2> 
    89                              <2> ; 71 - Menu screen dimming enabled (BYTE)
    90                              <2> %define CONFIG_MENU_DIMMING CONFIG(71)
    91                              <2> 
    92                              <2> ; 72 - Menu color (BYTE)
    93                              <2> %define CONFIG_MENU_BG_COLOR CONFIG(72)
    94                              <2> 
    95                              <2> ; 73 - "DOS" font enabled (BYTE)
    96                              <2> %define CONFIG_FONT CONFIG(73)
    97                              <2> %define CFG_FONT_MICHALOS 0
    98                              <2> %define CFG_FONT_BIOS 1
    99                              <2> 
   100                              <2> ; 74 - Minutes to wait for screensaver (BYTE)
   101                              <2> %define CONFIG_SCREENSAVER_MINUTES CONFIG(74)
   102                              <2> 
   103                              <2> ; 75 - System stack size in 16-byte blocks (WORD)
   104                              <2> %define CONFIG_STACKSGMT_SIZE CONFIG(75)
   105                              <2> 
   106                              <2> ; 77 - 80 - Unused *******************************
   107                              <2> 
   108                              <2> ; 81 - Minute time offset (WORD)
   109                              <2> %define CONFIG_TIMEZONE_OFFSET CONFIG(81)
   110                              <2> 
   111                              <2> ; ------------------------------------------------------------------
   112                              <2> ; MUSICAL NOTE FREQUENCY LIST
   113                              <2> 
   114                              <2> A2		equ 110
   115                              <2> AS2		equ 117
   116                              <2> B2		equ 124
   117                              <2> C3		equ 131
   118                              <2> CS3		equ 139
   119                              <2> D3		equ 147
   120                              <2> DS3		equ 156
   121                              <2> E3		equ 165
   122                              <2> F3		equ 175
   123                              <2> FS3		equ 185
   124                              <2> G3		equ 196
   125                              <2> GS3		equ 208
   126                              <2> A3		equ 220
   127                              <2> AS3		equ 233
   128                              <2> B3		equ 247
   129                              <2> C4		equ 262
   130                              <2> CS4		equ 277
   131                              <2> D4		equ 294
   132                              <2> DS4		equ 311
   133                              <2> E4		equ 330
   134                              <2> F4		equ 349
   135                              <2> FS4		equ 370
   136                              <2> G4		equ 392
   137                              <2> GS4		equ 415
   138                              <2> A4		equ 440
   139                              <2> AS4		equ 466
   140                              <2> B4		equ 494
   141                              <2> C5		equ 523
   142                              <2> CS5		equ 554
   143                              <2> D5		equ 587
   144                              <2> DS5		equ 622
   145                              <2> E5		equ 659
   146                              <2> F5		equ 698
   147                              <2> FS5		equ 740
   148                              <2> G5		equ 784
   149                              <2> GS5		equ 831
   150                              <2> A5		equ 880
   151                              <2> AS5		equ 932
   152                              <2> B5		equ 988
   153                              <2> C6		equ 1046
   154                              <2> CS6		equ 1109
   155                              <2> D6		equ 1175
   156                              <2> DS6		equ 1245
   157                              <2> E6		equ 1319
   158                              <2> F6		equ 1397
   159                              <2> FS6		equ 1480
   160                              <2> G6		equ 1568
   161                              <2> GS6		equ 1661
   162                              <2> A6		equ 1760
   163                              <2> AS6		equ 1865
   164                              <2> B6		equ 1976
   165                              <2> C7		equ 2093
   166                              <2> CS7		equ 2217
   167                              <2> D7		equ 2349
   168                              <2> DS7		equ 2489
   169                              <2> E7		equ 2637
   170                              <2> F7		equ 2794
   171                              <2> FS7		equ 2960
   172                              <2> G7		equ 3136
   173                              <2> GS7		equ 3322
   174                              <2> A7		equ 3520
   175                              <2> AS7		equ 3729
   176                              <2> B7		equ 3951
   177                              <2> C8		equ 4186
   178                              <2> CS8		equ 4435
   179                              <2> D8		equ 4699
   180                              <2> DS8		equ 4978
   181                              <2> E8		equ 5274
   182                              <2> F8		equ 5588
   183                              <2> FS8		equ 5920
   184                              <2> G8		equ 6272
   185                              <2> GS8		equ 6645
   186                              <2> A8		equ 7040
   187                              <2> AS8		equ 7459
   188                              <2> B8		equ 7902
     9                              <1> 	%include "include/syscalls.asm"
     1                              <2> ; ------------------------------------------------------------------
     2                              <2> ; Include file for MichalOS program development - syscalls
     3                              <2> ; ------------------------------------------------------------------
     4                              <2> 
     5                              <2> ; ==================================================================
     6                              <2> ; MichalOS Sound functions (PC speaker, YM3812)
     7                              <2> ; ==================================================================
     8                              <2> 
     9                              <2> ; ------------------------------------------------------------------
    10                              <2> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
    11                              <2> ; IN: AX = note frequency (in Hz)
    12                              <2> ; OUT: None, registers preserved
    13                              <2> 
    14                              <2> os_speaker_tone equ 32795
    15                              <2> 
    16                              <2> ; ------------------------------------------------------------------
    17                              <2> ; os_speaker_raw_period -- Generate PC speaker tone (call os_speaker_off to turn off)
    18                              <2> ; IN: AX = note period (= 105000000 / 88 / freq)
    19                              <2> ; OUT: None, registers preserved
    20                              <2> 
    21                              <2> os_speaker_raw_period equ 33107
    22                              <2> 
    23                              <2> ; ------------------------------------------------------------------
    24                              <2> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
    25                              <2> ; IN: AX = note frequency, CX = length (in ticks)
    26                              <2> ; OUT: None, registers preserved
    27                              <2> 
    28                              <2> os_speaker_note_length equ 32900
    29                              <2> 
    30                              <2> ; ------------------------------------------------------------------
    31                              <2> ; os_speaker_off -- Turn off PC speaker
    32                              <2> ; IN/OUT: None, registers preserved
    33                              <2> 
    34                              <2> os_speaker_off equ 32798
    35                              <2> 
    36                              <2> ; ------------------------------------------------------------------
    37                              <2> ; os_speaker_muted -- Check if the PC speaker is muted
    38                              <2> ; OUT: ZF set if muted, clear if not
    39                              <2> 
    40                              <2> os_speaker_muted equ 33125
    41                              <2> 
    42                              <2> ; ------------------------------------------------------------------
    43                              <2> ; os_start_adlib -- Starts the selected Adlib driver
    44                              <2> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
    45                              <2> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
    46                              <2> ; Common prescaler values:
    47                              <2> ;		33 = ~1 kHz (1004.362 Hz)
    48                              <2> ;		663 = ~50 Hz (49.991 Hz)
    49                              <2> ;		1820 = ~18.2 Hz (18.211 Hz)
    50                              <2> ; OUT: None, registers preserved
    51                              <2> 
    52                              <2> os_start_adlib equ 32984
    53                              <2> 
    54                              <2> ; ------------------------------------------------------------------
    55                              <2> ; os_stop_adlib -- Stops the Adlib driver
    56                              <2> ; IN/OUT: None, registers preserved
    57                              <2> 
    58                              <2> os_stop_adlib equ 33026
    59                              <2> 
    60                              <2> ; ------------------------------------------------------------------
    61                              <2> ; os_adlib_regwrite -- Write to a YM3812 register
    62                              <2> ; IN: AH/AL - register address/value to write
    63                              <2> 
    64                              <2> os_adlib_regwrite equ 32843
    65                              <2> 
    66                              <2> ; ------------------------------------------------------------------
    67                              <2> ; os_adlib_mute -- Mute the YM3812's current state
    68                              <2> ; IN/OUT: None
    69                              <2> 
    70                              <2> os_adlib_mute equ 33044
    71                              <2> 
    72                              <2> ; ------------------------------------------------------------------
    73                              <2> ; os_adlib_unmute -- Unmute the YM3812's current state
    74                              <2> ; IN/OUT: None
    75                              <2> 
    76                              <2> os_adlib_unmute equ 33089
    77                              <2> 
    78                              <2> ; ------------------------------------------------------------------
    79                              <2> ; os_adlib_calcfreq -- Play a frequency
    80                              <2> ; IN: AX - frequency, CL = channel
    81                              <2> ; OUT: None, registers preserved
    82                              <2> 
    83                              <2> os_adlib_calcfreq equ 32966
    84                              <2> 
    85                              <2> ; ------------------------------------------------------------------
    86                              <2> ; os_adlib_noteoff -- Turns off a note
    87                              <2> ; IN: CL = channel
    88                              <2> ; OUT: None, registers preserved
    89                              <2> 
    90                              <2> os_adlib_noteoff equ 33029
    91                              <2> 
    92                              <2> ; ==================================================================
    93                              <2> ; MichalOS Text display output functions
    94                              <2> ; ==================================================================
    95                              <2> 
    96                              <2> ; ------------------------------------------------------------------
    97                              <2> ; os_putchar -- Puts a character on the screen
    98                              <2> ; IN: AL = character
    99                              <2> ; OUT: None, registers preserved
   100                              <2> 
   101                              <2> os_putchar equ 32981
   102                              <2> 
   103                              <2> ; ------------------------------------------------------------------
   104                              <2> ; os_put_chars -- Puts up to a set amount of characters on the screen
   105                              <2> ; IN: BL = terminator, DS:SI = location, CX = character count
   106                              <2> ; OUT: None, registers preserved
   107                              <2> 
   108                              <2> os_put_chars equ 32996
   109                              <2> 
   110                              <2> ; ------------------------------------------------------------------
   111                              <2> ; os_print_string -- Displays text
   112                              <2> ; IN: DS:SI = message location (zero-terminated string)
   113                              <2> ; OUT: None, registers preserved
   114                              <2> 
   115                              <2> os_print_string equ 32771
   116                              <2> 
   117                              <2> ; ------------------------------------------------------------------
   118                              <2> ; os_print_string_box -- Displays text inside a text-box.
   119                              <2> ; IN: DS:SI = message location (zero-terminated string), DL = left alignment
   120                              <2> ; OUT: None, registers preserved
   121                              <2> 
   122                              <2> os_print_string_box equ 32993
   123                              <2> 
   124                              <2> ; ------------------------------------------------------------------
   125                              <2> ; os_format_string -- Displays colored text
   126                              <2> ; IN: DS:SI = message location (zero-terminated string), BL = text color
   127                              <2> ; OUT: None, registers preserved
   128                              <2> 
   129                              <2> os_format_string equ 32978
   130                              <2> 
   131                              <2> ; ------------------------------------------------------------------
   132                              <2> ; os_clear_screen -- Clears the screen to background
   133                              <2> ; IN/OUT: None, registers preserved
   134                              <2> 
   135                              <2> os_clear_screen equ 32777
   136                              <2> 
   137                              <2> ; ------------------------------------------------------------------
   138                              <2> ; os_move_cursor -- Moves cursor in text mode
   139                              <2> ; IN: DH, DL = row, column
   140                              <2> ; OUT: None, registers preserved
   141                              <2> 
   142                              <2> os_move_cursor equ 32774
   143                              <2> 
   144                              <2> ; ------------------------------------------------------------------
   145                              <2> ; os_get_cursor_pos -- Return position of text cursor
   146                              <2> ; IN: None
   147                              <2> ; OUT: DH, DL = row, column
   148                              <2> 
   149                              <2> os_get_cursor_pos equ 32870
   150                              <2> 
   151                              <2> ; ------------------------------------------------------------------
   152                              <2> ; os_show_cursor -- Turns on cursor in text mode
   153                              <2> ; IN/OUT: None, registers preserved
   154                              <2> 
   155                              <2> os_show_cursor equ 32903
   156                              <2> 
   157                              <2> ; ------------------------------------------------------------------
   158                              <2> ; os_hide_cursor -- Turns off cursor in text mode
   159                              <2> ; IN/OUT: None, registers preserved
   160                              <2> 
   161                              <2> os_hide_cursor equ 32906
   162                              <2> 
   163                              <2> ; ------------------------------------------------------------------
   164                              <2> ; os_draw_block -- Render block of specified colour
   165                              <2> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   166                              <2> ; OUT: None, registers preserved
   167                              <2> 
   168                              <2> os_draw_block equ 32945
   169                              <2> 
   170                              <2> ; ------------------------------------------------------------------
   171                              <2> ; os_file_selector -- Show a file selection dialog
   172                              <2> ; IN: None
   173                              <2> ; OUT: AX = location of filename string (or carry set if Esc pressed)
   174                              <2> 
   175                              <2> os_file_selector equ 32855
   176                              <2> 
   177                              <2> ; ------------------------------------------------------------------
   178                              <2> ; os_file_selector_filtered -- Show a file selection dialog only 
   179                              <2> ; with files mathing the filter
   180                              <2> ; IN: ES:BX = location of file extension list (0 if none)
   181                              <2> ; OUT: DS:AX = location of filename string (or carry set if Esc pressed)
   182                              <2> 
   183                              <2> os_file_selector_filtered equ 33122
   184                              <2> 
   185                              <2> ; ------------------------------------------------------------------
   186                              <2> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
   187                              <2> ; That means, when the user changes the selection, the application will be called back
   188                              <2> ; to change the tooltip's contents.
   189                              <2> ; IN: DS:AX = comma-separated list of strings to show (zero-terminated),
   190                              <2> ;     DS:BX = first help string, DS:CX = second help string
   191                              <2> ;     SI = key/display callback (see os_list_dialog_ex)
   192                              <2> ;     if AX = 0: DI = entry display callback, DX = number of entries
   193                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   194                              <2> 
   195                              <2> os_list_dialog_tooltip equ 32912
   196                              <2> 
   197                              <2> ; ------------------------------------------------------------------
   198                              <2> ; os_list_dialog -- Show a dialog with a list of options
   199                              <2> ; IN: ES:AX = comma-separated list of strings to show (zero-terminated),
   200                              <2> ;     ES:BX = first help string, ES:CX = second help string
   201                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   202                              <2> 
   203                              <2> os_list_dialog equ 32936
   204                              <2> 
   205                              <2> ; ------------------------------------------------------------------
   206                              <2> ; os_list_dialog_ex -- Show a dialog with a list of options
   207                              <2> ; IN: DS:BX = pointer to setup struct
   208                              <2> ;       Addr Size Description
   209                              <2> ;       000h word Pointer to entry display callback (accepts CX as entry ID, prints out result) - valid only if ptr to list is zero
   210                              <2> ;       002h word Pointer to comma-separated list of strings to show (zero-terminated)
   211                              <2> ;       004h word Pointer to key/entry change callback (accepts AX as entry ID, CX as keypress),
   212                              <2> ;       006h word Number of entries (if 0, then it is automatically calculated from 002h)
   213                              <2> ;       008h word Pointer to first help string (if 0, then the list will fill the whole dialog)
   214                              <2> ;       00Ah word Pointer to second help string
   215                              <2> ;       00Ch word (ES) Pointer to history data (points to a 5 byte array)
   216                              <2> ;       00Eh byte Screen X position
   217                              <2> ;       00Fh byte Screen Y position
   218                              <2> ;       010h byte Dialog width
   219                              <2> ;       011h byte Dialog height
   220                              <2> ;       012h word Source segment (used for comma-separated list & help strings)
   221                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   222                              <2> 
   223                              <2> os_list_dialog_ex equ 33113
   224                              <2> 
   225                              <2> ; ------------------------------------------------------------------
   226                              <2> ; os_select_list -- Draws a list of entries (defined by a callback) to select from.
   227                              <2> ; IN: AX = width/height, BL = color, CX = number of entries, DX = X/Y pos,
   228                              <2> ;     SI = callback (if C clear = accepts an entry ID in CX, prints an appropriate string,
   229                              <2> ;     if C set = accepts key input in AX, entry ID in CX; not required to preserve regs),
   230                              <2> ;     ES:DI = pointer to a history struct (word .num_of_entries, word .skip_num, byte .cursor) or 0 if none
   231                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   232                              <2> 
   233                              <2> os_select_list equ 33110
   234                              <2> 
   235                              <2> ; ------------------------------------------------------------------
   236                              <2> ; os_draw_background -- Clear screen with white top and bottom bars
   237                              <2> ; containing text, and a coloured middle section.
   238                              <2> ; IN: DS:AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
   239                              <2> ; OUT: None, registers preserved
   240                              <2> 
   241                              <2> os_draw_background equ 32807
   242                              <2> 
   243                              <2> ; ------------------------------------------------------------------
   244                              <2> ; os_print_newline -- Reset cursor to start of next line
   245                              <2> ; IN/OUT: None, registers preserved
   246                              <2> 
   247                              <2> os_print_newline equ 32783
   248                              <2> 
   249                              <2> ; ------------------------------------------------------------------
   250                              <2> ; os_dump_registers -- Dumps all register contents in hex to the screen
   251                              <2> ; IN: All registers
   252                              <2> ; OUT: None, registers preserved
   253                              <2> 
   254                              <2> os_dump_registers equ 32909
   255                              <2> 
   256                              <2> ; ------------------------------------------------------------------
   257                              <2> ; os_input_dialog -- Get text string from user via a dialog box
   258                              <2> ; IN: ES:AX = string location, DS:BX = message to show
   259                              <2> ; OUT: None, registers preserved
   260                              <2> 
   261                              <2> os_input_dialog equ 32933
   262                              <2> 
   263                              <2> ; ------------------------------------------------------------------
   264                              <2> ; os_password_dialog -- Get a password from user via a dialog box
   265                              <2> ; IN: ES:AX = string location, DS:BX = message to show
   266                              <2> ; OUT: None, registers preserved
   267                              <2> 
   268                              <2> os_password_dialog equ 33041
   269                              <2> 
   270                              <2> ; ------------------------------------------------------------------
   271                              <2> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
   272                              <2> ; IN: DS:AX, DS:BX, DS:CX = string locations (set registers to 0 for no display),
   273                              <2> ; IN: DX = 0 for single 'OK' dialog,
   274                              <2> ;          1 for two-button 'OK' and 'Cancel' ('OK' selected by default),
   275                              <2> ;          2 for two-button 'OK' and 'Cancel' ('Cancel' selected by default)
   276                              <2> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   277                              <2> ; NOTE: Each string is limited to 40 characters
   278                              <2> 
   279                              <2> os_dialog_box equ 32825
   280                              <2> 
   281                              <2> ; ------------------------------------------------------------------
   282                              <2> ; os_print_space -- Print a space to the screen
   283                              <2> ; IN/OUT: None, registers preserved
   284                              <2> 
   285                              <2> os_print_space equ 32873
   286                              <2> 
   287                              <2> ; ------------------------------------------------------------------
   288                              <2> ; os_print_digit -- Displays contents of AX as a single digit
   289                              <2> ; Works up to base 37, ie digits 0-Z
   290                              <2> ; IN: AX = "digit" to format and print
   291                              <2> ; OUT: None, registers preserved
   292                              <2> 
   293                              <2> os_print_digit equ 32879
   294                              <2> 
   295                              <2> ; ------------------------------------------------------------------
   296                              <2> ; os_print_1hex -- Displays low nibble of AL in hex format
   297                              <2> ; IN: AL = number to format and print
   298                              <2> ; OUT: None, registers preserved
   299                              <2> 
   300                              <2> os_print_1hex equ 32882
   301                              <2> 
   302                              <2> ; ------------------------------------------------------------------
   303                              <2> ; os_print_2hex -- Displays AL in hex format
   304                              <2> ; IN: AL = number to format and print
   305                              <2> ; OUT: None, registers preserved
   306                              <2> 
   307                              <2> os_print_2hex equ 32885
   308                              <2> 
   309                              <2> ; ------------------------------------------------------------------
   310                              <2> ; os_print_4hex -- Displays AX in hex format
   311                              <2> ; IN: AX = number to format and print
   312                              <2> ; OUT: None, registers preserved
   313                              <2> 
   314                              <2> os_print_4hex equ 32888
   315                              <2> 
   316                              <2> ; ------------------------------------------------------------------
   317                              <2> ; os_print_8hex - Displays EAX in hex format
   318                              <2> ; IN: EAX = unsigned integer
   319                              <2> ; OUT: None, registers preserved
   320                              <2> 
   321                              <2> os_print_8hex equ 33065
   322                              <2> 
   323                              <2> ; ------------------------------------------------------------------
   324                              <2> ; os_print_int -- Prints an integer in decimal.
   325                              <2> ; IN: AX = unsigned integer
   326                              <2> ; OUT: None, registers preserved
   327                              <2> 
   328                              <2> os_print_int equ 33101
   329                              <2> 
   330                              <2> ; ------------------------------------------------------------------
   331                              <2> ; os_print_32int -- Prints a 32 bit integer in decimal.
   332                              <2> ; IN: EAX = unsigned integer
   333                              <2> ; OUT: None, registers preserved
   334                              <2> 
   335                              <2> os_print_32int equ 32951
   336                              <2> 
   337                              <2> ; ------------------------------------------------------------------
   338                              <2> ; os_input_string -- Take string from keyboard entry
   339                              <2> ; IN: ES:AX = location of string
   340                              <2> ; OUT: None, registers preserved
   341                              <2> 
   342                              <2> os_input_string equ 32819
   343                              <2> 
   344                              <2> ; ------------------------------------------------------------------
   345                              <2> ; os_input_password -- Take password from keyboard entry
   346                              <2> ; IN: ES:AX = location of string
   347                              <2> ; OUT: None, registers preserved
   348                              <2> 
   349                              <2> os_input_password equ 33077
   350                              <2> 
   351                              <2> ; ------------------------------------------------------------------
   352                              <2> ; os_set_max_input_length -- Set the maximum length for the next string input
   353                              <2> ; IN: AL = maximum number of characters
   354                              <2> ; OUT: None, registers preserved
   355                              <2> 
   356                              <2> os_set_max_input_length equ 33131
   357                              <2> 
   358                              <2> ; ------------------------------------------------------------------
   359                              <2> ; os_input_string_ex -- Take string from keyboard entry
   360                              <2> ; IN: ES:AX = location of string, CH = 0 if normal input, 1 if password input,
   361                              <2> ;     DS:SI = callback on keys where AL = 0 (input: AX = keypress)
   362                              <2> ; OUT: None, registers preserved
   363                              <2> 
   364                              <2> os_input_string_ex equ 33119
   365                              <2> 
   366                              <2> ; ------------------------------------------------------------------
   367                              <2> ; os_color_selector - Pops up a color selector.
   368                              <2> ; IN: None
   369                              <2> ; OUT: color number (0-15)
   370                              <2> 
   371                              <2> os_color_selector equ 33053
   372                              <2> 
   373                              <2> ; ------------------------------------------------------------------
   374                              <2> ; os_temp_box -- Draws a dialog box with up to 5 lines of text.
   375                              <2> ; IN: DS:SI/AX/BX/CX/DX = string locations (or 0 for no display)
   376                              <2> ; OUT: None, registers preserved
   377                              <2> 
   378                              <2> os_temp_box equ 33086
   379                              <2> 
   380                              <2> ; ------------------------------------------------------------------
   381                              <2> ; os_reset_font -- Resets the font to the selected default.
   382                              <2> ; IN/OUT = None, registers preserved
   383                              <2> 
   384                              <2> os_reset_font equ 32990
   385                              <2> 
   386                              <2> ; ------------------------------------------------------------------
   387                              <2> ; os_draw_logo -- Draws the MichalOS logo.
   388                              <2> ; IN: None
   389                              <2> ; OUT: A very beautiful logo :-)
   390                              <2> 
   391                              <2> os_draw_logo equ 32852
   392                              <2> 
   393                              <2> ; ------------------------------------------------------------------
   394                              <2> ; os_draw_icon -- Draws an icon (in the MichalOS format).
   395                              <2> ; IN: DS:SI = address of the icon
   396                              <2> ; OUT: None, registers preserved
   397                              <2> 
   398                              <2> os_draw_icon equ 33023
   399                              <2> 
   400                              <2> ; ------------------------------------------------------------------
   401                              <2> ; os_option_menu -- Show a menu with a list of options
   402                              <2> ; IN: AX = comma-separated list of strings to show (zero-terminated)
   403                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
   404                              <2> 
   405                              <2> os_option_menu equ 32876
   406                              <2> 
   407                              <2> ; ==================================================================
   408                              <2> ; MichalOS Graphics functions
   409                              <2> ; Some graphics routines have been borrowed from TachyonOS
   410                              <2> ; ==================================================================
   411                              <2> 
   412                              <2> ; ------------------------------------------------------------------
   413                              <2> ; os_init_graphics_mode -- Initializes graphics mode.
   414                              <2> ; IN/OUT: None, registers preserved
   415                              <2> 
   416                              <2> os_init_graphics_mode equ 33020
   417                              <2> 
   418                              <2> ; ------------------------------------------------------------------
   419                              <2> ; os_init_text_mode -- Deinitializes graphics mode.
   420                              <2> ; IN/OUT: None, registers preserved
   421                              <2> 
   422                              <2> os_init_text_mode equ 33095
   423                              <2> 
   424                              <2> ; ------------------------------------------------------------------
   425                              <2> ; os_set_pixel -- Sets a pixel on the screen to a given value.
   426                              <2> ; IN: ES = destination memory segment, CX = X coordinate, AX = Y coordinate, BL = color
   427                              <2> ; OUT: None, registers preserved
   428                              <2> 
   429                              <2> os_set_pixel equ 33017
   430                              <2> 
   431                              <2> ; ------------------------------------------------------------------
   432                              <2> ; os_draw_line -- Draws a line with the Bresenham's line algorithm.
   433                              <2> ; Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
   434                              <2> ; IN: ES = destination memory segment, CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
   435                              <2> ; OUT: None, registers preserved
   436                              <2> 
   437                              <2> os_draw_line equ 32999
   438                              <2> 
   439                              <2> ; ------------------------------------------------------------------
   440                              <2> ; os_draw_rectangle -- Draws a rectangle.
   441                              <2> ; IN: ES = destination memory segment, CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
   442                              <2> ; OUT: None, registers preserved
   443                              <2> 
   444                              <2> os_draw_rectangle equ 33047
   445                              <2> 
   446                              <2> ; ------------------------------------------------------------------
   447                              <2> ; os_draw_polygon -- Draws a freeform shape.
   448                              <2> ; IN: ES = destination memory segment, BH = number of points, BL = colour, SI = location of shape points data
   449                              <2> ; OUT: None, registers preserved
   450                              <2> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
   451                              <2> 
   452                              <2> os_draw_polygon equ 33002
   453                              <2> 
   454                              <2> ; ------------------------------------------------------------------
   455                              <2> ; os_clear_graphics -- Clears the graphics screen with a given color.
   456                              <2> ; IN: ES = destination memory segment, BL = colour to set
   457                              <2> ; OUT: None, registers preserved
   458                              <2> 
   459                              <2> os_clear_graphics equ 33008
   460                              <2> 
   461                              <2> ; ----------------------------------------
   462                              <2> ; os_draw_circle -- draw a circular shape
   463                              <2> ; IN: ES = destination memory segment, AL = colour, BX = radius, CX = middle X, DX = middle y
   464                              <2> ; OUT: None, registers preserved
   465                              <2> 
   466                              <2> os_draw_circle equ 33005
   467                              <2> 
   468                              <2> ; ==================================================================
   469                              <2> ; MichalOS Keyboard input handling functions
   470                              <2> ; ==================================================================
   471                              <2> 
   472                              <2> ; ------------------------------------------------------------------
   473                              <2> ; os_wait_for_key -- Waits for keypress and returns key
   474                              <2> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
   475                              <2> ; IN: None
   476                              <2> ; OUT: AX = key pressed, other regs preserved
   477                              <2> 
   478                              <2> os_wait_for_key equ 32786
   479                              <2> 
   480                              <2> ; ------------------------------------------------------------------
   481                              <2> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   482                              <2> ; Also handles special keyboard shortcuts.
   483                              <2> ; IN: None
   484                              <2> ; OUT: AX = 0 if no key pressed, otherwise scan code
   485                              <2> 
   486                              <2> os_check_for_key equ 32789
   487                              <2> 
   488                              <2> ; ==================================================================
   489                              <2> ; MichalOS Port I/O functions
   490                              <2> ; ==================================================================
   491                              <2> 
   492                              <2> ; ------------------------------------------------------------------
   493                              <2> ; os_serial_port_enable -- Set up the serial port for transmitting data
   494                              <2> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
   495                              <2> ; OUT: None, registers preserved
   496                              <2> 
   497                              <2> os_serial_port_enable equ 32954
   498                              <2> 
   499                              <2> ; ------------------------------------------------------------------
   500                              <2> ; os_send_via_serial -- Send a byte via the serial port
   501                              <2> ; IN: AL = byte to send via serial
   502                              <2> ; OUT: AH = Bit 7 clear on success
   503                              <2> 
   504                              <2> os_send_via_serial equ 32861
   505                              <2> 
   506                              <2> ; ------------------------------------------------------------------
   507                              <2> ; os_get_via_serial -- Get a byte from the serial port
   508                              <2> ; IN: None
   509                              <2> ; OUT: AL = byte that was received, AH = Bit 7 clear on success
   510                              <2> 
   511                              <2> os_get_via_serial equ 32864
   512                              <2> 
   513                              <2> ; ==================================================================
   514                              <2> ; MichalOS Disk access functions
   515                              <2> ; ==================================================================
   516                              <2> 
   517                              <2> ; ------------------------------------------------------------------
   518                              <2> ; os_report_free_space -- Returns the amount of free space on disk
   519                              <2> ; IN: None
   520                              <2> ; OUT: AX = Number of sectors free
   521                              <2> 
   522                              <2> os_report_free_space equ 32894
   523                              <2> 
   524                              <2> ; ------------------------------------------------------------------
   525                              <2> ; os_get_file_list -- Generate comma-separated string of files on floppy
   526                              <2> ; IN/OUT: AX = location to store zero-terminated filename string
   527                              <2> 
   528                              <2> os_get_file_list equ 32831
   529                              <2> 
   530                              <2> ; ------------------------------------------------------------------
   531                              <2> ; os_load_file -- Load a file into RAM
   532                              <2> ; IN: AX = location of filename, ES:CX = location in RAM to load file
   533                              <2> ; OUT: BX = file size (in bytes), carry set if file not found
   534                              <2> 
   535                              <2> os_load_file equ 32801
   536                              <2> 
   537                              <2> ; --------------------------------------------------------------------------
   538                              <2> ; os_write_file -- Save (max 64K) file to disk
   539                              <2> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
   540                              <2> ; OUT: Carry clear if OK, set if failure
   541                              <2> 
   542                              <2> os_write_file equ 32915
   543                              <2> 
   544                              <2> ; --------------------------------------------------------------------------
   545                              <2> ; os_file_exists -- Check for presence of file on the floppy
   546                              <2> ; IN: AX = filename location; OUT: carry clear if found, set if not
   547                              <2> 
   548                              <2> os_file_exists equ 32918
   549                              <2> 
   550                              <2> ; --------------------------------------------------------------------------
   551                              <2> ; os_create_file -- Creates a new 0-byte file on the floppy disk
   552                              <2> ; IN: AX = location of filename
   553                              <2> ; OUT: None, registers preserved
   554                              <2> 
   555                              <2> os_create_file equ 32921
   556                              <2> 
   557                              <2> ; --------------------------------------------------------------------------
   558                              <2> ; os_remove_file -- Deletes the specified file from the filesystem
   559                              <2> ; IN: AX = location of filename to remove
   560                              <2> 
   561                              <2> os_remove_file equ 32924
   562                              <2> 
   563                              <2> ; --------------------------------------------------------------------------
   564                              <2> ; os_rename_file -- Change the name of a file on the disk
   565                              <2> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
   566                              <2> ; OUT: carry set on error
   567                              <2> 
   568                              <2> os_rename_file equ 32927
   569                              <2> 
   570                              <2> ; --------------------------------------------------------------------------
   571                              <2> ; os_get_file_size -- Get file size information for specified file
   572                              <2> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
   573                              <2> ; or carry set if file not found
   574                              <2> 
   575                              <2> os_get_file_size equ 32930
   576                              <2> 
   577                              <2> ; --------------------------------------------------------------------------
   578                              <2> ; os_get_file_datetime -- Get file write time/date information for specified file
   579                              <2> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
   580                              <2> ; or carry set if file not found
   581                              <2> 
   582                              <2> os_get_file_datetime equ 33011
   583                              <2> 
   584                              <2> ; --------------------------------------------------------------------------
   585                              <2> ; os_get_boot_disk -- Returns the boot disk number.
   586                              <2> ; IN: None
   587                              <2> ; OUT: DL = boot disk number for use in INT 13h calls
   588                              <2> 
   589                              <2> os_get_boot_disk equ 33062
   590                              <2> 
   591                              <2> ; ==================================================================
   592                              <2> ; MichalOS Miscellaneous functions
   593                              <2> ; ==================================================================
   594                              <2> 
   595                              <2> ; ------------------------------------------------------------------
   596                              <2> ; os_read_config_byte -- Reads a byte from the config
   597                              <2> ; IN: BX = offset
   598                              <2> ; OUT: AL = value
   599                              <2> 
   600                              <2> os_read_config_byte equ 33134
   601                              <2> 
   602                              <2> ; ------------------------------------------------------------------
   603                              <2> ; os_read_config_word -- Reads a word from the config
   604                              <2> ; IN: BX = offset
   605                              <2> ; OUT: AX = value
   606                              <2> 
   607                              <2> os_read_config_word equ 33137
   608                              <2> 
   609                              <2> ; ------------------------------------------------------------------
   610                              <2> ; os_write_config_byte -- Writes a byte to the config
   611                              <2> ; NOTE: This will only affect the config in memory,
   612                              <2> ; run os_save_config to save the changes to disk!
   613                              <2> ; IN: BX = offset, AL = value
   614                              <2> ; OUT: None, registers preserved
   615                              <2> 
   616                              <2> os_write_config_byte equ 33140
   617                              <2> 
   618                              <2> ; ------------------------------------------------------------------
   619                              <2> ; os_write_config_word -- Writes a byte to the config
   620                              <2> ; NOTE: This will only affect the config in memory,
   621                              <2> ; run os_save_config to save the changes to disk!
   622                              <2> ; IN: BX = offset, AX = value
   623                              <2> ; OUT: None, registers preserved
   624                              <2> 
   625                              <2> os_write_config_word equ 33143
   626                              <2> 
   627                              <2> ; ------------------------------------------------------------------
   628                              <2> ; os_save_config -- Saves the current config to disk
   629                              <2> ; OUT: Carry set if error
   630                              <2> 
   631                              <2> os_save_config equ 33146
   632                              <2> 
   633                              <2> ; ------------------------------------------------------------------
   634                              <2> ; os_exit -- Exits the application, launches another one (if possible)
   635                              <2> ; IN: AX = if not 0, then ptr to filename of application to be launched,
   636                              <2> ;     BX = 1 if the application calling os_exit should be re-launched after
   637                              <2> ;     the requested application exits
   638                              <2> ; OUT: None, register preserved
   639                              <2> 
   640                              <2> os_exit equ 32780
   641                              <2> 
   642                              <2> ; ------------------------------------------------------------------
   643                              <2> ; os_clear_registers -- Clear all registers
   644                              <2> ; IN: None
   645                              <2> ; OUT: Cleared registers
   646                              <2> 
   647                              <2> os_clear_registers equ 32975
   648                              <2> 
   649                              <2> ; ------------------------------------------------------------------
   650                              <2> ; os_get_os_name -- Get the OS name string
   651                              <2> ; IN: None
   652                              <2> ; OUT: DS:SI = OS name string, zero-terminated
   653                              <2> 
   654                              <2> os_get_os_name equ 33083
   655                              <2> 
   656                              <2> ; ------------------------------------------------------------------
   657                              <2> ; os_get_memory -- Gets the amount of system RAM.
   658                              <2> ; IN: None
   659                              <2> ; OUT: AX = conventional memory (in kB), BX = high memory (in kB)
   660                              <2> 
   661                              <2> os_get_memory equ 33050
   662                              <2> 
   663                              <2> ; ------------------------------------------------------------------
   664                              <2> ; os_int_1Ah -- Middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
   665                              <2> ; IN/OUT: same as int 1Ah
   666                              <2> 
   667                              <2> os_int_1Ah equ 33032
   668                              <2> 
   669                              <2> ; ==================================================================
   670                              <2> ; MichalOS/MikeOS 4.5 BASIC interpreter
   671                              <2> ; ==================================================================
   672                              <2> 
   673                              <2> ; ------------------------------------------------------------------
   674                              <2> ; The BASIC interpreter execution starts here -- a parameter string
   675                              <2> ; is passed in SI and copied into the first string, unless SI = 0
   676                              <2> 
   677                              <2> os_run_basic equ 32963
   678                              <2> 
   679                              <2> ; ==================================================================
   680                              <2> ; MichalOS Math functions
   681                              <2> ; ==================================================================
   682                              <2> 
   683                              <2> ; ------------------------------------------------------------------
   684                              <2> ; os_get_random -- Return a random integer between low and high (inclusive)
   685                              <2> ; IN: AX = low integer, BX = high integer
   686                              <2> ; OUT: CX = random integer
   687                              <2> 
   688                              <2> os_get_random equ 32948
   689                              <2> 
   690                              <2> ; ------------------------------------------------------------------
   691                              <2> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
   692                              <2> ; IN: AL = BCD number
   693                              <2> ; OUT: AX = integer value
   694                              <2> 
   695                              <2> os_bcd_to_int equ 32846
   696                              <2> 
   697                              <2> ; ------------------------------------------------------------------
   698                              <2> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
   699                              <2> ; IN: AL = integer value
   700                              <2> ; OUT: AL = BCD number
   701                              <2> 
   702                              <2> os_int_to_bcd equ 33035
   703                              <2> 
   704                              <2> ; ------------------------------------------------------------------
   705                              <2> ; os_math_power -- Calculates EAX^EBX.
   706                              <2> ; IN: EAX^EBX = input
   707                              <2> ; OUT: EAX = result
   708                              <2> 
   709                              <2> os_math_power equ 33071
   710                              <2> 
   711                              <2> ; ------------------------------------------------------------------
   712                              <2> ; os_math_root -- Approximates the EBXth root of EAX.
   713                              <2> ; IN: EAX = input, EBX = root
   714                              <2> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   715                              <2> 
   716                              <2> os_math_root equ 33074
   717                              <2> 
   718                              <2> ; ==================================================================
   719                              <2> ; MichalOS String manipulation functions
   720                              <2> ; ==================================================================
   721                              <2> 
   722                              <2> ; ------------------------------------------------------------------
   723                              <2> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
   724                              <2> ; IN: DS:SI = Input string/Output string
   725                              <2> ; OUT: None, registers preserved
   726                              <2> 
   727                              <2> os_string_encrypt equ 33014
   728                              <2> 
   729                              <2> ; ------------------------------------------------------------------
   730                              <2> ; os_string_add -- Add a string on top of another string
   731                              <2> ; IN: DS:AX = Main string, DS:BX = Added string
   732                              <2> ; OUT: None, registers preserved
   733                              <2> 
   734                              <2> os_string_add equ 32897
   735                              <2> 
   736                              <2> ; ------------------------------------------------------------------
   737                              <2> ; os_string_length -- Return length of a string
   738                              <2> ; IN: DS:AX = string location
   739                              <2> ; OUT AX = length (other regs preserved)
   740                              <2> 
   741                              <2> os_string_length equ 32810
   742                              <2> 
   743                              <2> ; ------------------------------------------------------------------
   744                              <2> ; os_string_reverse -- Reverse the characters in a string
   745                              <2> ; IN: DS:SI = string location
   746                              <2> ; OUT: None, registers preserved
   747                              <2> 
   748                              <2> os_string_reverse equ 32939
   749                              <2> 
   750                              <2> ; ------------------------------------------------------------------
   751                              <2> ; os_find_char_in_string -- Find location of character in a string
   752                              <2> ; IN: DS:SI = string location, AL = character to find
   753                              <2> ; OUT: AX = location in string, or 0 if char not present
   754                              <2> 
   755                              <2> os_find_char_in_string equ 32867
   756                              <2> 
   757                              <2> ; ------------------------------------------------------------------
   758                              <2> ; os_string_uppercase -- Convert zero-terminated string to upper case
   759                              <2> ; IN: DS:AX = string location
   760                              <2> ; OUT: None, registers preserved
   761                              <2> 
   762                              <2> os_string_uppercase equ 32813
   763                              <2> 
   764                              <2> ; ------------------------------------------------------------------
   765                              <2> ; os_string_lowercase -- Convert zero-terminated string to lower case
   766                              <2> ; IN: DS:AX = string location
   767                              <2> ; OUT: None, registers preserved
   768                              <2> 
   769                              <2> os_string_lowercase equ 32816
   770                              <2> 
   771                              <2> ; ------------------------------------------------------------------
   772                              <2> ; os_string_copy -- Copy one string into another
   773                              <2> ; IN: DS:SI = source, ES:DI = destination (programmer ensure sufficient room)
   774                              <2> ; OUT: None, registers preserved
   775                              <2> 
   776                              <2> os_string_copy equ 32822
   777                              <2> 
   778                              <2> ; ------------------------------------------------------------------
   779                              <2> ; os_string_join -- Join two strings into a third string
   780                              <2> ; IN: DS:AX = string one, DS:BX = string two, ES:CX = destination string
   781                              <2> ; OUT: None, registers preserved
   782                              <2> 
   783                              <2> os_string_join equ 32828
   784                              <2> 
   785                              <2> ; ------------------------------------------------------------------
   786                              <2> ; os_string_chomp -- Strip leading and trailing spaces from a string
   787                              <2> ; IN: DS:AX = string location
   788                              <2> ; OUT: None, registers preserved
   789                              <2> 
   790                              <2> os_string_chomp equ 32837
   791                              <2> 
   792                              <2> ; ------------------------------------------------------------------
   793                              <2> ; os_string_compare -- See if two strings match
   794                              <2> ; IN: DS:SI = string one, DS:DI = string two
   795                              <2> ; OUT: carry set if same, clear if different
   796                              <2> 
   797                              <2> os_string_compare equ 32834
   798                              <2> 
   799                              <2> ; ------------------------------------------------------------------
   800                              <2> ; os_string_parse -- Take string (eg "run foo bar baz") and return
   801                              <2> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
   802                              <2> ; IN: DS:SI = string
   803                              <2> ; OUT: AX, BX, CX, DX = individual strings
   804                              <2> 
   805                              <2> os_string_parse equ 32960
   806                              <2> 
   807                              <2> ; ------------------------------------------------------------------
   808                              <2> ; os_string_to_int -- Convert decimal string to integer value
   809                              <2> ; IN: DS:SI = string location (max 5 chars, up to '65535')
   810                              <2> ; OUT: AX = number
   811                              <2> 
   812                              <2> os_string_to_int equ 32942
   813                              <2> 
   814                              <2> ; ------------------------------------------------------------------
   815                              <2> ; os_string_to_hex -- Convert hexadecimal string to integer value
   816                              <2> ; IN: DS:SI = string location (max 8 chars, up to 'FFFFFFFF')
   817                              <2> ; OUT: EAX = number
   818                              <2> 
   819                              <2> os_string_to_hex equ 32840
   820                              <2> 
   821                              <2> ; ------------------------------------------------------------------
   822                              <2> ; os_int_to_string -- Convert unsigned integer to string
   823                              <2> ; IN: AX = unsigned int
   824                              <2> ; OUT: DS:AX = string location
   825                              <2> 
   826                              <2> os_int_to_string equ 32792
   827                              <2> 
   828                              <2> ; ------------------------------------------------------------------
   829                              <2> ; os_sint_to_string -- Convert signed integer to string
   830                              <2> ; IN: AX = signed int
   831                              <2> ; OUT: DS:AX = string location
   832                              <2> 
   833                              <2> os_sint_to_string equ 32957
   834                              <2> 
   835                              <2> ; ------------------------------------------------------------------
   836                              <2> ; os_get_time_string -- Get current time in a string (eg '10:25')
   837                              <2> ; IN: ES:BX = string location
   838                              <2> ; OUT: None, registers preserved
   839                              <2> 
   840                              <2> os_get_time_string equ 32849
   841                              <2> 
   842                              <2> ; ------------------------------------------------------------------
   843                              <2> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
   844                              <2> ; IN: ES:BX = string location
   845                              <2> ; OUT: None, registers preserved
   846                              <2> 
   847                              <2> os_get_date_string equ 32858
   848                              <2> 
   849                              <2> ; ------------------------------------------------------------------
   850                              <2> ; os_string_tokenize -- Reads tokens separated by specified char from
   851                              <2> ; a string. Returns pointer to next token, or 0 if none left
   852                              <2> ; IN: AL = separator char, DS:SI = beginning
   853                              <2> ; OUT: DI = next token or 0 if none
   854                              <2> 
   855                              <2> os_string_tokenize equ 32972
   856                              <2> 
   857                              <2> ; ------------------------------------------------------------------
   858                              <2> ; os_string_callback_tokenizer -- Prints a token from string, requests are done by callback
   859                              <2> ; IN: DS:AX = comma-separated string
   860                              <2> ; OUT: AL = AH = max length of any token, CX = number of entries in the list,
   861                              <2> ;      DX:SI = callback location (if C clear, accepts CX as entry ID, prints out result)
   862                              <2> 
   863                              <2> os_string_callback_tokenizer equ 33128
   864                              <2> 
   865                              <2> ; ------------------------------------------------------------------
   866                              <2> ; os_32int_to_string -- Converts an unsigned 32-bit integer into a string
   867                              <2> ; IN: EAX = unsigned int
   868                              <2> ; OUT: DS:AX = string location
   869                              <2> 
   870                              <2> os_32int_to_string equ 33059
   871                              <2> 
   872                              <2> ; ------------------------------------------------------------------
   873                              <2> ; os_string_to_32int -- Converts a string into a 32-bit integer
   874                              <2> ; IN: DS:SI = string location
   875                              <2> ; OUT: EAX = unsigned integer
   876                              <2> 
   877                              <2> os_string_to_32int equ 33068
   878                              <2> 
   879                              <2> ; ==================================================================
   880                              <2> ; MichalOS ZX7 decompression routine
   881                              <2> ; ==================================================================
   882                              <2> 
   883                              <2> ; ------------------------------------------------------------------
   884                              <2> ; os_decompress_zx7 -- Decompresses ZX7-packed data.
   885                              <2> ; IN: DS:SI = source, ES:DI = destination
   886                              <2> ; OUT: None, registers preserved
   887                              <2> 
   888                              <2> os_decompress_zx7 equ 33038
   889                              <2> 
   890                              <2> ; ==================================================================
   891                              <2> ; MichalOS Interrupt management & app timer functions
   892                              <2> ; ==================================================================
   893                              <2> 
   894                              <2> ; -----------------------------------------------------------------
   895                              <2> ; os_modify_int_handler -- Change location of interrupt handler
   896                              <2> ; IN: CL = int number, DI:SI = handler location
   897                              <2> ; OUT: None, registers preserved
   898                              <2> 
   899                              <2> os_modify_int_handler equ 33056
   900                              <2> 
   901                              <2> ; -----------------------------------------------------------------
   902                              <2> ; os_get_int_handler -- Change location of interrupt handler
   903                              <2> ; IN: CL = int number
   904                              <2> ; OUT: DI:SI = handler location
   905                              <2> 
   906                              <2> os_get_int_handler equ 33080
   907                              <2> 
   908                              <2> ; ------------------------------------------------------------------
   909                              <2> ; os_pause -- Delay execution for a specified number of ticks (18.2 Hz by default)
   910                              <2> ; IN: AX = amount of ticks to wait
   911                              <2> ; OUT: None, registers preserved
   912                              <2> 
   913                              <2> os_pause equ 32804
   914                              <2> 
   915                              <2> ; -----------------------------------------------------------------
   916                              <2> ; os_attach_app_timer -- Attach a timer interrupt to an application and sets the timer speed
   917                              <2> ; Formula: speed = (105000000 / 88) / frequency
   918                              <2> ; IN: DS:SI = handler location, CX = speed
   919                              <2> ; OUT: None, registers preserved
   920                              <2> 
   921                              <2> os_attach_app_timer equ 32969
   922                              <2> 
   923                              <2> ; -----------------------------------------------------------------
   924                              <2> ; os_return_app_timer -- Returns the timer interrupt back to the system and resets the timer speed
   925                              <2> ; IN/OUT: None, registers preserved
   926                              <2> 
   927                              <2> os_return_app_timer equ 32987
   928                              <2> 
   929                              <2> ; -----------------------------------------------------------------
   930                              <2> ; os_set_timer_speed -- Sets the timer's trigger speed.
   931                              <2> ; Formula: speed = (105000000 / 88) / frequency
   932                              <2> ; IN: CX = speed
   933                              <2> ; OUT: Nothing, registers preserved
   934                              <2> 
   935                              <2> os_set_timer_speed equ 32891
   936                              <2> 
   937                              <2> ; ==================================================================
   938                              <2> ; MichalOS Low-level disk driver
   939                              <2> ; ==================================================================
   940                              <2> 
   941                              <2> ; --------------------------------------------------------------------------
   942                              <2> ; os_disk_read_sector -- Read a single sector from disk
   943                              <2> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   944                              <2> 
   945                              <2> os_disk_read_sector equ 33092
   946                              <2> 
   947                              <2> ; --------------------------------------------------------------------------
   948                              <2> ; os_disk_read_multiple_sectors -- Read multiple sectors from disk
   949                              <2> ; IN: EAX = sector ID, CX = number of sectors, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   950                              <2> 
   951                              <2> os_disk_read_multiple_sectors equ 33104
   952                              <2> 
   953                              <2> ; --------------------------------------------------------------------------
   954                              <2> ; os_disk_write_sector -- Write a single sector to disk
   955                              <2> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   956                              <2> 
   957                              <2> os_disk_write_sector equ 33098
   958                              <2> 
   959                              <2> ; --------------------------------------------------------------------------
   960                              <2> ; os_disk_write_multiple_sectors -- Write multiple sectors to disk
   961                              <2> ; IN: EAX = sector ID, CX = number of sectors, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   962                              <2> 
   963                              <2> os_disk_write_multiple_sectors equ 33116
   964                              <2> 
    10                              <1> 
    11                              <1> %macro oscall 1
    12                              <1> 	mov bp, %1
    13                              <1> 	int 40h
    14                              <1> %endmacro
    15                              <1> 
    16                              <1> ; -----------------------------------------------------------------
    39                                      
    40                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    41                                      ; jump over data section
    42                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    43 00000000 E9CD04                      jmp initialization
    44                                  
    45                                      
    46                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    47                                  ;
    48                                  ;
    49                                  ;
    50                                  ; Constants
    51                                  ;
    52                                  ;
    53                                  ;
    54                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                                  
    56                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    57                                      ; strings that will be displayed
    58                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    59 00000003 5772697474656E2062-         msg_author db "Written by Sebastian Mihai, 2014", 0
    59 0000000C 792053656261737469-
    59 00000015 616E204D696861692C-
    59 0000001E 203230313400       
    60 00000024 4E65787400                  msg_next db "Next", 0
    61 00000029 1B202D204C65667400          msg_left db 1Bh, " - Left", 0
    62 00000032 1A202D205269676874-         msg_right db 1Ah, " - Right", 0
    62 0000003B 00                 
    63 0000003C 5A2F58202D20526F74-         msg_rotate db "Z/X - Rotate", 0
    63 00000045 61746500           
    64 00000049 457363202D20517569-         msg_quit db "Esc - Quit", 0
    64 00000052 7400               
    65 00000054 4C696E657300                msg_lines db "Lines", 0
    66 0000005A 47616D65204F766572-         msg_game_over db "Game Over", 0
    66 00000063 00                 
    67 00000064 61534D7472697300            msg_asmtris db "aSMtris", 0
    68 0000006C 4D6F64696669656420-         msg_author2 db "Modified by Michal Prochazka, 2019", 0
    68 00000075 6279204D696368616C-
    68 0000007E 2050726F6368617A6B-
    68 00000087 612C203230313900   
    69 0000008F 19202D2046616C6C00      	msg_fall db 19h, " - Fall", 0
    70 00000098 52202D205265737461-         msg_reset db "R - Restart", 0
    70 000000A1 727400             
    71                                      
    72 000000A4 4001                        screen_width dw 320
    73                                      
    74 000000A6 0500                        block_size dw 5 ; block size in pixels
    75 000000A8 0400                        blocks_per_piece dw 4 ; number of blocks in a piece
    76                                  
    77                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    78                                      ; music data
    79                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    80 000000AA 9302930293029302EE-        	track00 dw		E5,	E5,	E5,	E5,	B4,	B4,	C5,	C5,	D5,	D5,	E5,	D5,	C5,	C5,	B4,	B4
    80 000000B3 01EE010B020B024B02-
    80 000000BC 4B0293024B020B020B-
    80 000000C5 02EE01EE01         
    81 000000CA B801B801B8010000B8-     	track01 dw		A4,	A4,	A4,	0,	A4,	A4,	C5,	C5,	E5,	E5,	E5,	E5,	D5,	D5,	C5,	C5
    81 000000D3 01B8010B020B029302-
    81 000000DC 9302930293024B024B-
    81 000000E5 020B020B02         
    82 000000EA EE01EE01EE01EE01EE-     	track02 dw		B4,	B4,	B4,	B4,	B4,	B4,	C5,	C5,	D5,	D5,	D5,	D5,	E5,	E5,	E5,	E5
    82 000000F3 01EE010B020B024B02-
    82 000000FC 4B024B024B02930293-
    82 00000105 0293029302         
    83 0000010A 0B020B020B020B02B8-     	track03 dw		C5,	C5,	C5,	C5,	A4,	A4,	A4,	0,	A4,	A4,	A4,	0,	0,	0,	0,	0
    83 00000113 01B801B8010000B801-
    83 0000011C B801B8010000000000-
    83 00000125 0000000000         
    84 0000012A 000000004B024B024B-     	track04 dw		0,	0,	D5, D5, D5, D5, F5, F5, A5, 0,	A5, A5, G5, G5, F5, F5
    84 00000133 024B02BA02BA027003-
    84 0000013C 000070037003100310-
    84 00000145 03BA02BA02         
    85 0000014A 930293029302930293-     	track05 dw		E5, E5, E5, E5, E5, E5, C5, C5, E5, E5, E5, E5, D5, D5, C5, C5
    85 00000153 0293020B020B029302-
    85 0000015C 9302930293024B024B-
    85 00000165 020B020B02         
    86 0000016A EE01EE01EE010000EE-     	track06 dw		B4, B4, B4, 0,	B4, B4, C5, C5, D5, D5, D5, D5, E5, E5, E5, E5
    86 00000173 01EE010B020B024B02-
    86 0000017C 4B024B024B02930293-
    86 00000185 0293029302         
    87 0000018A 0B020B020B020B02B8-     	track07 dw		C5, C5, C5, C5, A4, A4, A4, 0,	A4, A4, A4, A4, 0,	0,	0,	0
    87 00000193 01B801B8010000B801-
    87 0000019C B801B801B801000000-
    87 000001A5 0000000000         
    88 000001AA 9302930293029302EE-     	track08 dw		E5,	E5,	E5,	E5,	B4,	B4,	C5,	C5,	D5,	D5,	E5,	D5,	C5,	C5,	B4,	B4
    88 000001B3 01EE010B020B024B02-
    88 000001BC 4B0293024B020B020B-
    88 000001C5 02EE01EE01         
    89 000001CA B801B801B8010000B8-     	track09 dw		A4,	A4,	A4,	0,	A4,	A4,	C5,	C5,	E5,	E5,	E5,	E5,	D5,	D5,	C5,	C5
    89 000001D3 01B8010B020B029302-
    89 000001DC 9302930293024B024B-
    89 000001E5 020B020B02         
    90 000001EA EE01EE01EE01EE01EE-     	track0A dw		B4,	B4,	B4,	B4,	B4,	B4,	C5,	C5,	D5,	D5,	D5,	D5,	E5,	E5,	E5,	E5
    90 000001F3 01EE010B020B024B02-
    90 000001FC 4B024B024B02930293-
    90 00000205 0293029302         
    91 0000020A 0B020B020B020B02B8-     	track0B dw		C5,	C5,	C5,	C5,	A4,	A4,	A4,	0,	A4,	A4,	A4,	0,	0,	0,	0,	0
    91 00000213 01B801B8010000B801-
    91 0000021C B801B8010000000000-
    91 00000225 0000000000         
    92 0000022A 000000004B024B024B-     	track0C dw		0,	0,	D5, D5, D5, D5, F5, F5, A5, 0,	A5, A5, G5, G5, F5, F5
    92 00000233 024B02BA02BA027003-
    92 0000023C 000070037003100310-
    92 00000245 03BA02BA02         
    93 0000024A 930293029302930293-     	track0D dw		E5, E5, E5, E5, E5, E5, C5, C5, E5, E5, E5, E5, D5, D5, C5, C5
    93 00000253 0293020B020B029302-
    93 0000025C 9302930293024B024B-
    93 00000265 020B020B02         
    94 0000026A EE01EE01EE010000EE-     	track0E dw		B4, B4, B4, 0,	B4, B4, C5, C5, D5, D5, D5, D5, E5, E5, E5, E5
    94 00000273 01EE010B020B024B02-
    94 0000027C 4B024B024B02930293-
    94 00000285 0293029302         
    95 0000028A 0B020B020B020B02B8-     	track0F dw		C5, C5, C5, C5, A4, A4, A4, 0,	A4, A4, A4, A4, 0,	0,	0,	0
    95 00000293 01B801B8010000B801-
    95 0000029C B801B801B801000000-
    95 000002A5 0000000000         
    96 000002AA 930293029302930293-     	track10 dw		E5, E5, E5, E5, E5, E5, E5, E5, C5, C5, C5, C5, C5, C5, C5, C5
    96 000002B3 029302930293020B02-
    96 000002BC 0B020B020B020B020B-
    96 000002C5 020B020B02         
    97 000002CA 4B024B024B024B024B-     	track11 dw		D5, D5, D5, D5, D5, D5, D5, D5, B4, B4, B4, B4, B4, B4, B4, B4
    97 000002D3 024B024B024B02EE01-
    97 000002DC EE01EE01EE01EE01EE-
    97 000002E5 01EE01EE01         
    98 000002EA 0B020B020B020B020B-     	track12 dw		C5, C5, C5, C5, C5, C5, C5, C5, A4, A4, A4, A4, A4, A4, A4, A4
    98 000002F3 020B020B020B02B801-
    98 000002FC B801B801B801B801B8-
    98 00000305 01B801B801         
    99 0000030A 9F019F019F019F019F-     	track13 dw		GS4,GS4,GS4,GS4,GS4,GS4,GS4,GS4,B4, B4, B4, B4, 0,	0,	0,	0
    99 00000313 019F019F019F01EE01-
    99 0000031C EE01EE01EE01000000-
    99 00000325 0000000000         
   100 0000032A 930293029302930293-     	track14 dw		E5, E5, E5, E5, E5, E5, E5, E5, C5, C5, C5, C5, C5, C5, C5, C5
   100 00000333 029302930293020B02-
   100 0000033C 0B020B020B020B020B-
   100 00000345 020B020B02         
   101 0000034A 4B024B024B024B024B-     	track15 dw		D5, D5, D5, D5, D5, D5, D5, D5, B4, B4, B4, B4, B4, B4, B4, B4
   101 00000353 024B024B024B02EE01-
   101 0000035C EE01EE01EE01EE01EE-
   101 00000365 01EE01EE01         
   102 0000036A 0B020B020B020B0293-     	track16 dw		C5, C5, C5, C5, E5, E5, E5, E5, A5, A5, A5, A5, A5, A5, A5, A5
   102 00000373 029302930293027003-
   102 0000037C 700370037003700370-
   102 00000385 0370037003         
   103 0000038A 3F033F033F033F033F-     	track17 dw		GS5,GS5,GS5,GS5,GS5,GS5,GS5,GS5,0,	0,	0,	0,	0,	0,	0,	0
   103 00000393 033F033F033F030000-
   103 0000039C 000000000000000000-
   103 000003A5 0000000000         
   104                                      
   105                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   106                                      ; the reason why pieces change colour is to facilitate collision detection
   107                                      ; since when rotating, each piece is allowed to collide with pixels of the
   108                                      ; same colour as itself, but is not allowed to collide with versions of 
   109                                      ; itself which have already cemented
   110                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   111 000003AA 2800300036000E002A-         colour_cemented_piece dw 40, 48, 54, 14, 42, 36, 34 ; colours for pieces
   111 000003B3 0024002200         
   112                                                                                          ; which have cemented
   113 000003B8 27002F0037002C0006-         colour_falling_piece dw 39, 47, 55, 44, 6, 37, 33 ; colours for pieces
   113 000003C1 0025002100         
   114                                                                                        ; which are falling
   115                                      
   116                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   117                                      ; piece definitions begin here
   118                                      ;
   119                                      ; - piece_definition variable moves between piece_t, piece_j, etc.
   120                                      ; - piece_orientation_index variable moves between 0 and 3, offsetting
   121                                      ;                            within a piece's four possible orientations
   122                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   123                                      pieces_origin:
   124 000003C6 45064A064F068A0C            piece_t dw 1605, 1610, 1615, 3210 ; point down
   125 000003CE 0A004A064F068A0C                     dw 10, 1610, 1615, 3210   ; point right
   126 000003D6 0A0045064A064F06                     dw 10, 1605, 1610, 1615   ; point up
   127 000003DE 0A0045064A068A0C                     dw 10, 1605, 1610, 3210   ; point left
   128 000003E6 45064A064F068F0C            piece_j dw 1605, 1610, 1615, 3215 ; point down
   129 000003EE 0A000F004A068A0C                     dw 10, 15, 1610, 3210     ; point right
   130 000003F6 050045064A064F06                     dw 5, 1605, 1610, 1615    ; point up
   131 000003FE 0A004A06850C8A0C                     dw 10, 1610, 3205, 3210   ; point left
   132 00000406 45064A064F06850C            piece_l dw 1605, 1610, 1615, 3205 ; point down
   133 0000040E 0A004A068A0C8F0C                     dw 10, 1610, 3210, 3215   ; point right
   134 00000416 0F0045064A064F06                     dw 15, 1605, 1610, 1615   ; point up
   135 0000041E 05000A004A068A0C                     dw 5, 10, 1610, 3210      ; point left
   136 00000426 45064A068A0C8F0C            piece_z dw 1605, 1610, 3210, 3215 ; horizontal z
   137 0000042E 0F004A064F068A0C                     dw 15, 1610, 1615, 3210   ; vertical z
   138 00000436 45064A068A0C8F0C                     dw 1605, 1610, 3210, 3215 ; horizontal z
   139 0000043E 0F004A064F068A0C                     dw 15, 1610, 1615, 3210   ; vertical z
   140 00000446 4A064F06850C8A0C            piece_s dw 1610, 1615, 3205, 3210 ; horizontal s
   141 0000044E 0A004A064F068F0C                     dw 10, 1610, 1615, 3215   ; vertical s
   142 00000456 4A064F06850C8A0C                     dw 1610, 1615, 3205, 3210 ; horizontal s
   143 0000045E 0A004A064F068F0C                     dw 10, 1610, 1615, 3215   ; vertical s
   144 00000466 45064A06850C8A0C            piece_square dw 1605, 1610, 3205, 3210 ; a square
   145 0000046E 45064A06850C8A0C                          dw 1605, 1610, 3205, 3210 ; another square
   146 00000476 45064A06850C8A0C                          dw 1605, 1610, 3205, 3210 ; nothing but 
   147 0000047E 45064A06850C8A0C                          dw 1605, 1610, 3205, 3210 ; squares here
   148 00000486 400645064A064F06            piece_line dw 1600, 1605, 1610, 1615 ; horizontal line
   149 0000048E 0A004A068A0CCA12                        dw 10, 1610, 3210, 4810   ; vertical line
   150 00000496 400645064A064F06                        dw 1600, 1605, 1610, 1615 ; horizontal line
   151 0000049E 0A004A068A0CCA12                        dw 10, 1610, 3210, 4810   ; vertical line
   152                                      
   153                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   154                                  ;
   155                                  ;
   156                                  ;
   157                                  ; Variables
   158                                  ;
   159                                  ;
   160                                  ;
   161                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                                  
   163 000004A6 30303000                    msg_score_buffer db "000", 0 ; holds the string representation of score
   164 000004AA 0000                        score dw 0 ; keeps score (representing total number of cleared lines)
   165                                  
   166 000004AC 0000                        music_counter	dw 0
   167                                      
   168 000004AE 0000                        current_frame dw 0 ; our global frame counter
   169                                      
   170 000004B0 00                          piece_speed	db 0
   171 000004B1 00                          skip_num db 0
   172                                      
   173 000004B2 0000                        previous_note dw 0
   174                                      
   175 000004B4 00                          delay_stopping_point_centiseconds db 0 ; convenience variable used by the
   176                                                                             ; delay subroutine
   177 000004B5 00                          delay_initial db 0 ; another convenience variable used by the 
   178                                                         ; delay subroutine
   179                                      
   180 000004B6 00                          random_number db 0 ; incremented by various events 
   181                                                         ; such as input, clock polling, etc.
   182                                                         
   183 000004B7 00                          must_quit db 0 ; flag indicating that the player is quitting the game
   184                                      
   185 000004B8 00                          cement_counter db 0 ; number of frames during which a piece which
   186                                                          ; can no longer fall is allowed to still be
   187                                                          ; controlled by the player
   188                                      
   189 000004B9 00                          player_input_pressed db 0 ; flag indicating the presence of input
   190                                      
   191 000004BA 0000                        current_piece_colour_index dw 0 ; index of current colour in colours array
   192                                      
   193 000004BC 0000                        next_piece_colour_index dw 0 ; used to display next piece
   194 000004BE 0000                        next_piece_orientation_index dw 0 ; used to display next piece
   195                                      
   196 000004C0 0000                        piece_definition dw 0 ; pointer to first of the group 
   197                                                            ; of four piece orientations for this piece
   198                                                            ; (see above for an explanation)
   199 000004C2 0000                        piece_orientation_index dw 0 ; 0 through 3, index of current orientation
   200                                                                   ; among all of the piece's orientations
   201                                                                   ; (see above for an explanation)
   202                                                                   
   203 000004C4 0000000000000000            piece_blocks dw 0, 0, 0, 0  ; stores positions of blocks of current piece 
   204                                      
   205 000004CC 0000                        piece_position dw 0    ; position of the top left corner 
   206                                                          ; of the falling 4 by 4 piece
   207 000004CE 0000                        piece_position_delta dw 0 ; frame-by-frame change in current piece position
   208                                  
   209                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   210                                  ;
   211                                  ;
   212                                  ; Initialization
   213                                  ;
   214                                  ;
   215                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
   216                                  initialization:
   217                                      
   218                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   219                                      ; enter graphics mode 13h, 320x200 pixels 8bit colour
   220                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221 000004D0 E8(FC80)                    call os_init_graphics_mode
   222                                  
   223 000004D3 C606[B104]00                mov byte [skip_num], 0
   224 000004D8 C606[6109]00                mov byte [tmp_skip_num], 0
   225 000004DD C606[B004]00                mov byte [piece_speed], 0
   226 000004E2 C706[AA04]0000              mov word [score], 0
   227                                      
   228                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   229                                      ; generate initial piece
   230                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   231 000004E8 E89901                      call procedure_random_next_piece
   232                                  
   233                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   234                                      ; display controls, play area, borders, etc.
   235                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   236 000004EB E8E204                      call procedure_draw_screen
   237                                  
   238                                  
   239                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                                  ;
   241                                  ;
   242                                  ; Main program
   243                                  ;
   244                                  ;
   245                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
   246                                      
   247                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   248                                  ;
   249                                  ; Generate a new piece and refresh next piece
   250                                  ;
   251                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
   252                                  new_piece:
   253                                  
   254                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   255                                      ; since we're generating a new block, a piece has just cemented, which
   256                                      ; means that there may be updates to the score due to lines potentially 
   257                                      ; being cleared by that last piece
   258                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259 000004EE E85801                      call procedure_display_score
   260                                      
   261                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   262                                      ; start falling from the middle of the top of the play area
   263                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   264 000004F1 C706[CC04]D638              mov word [piece_position], 14550
   265                                      
   266                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                                      ; next piece colour index becomes current
   268                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   269 000004F7 A1[BC04]                    mov ax, [next_piece_colour_index]
   270 000004FA A3[BA04]                    mov word [current_piece_colour_index], ax
   271                                  
   272                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   273                                      ; colours array and pieces array have corresponding entries, so use colours
   274                                      ; index to set the piece index as well, but it has to be offset by as many
   275                                      ; bytes as each piece occupies
   276                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   277 000004FD C1E005                      shl ax, 5 ; ax := ax * 32 ( 16 words for each piece )
   278 00000500 05[C603]                    add ax, pieces_origin ; offset from first piece
   279 00000503 A3[C004]                    mov [piece_definition], ax ; piece_definition now points to the first of 
   280                                                                 ; four piece orientations of a specific piece    
   281                                  
   282                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   283                                      ; next piece becomes current
   284                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   285 00000506 A1[BE04]                    mov ax, [next_piece_orientation_index]
   286 00000509 A3[C204]                    mov word [piece_orientation_index], ax ; choose one of the 
   287                                                                             ; four orientations
   288 0000050C E8F601                      call procedure_copy_piece
   289                                      
   290                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                                      ; can this piece even spawn?
   292                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   293 0000050F E84C02                      call procedure_can_piece_be_placed
   294 00000512 84C0                        test al, al ; did we get a 0, meaning "can move"?
   295 00000514 0F851301                    jnz game_over ; no, can't move down - game is over!
   296                                      
   297                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   298                                      ; since we've just made next piece current, we need to generate a new one
   299                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   300 00000518 E86901                      call procedure_random_next_piece
   301                                      
   302                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   303                                  ;
   304                                  ; Temporarily make next piece current so that it can be displayed in the
   305                                  ; "Next" piece area
   306                                  ;
   307                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   308                                  display_next_piece:
   309                                  
   310                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   311                                      ; erase old next piece by drawing a black 4x4 block piece on top
   312                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   313 0000051B BF8D45                      mov di, 17805
   314 0000051E BB1400                      mov bx, 20
   315                                      clr dl
    31 00000521 30D2                <1>  xor %1, %1
   316 00000523 E83C04                      call procedure_draw_square ; erase old "next" piece
   317                                  
   318                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   319                                      ; save current piece
   320                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   321 00000526 FF36[BA04]                  push word [current_piece_colour_index]
   322 0000052A FF36[C004]                  push word [piece_definition]
   323 0000052E FF36[C204]                  push word [piece_orientation_index]
   324 00000532 FF36[CC04]                  push word [piece_position]
   325                                      
   326                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   327                                      ; make next piece current - colour index
   328                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   329 00000536 A1[BC04]                    mov ax, [next_piece_colour_index]
   330 00000539 A3[BA04]                    mov word [current_piece_colour_index], ax ; save colour index
   331                                      
   332                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   333                                      ; make next piece current - piece definition
   334                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   335 0000053C C1E005                      shl ax, 5 ; ax := ax * 32 ( 16 words for each piece )
   336 0000053F 05[C603]                    add ax, pieces_origin ; offset from first piece
   337 00000542 A3[C004]                    mov [piece_definition], ax ; piece_definition now points to the first of 
   338                                                                 ; four piece orientations of a specific piece    
   339                                  
   340                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   341                                      ; make next piece current -  piece orientation index
   342                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   343 00000545 A1[BE04]                    mov ax, [next_piece_orientation_index]
   344 00000548 A3[C204]                    mov word [piece_orientation_index], ax ; choose one of the 
   345                                                                             ; four orientations
   346 0000054B E8B701                      call procedure_copy_piece
   347                                      
   348                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   349                                      ; temporarily move current piece to the Next display area
   350                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   351 0000054E C706[CC04]8D45              mov word [piece_position], 17805 ; move piece to where next 
   352                                                                       ; piece is displayed
   353                                      
   354                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   355                                      ; set colour in dl
   356                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   357 00000554 8B1E[BA04]                  mov word bx, [current_piece_colour_index]
   358 00000558 D1E3                        shl bx, 1
   359 0000055A 8A97[B803]                  mov byte dl, [colour_falling_piece + bx]
   360 0000055E E8E001                      call procedure_draw_piece
   361                                      
   362                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   363                                      ; revert current piece to what is truly the current piece
   364                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   365 00000561 8F06[CC04]                  pop word [piece_position]
   366 00000565 8F06[C204]                  pop word [piece_orientation_index]
   367 00000569 8F06[C004]                  pop word [piece_definition]
   368 0000056D 8F06[BA04]                  pop word [current_piece_colour_index]
   369 00000571 E89101                      call procedure_copy_piece
   370                                      
   371                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   372                                  ;
   373                                  ; Repeat from here on down as the current piece is falling
   374                                  ;
   375                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   376                                  main_loop:
   377                                  
   378 00000574 A1[AA04]                	mov ax, [score]
   379 00000577 C1E804                  	shr ax, 4
   380 0000057A A2[B104]                	mov [skip_num], al
   381                                  
   382                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   383                                      ; advance frame
   384                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   385 0000057D A1[AE04]                    mov word ax, [current_frame]
   386 00000580 40                          inc ax
   387 00000581 A3[AE04]                    mov word [current_frame], ax
   388                                  	
   389 00000584 E87903                      call procedure_delay
   390                                      
   391                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   392                                      ; reset position delta and input state
   393                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   394 00000587 C706[CE04]0000              mov word [piece_position_delta], 0
   395 0000058D C606[B904]00                mov byte [player_input_pressed], 0
   396                                      
   397                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   398                                      ; animate logo
   399                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   400 00000592 E8ED04                      call procedure_display_logo
   401                                      
   402                                  read_input:
   403                                  
   404                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   405                                      ; read input, exiting game if the player chose to
   406                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   407 00000595 E80702                      call procedure_read_character
   408 00000598 803E[B704]00                cmp byte [must_quit], 0
   409 0000059D 0F85A700                    jne done
   410                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   411                                      ; [piece_position_delta] now contains modification from input
   412                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   413                                  
   414                                  handle_horizontal_movement:
   415                                      
   416                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   417                                      ; if the player didn't press left or right, skip directly to where we 
   418                                      ; handle vertical movement
   419                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   420 000005A1 A1[CE04]                    mov ax, [piece_position_delta]
   421 000005A4 85C0                        test ax, ax
   422 000005A6 7403                        jz handle_vertical_movement ; we didn't press left or right
   423                                  
   424                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   425                                      ; either left or right was pressed, so shift piece horizontally
   426                                      ; according to how delta was set
   427                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   428 000005A8 E87901                      call procedure_apply_delta_and_draw_piece
   429                                      
   430                                  handle_vertical_movement:
   431                                      
   432                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   433                                      ; for each of the blocks in the current piece
   434                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   435 000005AB 8B0E[A800]                  mov cx, [blocks_per_piece] ; each piece has 4 blocks
   436                                  handle_vertical_movement_loop:
   437                                  
   438                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   439                                      ; position di to the origin of current block
   440                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   441 000005AF 8B3E[CC04]                  mov di, [piece_position] ; start from the origin of the piece
   442 000005B3 89CB                        mov bx, cx ; wish I could use cx as an index register...
   443 000005B5 D1E3                        shl bx, 1 ; bx := bx * 2, since each block index is a word
   444 000005B7 83EB02                      sub bx, 2 ; our index is zero-based, while cx/loop are one-based
   445 000005BA 03BF[C404]                  add di, word [piece_blocks + bx] ; shift position in the piece 
   446                                                                       ; to the position of current block
   447                                  
   448                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   449                                      ; if current block cannot move down, then 
   450                                      ; the whole piece cannot move down
   451                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   452 000005BE E8F102                      call procedure_can_move_down
   453 000005C1 84C0                        test al, al ; a non-zero indicates an obstacle below
   454 000005C3 7504                        jnz handle_vertical_movement_loop_failure
   455                                      
   456                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   457                                      ; check next block
   458                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   459 000005C5 E2E8                        loop handle_vertical_movement_loop
   460                                      
   461                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   462                                      ; all blocks can move down means that the piece can move down
   463                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   464 000005C7 EB51                        jmp handle_vertical_movement_move_down_success
   465                                      
   466                                  handle_vertical_movement_loop_failure:
   467                                  
   468                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   469                                      ; we get here when the piece can no longer fall
   470                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   471 000005C9 A0[B904]                    mov byte al, [player_input_pressed]
   472 000005CC 84C0                        test al, al
   473                                      
   474                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   475                                      ; if no player input is present during this last frame, then cement right 
   476                                      ; away, because the player isn't trying to slide or rotate the piece at the
   477                                      ; last moment, as it is landing ( shortly after ); this would ultimately
   478                                      ; introduced an unnecessary delay when the piece lands, when the player
   479                                      ; is already expecting the next piece
   480                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   481 000005CE 740C                        jz handle_vertical_movement_cement_immediately
   482                                  
   483                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   484                                      ; decrement and check the cement counter to see if it reached zero
   485                                      ; if it did, then the piece landed a long enough time ago to be cemented
   486                                      ; in place
   487                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   488 000005D0 A0[B804]                    mov byte al, [cement_counter]
   489 000005D3 FEC8                        dec al
   490 000005D5 A2[B804]                    mov byte [cement_counter], al
   491 000005D8 84C0                        test al, al ; if we reached zero now, it means the piece can finally cement
   492 000005DA 7598                        jnz main_loop ; we haven't reached zero yet, so render next frame
   493                                  
   494                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   495                                      ; cement counter is now zero, which means we have to cement the piece
   496                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   497                                      
   498                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   499                                  ;
   500                                  ; Current piece can now be "cemented" on whatever it landed
   501                                  ;
   502                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   503                                  handle_vertical_movement_cement_immediately:
   504                                  
   505                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   506                                      ; since the cement counter isn't guaranteed to be zero, we should zero it
   507                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   508 000005DC C606[B804]00                mov byte [cement_counter], 0
   509                                      
   510                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   511                                      ; it cannot move down, so "cement it in place" by changing its colour
   512                                      ; by indexing in the cemented piece colours array
   513                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   514 000005E1 8B1E[BA04]                  mov word bx, [current_piece_colour_index]
   515 000005E5 D1E3                        shl bx, 1 ; each colour is a word, so offset by double the index
   516 000005E7 8A97[AA03]                  mov byte dl, [colour_cemented_piece + bx]
   517 000005EB E85301                      call procedure_draw_piece
   518                                  
   519                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   520                                      ; remove possibly full lines
   521                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   522 000005EE 31D2                        xor dx, dx ; we'll accumulate number of lines cleared in dx
   523 000005F0 B91400                      mov cx, 20 ; we're clearing at most 4 lines, each 
   524                                                 ; having a height of 5 pixels
   525                                      
   526                                  handle_vertical_movement_cement_immediately_attempt_clear_lines_loop:
   527 000005F3 52                          push dx
   528 000005F4 E8A100                      call procedure_attempt_line_removal    
   529 000005F7 5A                          pop dx
   530                                      
   531                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   532                                      ; accumulate number of cleared lines in dx and continue to loop
   533                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   534 000005F8 00C2                        add dl, al
   535 000005FA E2F7                        loop handle_vertical_movement_cement_immediately_attempt_clear_lines_loop
   536                                      
   537                                  update_score:
   538                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   539                                      ; dx now contains number of lines (not block lines!) cleared, so we must
   540                                      ; divide in order to convert to block lines (or actual "tetris" lines).
   541                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   542 000005FC 89D0                        mov ax, dx
   543 000005FE 8A16[A600]                  mov dl, [block_size]
   544 00000602 F6F2                        div dl ; al now contains number of block lines
   545 00000604 30E4                        xor ah, ah
   546                                      
   547                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   548                                      ; add number of cleared lines to the score
   549                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   550 00000606 8B16[AA04]                  mov word dx, [score]
   551 0000060A 01D0                        add ax, dx
   552                                      
   553                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   554                                      ; if score reached 1000, it rolls back to 0
   555                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   556 0000060C 3DE803                      cmp ax, 1000 ; our scoring goes to 999, so restart at 0 if it goes over
   557 0000060F 7C03                        jl score_is_not_over_1000
   558 00000611 2DE803                      sub ax, 1000
   559                                  score_is_not_over_1000:
   560 00000614 A3[AA04]                    mov word [score], ax
   561                                      
   562                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   563                                      ; spawn new piece
   564                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   565 00000617 E9D4FE                      jmp new_piece
   566                                  
   567                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   568                                  ;
   569                                  ; Current piece will now move down one pixel
   570                                  ;
   571                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   572                                  handle_vertical_movement_move_down_success:
   573                                  
   574                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   575                                      ; re-start cement counter, in case the piece landed on something, but the
   576                                      ; player slid it off during the cementing period, causing it to start 
   577                                      ; falling again, in which case we want to allow sliding again when it 
   578                                      ; lands on something again
   579                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   580 0000061A C606[B804]0A                mov byte [cement_counter], 10
   581                                  
   582                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   583                                      ; it can move down, and our delta will be one pixel lower
   584                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   585 0000061F A1[A400]                    mov ax, [screen_width]
   586 00000622 A3[CE04]                    mov word [piece_position_delta], ax
   587                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   588                                      ; delta is now one row lower
   589                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   590                                  
   591                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   592                                      ; move piece down and display it
   593                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   594 00000625 E8FC00                      call procedure_apply_delta_and_draw_piece
   595                                      
   596                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   597                                      ; render next frame
   598                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   599 00000628 E949FF                      jmp main_loop
   600                                  
   601                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   602                                  ;
   603                                  ; Game has ended because the screen has filled up (next piece can no
   604                                  ; longer spawn)
   605                                  ;
   606                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   607                                  game_over:
   608                                  
   609                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   610                                      ; draw game over overlay panel, and hide left/right/rotate controls
   611                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   612 0000062B E8C704                      call procedure_display_game_over
   613                                      
   614                                  game_over_loop:
   615                                  
   616                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   617                                      ; still display logo
   618                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   619 0000062E E85104                      call procedure_display_logo
   620                                      
   621 00000631 E8CC02                      call procedure_delay
   622                                      
   623                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   624                                      ; advance frame, since we're still animating the logo
   625                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   626 00000634 A1[AE04]                    mov word ax, [current_frame]
   627 00000637 40                          inc ax
   628 00000638 A3[AE04]                    mov word [current_frame], ax
   629                                      
   630                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   631                                      ; check whether any key is pressed
   632                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   633 0000063B E8(1580)                    call os_check_for_key
   634                                  
   635 0000063E 3C72                        cmp al, 'r'
   636 00000640 0F848CFE                    je initialization
   637                                      
   638 00000644 3C1B                        cmp al, 27
   639 00000646 75E6                        jne game_over_loop ; wait for Q to be pressed to exit the program
   640                                  
   641                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   642                                  ;
   643                                  ; Exit to the operating system
   644                                  ;
   645                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   646                                  done:
   647                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   648                                      ; return to the operating system
   649                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   650 00000648 C3                          ret
   651                                  
   652                                      
   653                                      
   654                                      
   655                                  
   656                                      
   657                                      
   658                                      
   659                                      
   660                                      
   661                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   662                                  ;
   663                                  ;
   664                                  ;
   665                                  ; Procedures
   666                                  ;
   667                                  ; Notes: 
   668                                  ;        - procedures are labels which are reached via call statements, and 
   669                                  ;          it is expected that they return properly
   670                                  ;        - some procedures preserve registers, as indicated in the comments
   671                                  ;        - some procedures expect input in registers, as per their comments
   672                                  ;        - some procedures output values in registers, as per their comments
   673                                  ;        - procedure naming convention is as follows:
   674                                  ;            1. their names are "procedure_xx_yy_zz"
   675                                  ;            2. their sub-labels (between which jumps occur while inside the
   676                                  ;               procedure) are named "xx_yy_zz_purpose", etc.
   677                                  ;          (I chose this naming convention in order to easily jump between
   678                                  ;          procedure definition and invocations via simple text search, as well
   679                                  ;          as between sub-labels within a procedure)
   680                                  ;
   681                                  ;
   682                                  ;
   683                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   684                                  
   685                                  
   686                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   687                                  ;
   688                                  ; Convert current score to a string, and display it
   689                                  ;
   690                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   691                                  procedure_display_score:
   692                                  
   693                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   694                                      ; divide by 100 and convert to the character '0', '1', '2', ... , '9',
   695                                      ; storing it in the first position of our 3-digit string buffer
   696                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   697 00000649 A1[AA04]                    mov word ax, [score]
   698 0000064C B264                        mov dl, 100
   699 0000064E F6F2                        div dl ; hundreds in al, remainder in ah 
   700 00000650 B130                        mov cl, '0'
   701 00000652 00C1                        add cl, al
   702 00000654 880E[A604]                  mov byte [msg_score_buffer], cl ; set hundreds digit
   703                                      
   704                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   705                                      ; divide by 10 and convert to the character '0', '1', '2', ... , '9',
   706                                      ; storing it in the second position of our 3-digit string buffer
   707                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   708 00000658 88E0                        mov al, ah ; divide remainder again
   709 0000065A 30E4                        xor ah, ah
   710 0000065C B20A                        mov dl, 10
   711 0000065E F6F2                        div dl ; tens in al, remainder in ah
   712 00000660 B130                        mov cl, '0'
   713 00000662 00C1                        add cl, al
   714 00000664 880E[A704]                  mov byte [msg_score_buffer + 1], cl ; set tens digit
   715                                      
   716                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   717                                      ; convert remainder to the character '0', '1', '2', ... , '9',
   718                                      ; storing it in the third position of our 3-digit string buffer
   719                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   720 00000668 B130                        mov cl, '0'
   721 0000066A 00E1                        add cl, ah
   722 0000066C 880E[A804]                  mov byte [msg_score_buffer + 2], cl ; set units digit
   723                                      
   724                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   725                                      ; display string representation of score
   726                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   727 00000670 BB[A604]                    mov bx, msg_score_buffer
   728 00000673 B60F                        mov dh, 15
   729 00000675 B21A                        mov dl, 26
   730 00000677 E80100                      call procedure_print_at
   731                                      
   732 0000067A C3                          ret
   733                                  
   734                                      
   735                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   736                                  ; 
   737                                  ; Print a string at the specified location
   738                                  ;
   739                                  ; Input:
   740                                  ;         dh = row
   741                                  ;         dl = column
   742                                  ;         bx = address of string
   743                                  ;
   744                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   745                                  procedure_print_at:
   746                                  
   747                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   748                                      ; position cursor
   749                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   750 0000067B E8(0680)                    call os_move_cursor
   751                                      
   752                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   753                                      ; output string
   754                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   755 0000067E 89DE                        mov si, bx
   756 00000680 E8(0380)                    call os_print_string
   757                                  
   758 00000683 C3                          ret
   759                                      
   760                                      
   761                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   762                                  ; 
   763                                  ; Create next piece
   764                                  ; 
   765                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   766                                  procedure_random_next_piece:
   767                                      
   768 00000684 E87902                      call procedure_delay ; advance random number (or seed for the initial call)
   769                                      
   770                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   771                                      ; piece index will be randomly chosen from [0, 6] inclusive
   772                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   773 00000687 B307                        mov bl, 7
   774 00000689 E86A00                      call procedure_generate_random_number ; choose a piece (in ax)
   775 0000068C A3[BC04]                    mov word [next_piece_colour_index], ax ; save colour index
   776                                      
   777                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   778                                      ; orientation will be randomly chosen from [0, 3] inclusive
   779                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   780 0000068F B304                        mov bl, 4
   781 00000691 E86200                      call procedure_generate_random_number ; choose one of four piece
   782                                                                            ; orientations (in ax)
   783                                      
   784 00000694 A3[BE04]                    mov word [next_piece_orientation_index], ax 
   785                                      
   786 00000697 C3                          ret
   787                                  
   788                                  
   789                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   790                                  ; 
   791                                  ; cx is preserved
   792                                  ;
   793                                  ; Attempt to find and remove one line by scanning upwards from the bottom of 
   794                                  ; the play area. As soon as the first full line is found, all lines above it 
   795                                  ; are shifted one line down.
   796                                  ; Finally, the top line in the play area is cleared.
   797                                  ;
   798                                  ; Note: "line" here means a one-pixel tall horizontal line, and NOT a line
   799                                  ;        which is as tall as a block
   800                                  ;
   801                                  ; Output:
   802                                  ;        al - number of lines cleared
   803                                  ; 
   804                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   805                                  procedure_attempt_line_removal:
   806                                  
   807 00000698 51                          push cx
   808                                      
   809                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   810                                      ; start at bottom left position of play area
   811                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   812 00000699 BFC7BA                      mov di, 47815
   813 0000069C B96800                      mov cx, 104 ; we'll check at most all but one lines of the play area
   814                                                  ; there are 20 block lines, and each block line is 5 pixels 
   815                                                  ; tall with an additional top line to accomodate pieces with 
   816                                                  ; an empty top block line in some of their orientations
   817                                      
   818                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   819                                      ; for each line moving upwards
   820                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   821                                  attempt_line_removal_loop:
   822                                  
   823                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   824                                      ; if this line is full (no black pixels), we will shift all lines above it
   825                                      ; down by one line each
   826                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   827 0000069F E83C00                      call procedure_is_horizontal_line_full
   828 000006A2 84C0                        test al, al
   829 000006A4 7408                        jz attempt_line_removal_full_line_found
   830                                      
   831                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   832                                      ; this line isn't full (it has gaps), so continue with next line above
   833                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   834 000006A6 2B3E[A400]                  sub di, [screen_width] ; move one line up
   835 000006AA E2F3                        loop attempt_line_removal_loop
   836                                      
   837                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   838                                      ; no completely full lines has been found
   839                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   840 000006AC EB2C                        jmp attempt_line_removal_no_line_found
   841                                      
   842                                  attempt_line_removal_full_line_found:
   843                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   844                                      ; di now points to the left most pixel of the full line we're removing
   845                                      ; and cx takes our next loop to the second line from the top (inclusive)
   846                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   847                                  attempt_line_removal_shift_lines_down_loop:
   848                                      
   849                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   850                                      ; save outer loop (for each line, going upwards)
   851                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   852 000006AE 51                          push cx 
   853 000006AF 57                          push di
   854                                          
   855                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   856                                      ; set source pointer for the memory copy operation to be one line above
   857                                      ; our current line
   858                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   859 000006B0 89FE                        mov si, di
   860 000006B2 2B36[A400]                  sub si, [screen_width] ; line above (source)
   861                                      
   862                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   863                                      ; destination pointer for the memory copy operation is in di, and is 
   864                                      ; set to the current line, as it should be
   865                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   866                                      
   867                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   868                                      ; memory copy operation will execute 50 times, going pixel-by-pixel to the
   869                                      ; right, copying the line above current line into current line
   870                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   871 000006B6 B93200                      mov cx, 50
   872                                      
   873                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   874                                      ; execute memory copy operation within the video memory segment, restoring
   875                                      ; data segments after
   876                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   877 000006B9 1E                          push ds
   878 000006BA 06                          push es
   879 000006BB B800A0                      mov ax, 0A000h ; we'll be reading and writing within the video segment
   880 000006BE 8ED8                        mov ds, ax ; so source segment will be this segment as well
   881 000006C0 8EC0                        mov es, ax ; and so will the destination segment
   882 000006C2 F3A4                        rep movsb
   883 000006C4 07                          pop es
   884 000006C5 1F                          pop ds
   885                                      
   886                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   887                                      ; restore outer loop (for each line, going upwards)
   888                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   889 000006C6 5F                          pop di
   890 000006C7 59                          pop cx
   891                                      
   892                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   893                                      ; next line (upwards)
   894                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   895 000006C8 2B3E[A400]                  sub di, [screen_width] ; move one line up
   896                                      
   897 000006CC E2E0                        loop attempt_line_removal_shift_lines_down_loop
   898                                      
   899                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   900                                      ; after the last iteration of our shift-lines-down-by-one loop, 
   901                                      ; di is at the beginning of the top most line; this is exactly where we 
   902                                      ; need it in order to empty (set all pixels to black) the top-most line
   903                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   904 000006CE 30D2                        xor dl, dl
   905 000006D0 B93200                      mov cx, 50
   906 000006D3 E8B402                      call procedure_draw_line ; empty the top most line
   907                                      
   908                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   909                                      ; return the fact that we did clear one line
   910                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   911 000006D6 B001                        mov al, 1
   912 000006D8 EB02                        jmp attempt_line_removal_done
   913                                  
   914                                  attempt_line_removal_no_line_found:    
   915                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   916                                      ; return the fact that no lines were cleared
   917                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   918 000006DA 30C0                        xor al, al
   919                                      
   920                                  attempt_line_removal_done:
   921 000006DC 59                          pop cx
   922 000006DD C3                          ret
   923                                  
   924                                  
   925                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   926                                  ;
   927                                  ; cx is preserved
   928                                  ; di is preserved
   929                                  ;
   930                                  ; Check a line to see whether it is full (meaning it contains no black pixels)
   931                                  ;
   932                                  ; Input:
   933                                  ;        di - position
   934                                  ; Output:
   935                                  ;        al - 0 if line is full
   936                                  ;
   937                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   938                                  procedure_is_horizontal_line_full:
   939 000006DE 51                          push cx
   940 000006DF 57                          push di
   941                                      
   942                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   943                                      ; for each pixel, going to the right, starting at di
   944                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   945 000006E0 B93200                      mov cx, 50 ; width of play area is 10 blocks
   946                                  is_horizontal_line_full_loop:
   947                                  
   948                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   949                                      ; if current pixel is black, then this line cannot be full
   950                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   951 000006E3 E8B802                      call procedure_read_pixel
   952 000006E6 84D2                        test dl, dl ; is colour at current location black?
   953 000006E8 7407                        jz is_horizontal_line_full_failure
   954                                      
   955                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   956                                      ; next pixel
   957                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   958 000006EA 47                          inc di ; next pixel of this line
   959 000006EB E2F6                        loop is_horizontal_line_full_loop
   960                                      
   961                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   962                                      ; if we got here, it means we haven't found any black pixels, so the line 
   963                                      ; is full; ax is set accordingly to return the fact that the line is full
   964                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   965 000006ED 31C0                        xor ax, ax
   966 000006EF EB02                        jmp is_horizontal_line_full_loop_done
   967                                      
   968                                  is_horizontal_line_full_failure:
   969                                  
   970                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   971                                      ; return the fact that the line isn't full
   972                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   973 000006F1 B001                        mov al, 1
   974                                      
   975                                  is_horizontal_line_full_loop_done:
   976 000006F3 5F                          pop di
   977 000006F4 59                          pop cx
   978                                      
   979 000006F5 C3                          ret
   980                                  
   981                                      
   982                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   983                                  ;
   984                                  ; Generate a random number between 0 and N-1 inclusive
   985                                  ;
   986                                  ; Input:
   987                                  ;        bl - N
   988                                  ; Output:
   989                                  ;        ax - random number
   990                                  ;    
   991                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   992                                  procedure_generate_random_number:
   993                                  
   994                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   995                                      ; advance random number
   996                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   997 000006F6 A0[B604]                    mov al, byte [random_number]
   998 000006F9 041F                        add al, 31
   999 000006FB A2[B604]                    mov byte [random_number], al
  1000                                  
  1001                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1002                                      ; divide by N and return remainder
  1003                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1004 000006FE F6F3                        div bl ; divide by N
  1005 00000700 88E0                        mov al, ah ; save remainder in al
  1006 00000702 30E4                        xor ah, ah
  1007                                      
  1008 00000704 C3                          ret
  1009                                  
  1010                                      
  1011                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1012                                  ;
  1013                                  ; Change current piece orientation to the 
  1014                                  ; orientation specified in [piece_orientation_index]
  1015                                  ;
  1016                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1017                                  procedure_copy_piece:
  1018                                      
  1019 00000705 1E                          push ds
  1020 00000706 06                          push es
  1021                                      
  1022                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1023                                      ; both source and destination segments will be the same as the code segment
  1024                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1025 00000707 8CC8                        mov ax, cs ; all code is within this segment
  1026 00000709 8ED8                        mov ds, ax ; so source segment will be this segment as well
  1027 0000070B 8EC0                        mov es, ax ; and so will the destination segment
  1028                                      
  1029                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1030                                      ; destination of memory copy operation is the current piece blocks array
  1031                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1032 0000070D BF[C404]                    mov di, piece_blocks ; pointer to current orientation (destination)
  1033                                      
  1034                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1035                                      ; source of memory copy operation is the current piece origin, offset by
  1036                                      ; the orientation specified in [piece_orientation_index]
  1037                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1038 00000710 A1[C204]                    mov ax, [piece_orientation_index] ; choose k-th orientation 
  1039                                                                        ; of this piece ( 0 through 3 )
  1040                                      
  1041 00000713 8B36[C004]                  mov si, [piece_definition] ; piece_definition is a pointer to 
  1042                                                                 ; first orientation of current piece (source)
  1043 00000717 C1E003                      shl ax, 3 ; ax := ax * 8 ( 4 words for each orientation )
  1044 0000071A 01C6                        add si, ax ; offset orientation within the current piece
  1045                                      
  1046                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1047                                      ; copy each of the four blocks
  1048                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1049 0000071C B90400                      mov cx, 4
  1050                                      
  1051 0000071F F3A5                        rep movsw ; perform copy
  1052                                      
  1053 00000721 07                          pop es
  1054 00000722 1F                          pop ds
  1055                                      
  1056 00000723 C3                          ret
  1057                                      
  1058                                      
  1059                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1060                                  ;
  1061                                  ; Applies a movement delta (causing either vertical or horizontal movement of
  1062                                  ; the current piece
  1063                                  ;
  1064                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1065                                  procedure_apply_delta_and_draw_piece:
  1066                                  
  1067                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1068                                      ; erase old piece
  1069                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1070                                      clr dl
    31 00000724 30D2                <1>  xor %1, %1
  1071 00000726 E81800                      call procedure_draw_piece
  1072                                  
  1073                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1074                                      ; apply delta
  1075                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1076 00000729 A1[CC04]                    mov ax, [piece_position]
  1077 0000072C 0306[CE04]                  add ax, [piece_position_delta]
  1078 00000730 A3[CC04]                    mov [piece_position], ax
  1079                                      
  1080                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1081                                      ; draw new piece
  1082                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1083 00000733 8B1E[BA04]                  mov word bx, [current_piece_colour_index]
  1084 00000737 D1E3                        shl bx, 1 ; two bytes per colour
  1085 00000739 8A97[B803]                  mov byte dl, [colour_falling_piece + bx]
  1086 0000073D E80100                      call procedure_draw_piece
  1087                                  
  1088 00000740 C3                          ret
  1089                                      
  1090                                      
  1091                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1092                                  ;
  1093                                  ; Draw the blocks within the current piece at current position
  1094                                  ;
  1095                                  ; Input:
  1096                                  ;        dl - colour
  1097                                  ;
  1098                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1099                                  procedure_draw_piece:    
  1100                                  
  1101                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1102                                      ; for each of the piece's four blocks
  1103                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1104 00000741 8B0E[A800]                  mov cx, [blocks_per_piece]
  1105                                  draw_piece_loop:
  1106                                  
  1107                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1108                                      ; set di to the origin (top left corner) of this piece
  1109                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1110 00000745 8B3E[CC04]                  mov di, [piece_position]
  1111                                      
  1112                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1113                                      ; and then offset it to the origin (top left corner) of the current block
  1114                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1115 00000749 89CB                        mov bx, cx
  1116 0000074B D1E3                        shl bx, 1 ; bx := bx * 2
  1117 0000074D 83EB02                      sub bx, 2 ; our index is zero-based, while cx/loop are one-based
  1118 00000750 03BF[C404]                  add di, word [piece_blocks + bx] ; shift position in the piece 
  1119                                                                       ; to the position of current block
  1120                                                                       
  1121                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1122                                      ; di now points to the origin of the current block, so we can draw it
  1123                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1124 00000754 8B1E[A600]                  mov bx, [block_size]
  1125 00000758 E80702                      call procedure_draw_square
  1126                                      
  1127                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1128                                      ; next block of this piece
  1129                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1130 0000075B E2E8                        loop draw_piece_loop
  1131                                      
  1132 0000075D C3                          ret
  1133                                  
  1134                                  
  1135                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
  1136                                  ;
  1137                                  ; Checks if current piece can be placed in its current position
  1138                                  ; This can be used to check if we can still spawn pieces (whether the
  1139                                  ; game has ended), or if we can rotate a certain piece (since existing
  1140                                  ; "cemented" blocks could be in the way, or we could be too close to the
  1141                                  ; edge or bottom)
  1142                                  ;
  1143                                  ; Output
  1144                                  ;        al - 0 if piece can be placed at current location
  1145                                  ;
  1146                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1147                                  procedure_can_piece_be_placed:
  1148                                          
  1149                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1150                                      ; for each of the piece's four blocks
  1151                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1152 0000075E 8B0E[A800]                  mov cx, [blocks_per_piece] ; each piece has 4 blocks
  1153                                  can_piece_be_placed_loop:
  1154                                  
  1155                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1156                                      ; set di to the origin (top left corner) of this piece
  1157                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1158 00000762 8B3E[CC04]                  mov di, [piece_position]
  1159                                      
  1160                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1161                                      ; and then offset it to the origin (top left corner) of the current block
  1162                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1163 00000766 89CB                        mov bx, cx 
  1164 00000768 D1E3                        shl bx, 1 ; bx := bx * 2
  1165 0000076A 83EB02                      sub bx, 2 ; our index is zero-based, while cx/loop are one-based
  1166 0000076D 03BF[C404]                  add di, word [piece_blocks + bx] ; shift position in the piece 
  1167                                                                       ; to the position of current block
  1168                                      
  1169                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1170                                      ; preserve outer loop (for each block of current piece)
  1171                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1172 00000771 51                          push cx ; don't mess up the outer loop
  1173                                      
  1174                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1175                                      ; inner loop will check horizontal lines, so the pixel increment is 1
  1176                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1177 00000772 BB0100                      mov bx, 1 ; horizontal lines
  1178                                      
  1179                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1180                                      ; di now points to the first horizontal line of this block
  1181                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1182                                      
  1183                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1184                                      ; for each of this block's horizontal lines
  1185                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1186 00000775 8B0E[A600]                  mov cx, [block_size]
  1187                                  can_piece_be_placed_line_by_line_loop:
  1188                                  
  1189                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1190                                      ; if current line is not available, we cannot place this piece
  1191                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1192 00000779 E85601                      call procedure_is_line_available
  1193 0000077C 84C0                        test al, al ; a non-zero indicates an obstacle
  1194 0000077E 750D                        jne can_piece_be_placed_failure
  1195                                      
  1196                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1197                                      ; next horizontal line of this block
  1198                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1199 00000780 033E[A400]                  add di, [screen_width]
  1200 00000784 E2F3                        loop can_piece_be_placed_line_by_line_loop
  1201                                      
  1202                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1203                                      ; restore outer loop (for each block of current piece)
  1204                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1205 00000786 59                          pop cx
  1206                                      
  1207                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1208                                      ; next block of this piece
  1209                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1210 00000787 E2D9                        loop can_piece_be_placed_loop
  1211                                      
  1212                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1213                                      ; we've checked all blocks of this piece, and they can all be placed, so
  1214                                      ; then the piece itself can be placed
  1215                                      ; set ax to return the fact that this piece can be placed here
  1216                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1217 00000789 31C0                        xor ax, ax
  1218 0000078B EB03                        jmp can_piece_be_placed_success
  1219                                  
  1220                                  can_piece_be_placed_failure:
  1221                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1222                                      ; return the fact that this piece cannot be placed here
  1223                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1224 0000078D B001                        mov al, 1
  1225                                      
  1226                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1227                                      ; we broke out of the inner loop, so didn't pop cx for the outer loop
  1228                                      ; and we must not corrupt stack
  1229                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1230 0000078F 59                          pop cx
  1231                                  
  1232                                  can_piece_be_placed_success:
  1233                                  
  1234 00000790 C3                          ret
  1235                                  
  1236                                  
  1237                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1238                                  ;
  1239                                  ; Advances orientation index, and copies the new orientation to 
  1240                                  ; make it current, as needed by a rotation
  1241                                  ;
  1242                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1243                                  procedure_advance_orientation:
  1244                                  
  1245                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1246                                      ; advance index within [0, 3], cycling back to 0 from 3
  1247                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1248 00000791 A1[C204]                    mov word ax, [piece_orientation_index]
  1249 00000794 40                          inc ax
  1250 00000795 83E003                      and ax, 3 ; ax := (ax + 1) mod 4
  1251 00000798 A3[C204]                    mov word [piece_orientation_index], ax
  1252                                      
  1253                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1254                                      ; copy new orientation in the current piece
  1255                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1256 0000079B E867FF                      call procedure_copy_piece
  1257                                      
  1258 0000079E C3                          ret
  1259                                      
  1260                                      
  1261                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1262                                  ;
  1263                                  ; Read keyboard input and act accordingly
  1264                                  ;
  1265                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1266                                  procedure_read_character: 
  1267                                  
  1268                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1269                                      ; check if any key is pressed
  1270                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1271 0000079F B401                        mov ah, 1
  1272 000007A1 CD16                        int 16h ; any keys pressed?
  1273 000007A3 7501                        jnz read_character_key_was_pressed ; yes
  1274                                      
  1275                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1276                                      ; no keys pressed
  1277                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1278 000007A5 C3                          ret
  1279                                  
  1280                                  read_character_key_was_pressed:
  1281 000007A6 E8(1580)                    call os_check_for_key
  1282                                  
  1283                                  handle_input:
  1284                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1285                                      ; check whether right was pressed
  1286                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1287 000007A9 80FC4D                      cmp ah, 77
  1288 000007AC 0F848D00                    je move_right
  1289                                      
  1290                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1291                                      ; check whether left was pressed
  1292                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1293 000007B0 80FC4B                      cmp ah, 75
  1294 000007B3 0F84C200                    je move_left
  1295                                      
  1296                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1297                                      ; check whether down was pressed
  1298                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1299 000007B7 80FC50                      cmp ah, 80
  1300 000007BA 740D                        je inc_speed
  1301                                      
  1302                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1303                                      ; check whether rotate was pressed
  1304                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1305 000007BC 3C7A                        cmp al, 'z'
  1306 000007BE 7415                        je rotate_left
  1307                                      
  1308 000007C0 3C78                        cmp al, 'x'
  1309 000007C2 7427                        je rotate_right
  1310                                      
  1311                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1312                                      ; check whether quit was pressed
  1313                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1314 000007C4 3C1B                        cmp al, 27
  1315 000007C6 7407                        je quit    
  1316                                      
  1317                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1318                                      ; an unknown key was pressed
  1319                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1320 000007C8 C3                          ret
  1321                                  
  1322                                  inc_speed:
  1323 000007C9 C606[B004]05            	mov byte [piece_speed], 5
  1324 000007CE C3                      	ret
  1325                                      
  1326                                  quit:
  1327                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1328                                      ; indicate that the main loop should end, and we should exit the game
  1329                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1330 000007CF C606[B704]01                mov byte [must_quit], 1    
  1331                                      
  1332 000007D4 C3                          ret
  1333                                  
  1334                                  rotate_left:
  1335                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1336                                      ; save old orientation, in case we cannot rotate
  1337                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1338 000007D5 FF36[C204]                  push word [piece_orientation_index]
  1339                                      
  1340                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1341                                      ; change to next orientation 
  1342                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1343 000007D9 E8B5FF                      call procedure_advance_orientation
  1344                                      
  1345                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1346                                      ; see if new orientation can be placed
  1347                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1348 000007DC E87FFF                      call procedure_can_piece_be_placed
  1349 000007DF 84C0                        test al, al ; did we get a 0, meaning ok
  1350 000007E1 7424                        jz rotate_left_perform ; yes!
  1351                                      
  1352                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1353                                      ; new orientation cannot be placed, so restore old orientation
  1354                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1355 000007E3 8F06[C204]                  pop word [piece_orientation_index] 
  1356 000007E7 E81BFF                      call procedure_copy_piece
  1357                                      
  1358 000007EA C3                          ret
  1359                                      
  1360                                  rotate_right:
  1361                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1362                                      ; save old orientation, in case we cannot rotate
  1363                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1364 000007EB FF36[C204]                  push word [piece_orientation_index]
  1365                                      
  1366                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1367                                      ; change to next orientation 
  1368                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1369 000007EF E89FFF                      call procedure_advance_orientation
  1370 000007F2 E89CFF                      call procedure_advance_orientation
  1371 000007F5 E899FF                      call procedure_advance_orientation
  1372                                      
  1373                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1374                                      ; see if new orientation can be placed
  1375                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1376 000007F8 E863FF                      call procedure_can_piece_be_placed
  1377 000007FB 84C0                        test al, al ; did we get a 0, meaning ok
  1378 000007FD 7420                        jz rotate_right_perform ; yes!
  1379                                      
  1380                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1381                                      ; new orientation cannot be placed, so restore old orientation
  1382                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1383 000007FF 8F06[C204]                  pop word [piece_orientation_index] 
  1384 00000803 E8FFFE                      call procedure_copy_piece
  1385                                      
  1386 00000806 C3                          ret
  1387                                      
  1388                                  rotate_left_perform:
  1389                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1390                                      ; new orientation can be placed
  1391                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1392                                  
  1393                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1394                                      ; restore old orientation, so we can clear it
  1395                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1396 00000807 8F06[C204]                  pop word [piece_orientation_index] 
  1397 0000080B E8F7FE                      call procedure_copy_piece
  1398                                      
  1399                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1400                                      ; draw old orientation in black to clear it
  1401                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1402 0000080E 30D2                        xor dl, dl ; black colour
  1403 00000810 E82EFF                      call procedure_draw_piece
  1404                                      
  1405                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1406                                      ; change to next orientation 
  1407                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1408 00000813 E87BFF                      call procedure_advance_orientation
  1409                                      
  1410                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1411                                      ; advance random number
  1412                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1413 00000816 A0[B604]                    mov al, byte [random_number]
  1414 00000819 040B                        add al, 11
  1415 0000081B A2[B604]                    mov byte [random_number], al
  1416                                      
  1417 0000081E C3                          ret
  1418                                      
  1419                                  rotate_right_perform:
  1420                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1421                                      ; new orientation can be placed
  1422                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1423                                  
  1424                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1425                                      ; restore old orientation, so we can clear it
  1426                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1427 0000081F 8F06[C204]                  pop word [piece_orientation_index] 
  1428 00000823 E8DFFE                      call procedure_copy_piece
  1429                                      
  1430                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1431                                      ; draw old orientation in black to clear it
  1432                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1433 00000826 30D2                        xor dl, dl ; black colour
  1434 00000828 E816FF                      call procedure_draw_piece
  1435                                      
  1436                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1437                                      ; change to next orientation 
  1438                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1439 0000082B E863FF                      call procedure_advance_orientation
  1440 0000082E E860FF                      call procedure_advance_orientation
  1441 00000831 E85DFF                      call procedure_advance_orientation
  1442                                      
  1443                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1444                                      ; advance random number
  1445                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1446 00000834 A0[B604]                    mov al, byte [random_number]
  1447 00000837 040B                        add al, 11
  1448 00000839 A2[B604]                    mov byte [random_number], al
  1449                                      
  1450 0000083C C3                          ret
  1451                                      
  1452                                  move_right:
  1453                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1454                                      ; set player input flag
  1455                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1456 0000083D C606[B904]01                mov byte [player_input_pressed], 1
  1457                                      
  1458                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1459                                      ; determine if we can move right
  1460                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1461                                      
  1462                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1463                                      ; for each of the piece's four blocks
  1464                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1465 00000842 8B0E[A800]                  mov cx, [blocks_per_piece]
  1466                                  move_right_loop:
  1467                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1468                                      ; set di to the origin (top left corner) of this piece
  1469                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1470 00000846 8B3E[CC04]                  mov di, [piece_position]
  1471                                      
  1472                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1473                                      ; and then offset it to the origin (top left corner) of the current block
  1474                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1475 0000084A 89CB                        mov bx, cx
  1476 0000084C D1E3                        shl bx, 1 ; bx := bx * 2
  1477 0000084E 83EB02                      sub bx, 2 ; our index is zero-based, while cx/loop are one-based
  1478 00000851 03BF[C404]                  add di, word [piece_blocks + bx] ; shift position in the piece 
  1479                                                                       ; to the position of current block
  1480                                      
  1481                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1482                                      ; position di immediately to the right of the end of the block's first line
  1483                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1484 00000855 033E[A600]                  add di, [block_size]
  1485                                  
  1486                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1487                                      ; set pixel increment to screen width, meaning a vertical line, and check
  1488                                      ; whether the vertical line immediately to the right of block is available
  1489                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1490 00000859 8B1E[A400]                  mov bx, [screen_width]
  1491 0000085D E87200                      call procedure_is_line_available
  1492                                      
  1493                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1494                                      ; if line is not available, we cannot move
  1495                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1496 00000860 84C0                        test al, al ; did we get a 0, meaning success ?
  1497 00000862 750C                        jnz move_right_done ; no
  1498                                      
  1499                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1500                                      ; next block of this piece
  1501                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1502 00000864 E2E0                        loop move_right_loop
  1503                                      
  1504                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1505                                      ; we are moving right, so set piece position delta adequately
  1506                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1507 00000866 A1[CE04]                    mov ax, [piece_position_delta]
  1508 00000869 0306[A600]                  add ax, [block_size]
  1509 0000086D A3[CE04]                    mov [piece_position_delta], ax
  1510                                  
  1511                                  move_right_done:
  1512                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1513                                      ; advance random number
  1514                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1515 00000870 A0[B604]                    mov al, byte [random_number]
  1516 00000873 0403                        add al, 3
  1517 00000875 A2[B604]                    mov byte [random_number], al
  1518                                      
  1519 00000878 C3                          ret
  1520                                      
  1521                                  move_left:
  1522                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1523                                      ; set player input flag
  1524                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1525 00000879 C606[B904]01                mov byte [player_input_pressed], 1
  1526                                      
  1527                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1528                                      ; determine if we can move left
  1529                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1530                                      
  1531                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1532                                      ; for each of the piece's four blocks
  1533                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1534 0000087E 8B0E[A800]                  mov cx, [blocks_per_piece]
  1535                                  move_left_loop:    
  1536                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1537                                      ; set di to the origin (top left corner) of this piece
  1538                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1539 00000882 8B3E[CC04]                  mov di, [piece_position]
  1540                                      
  1541                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1542                                      ; and then offset it to the origin (top left corner) of the current block
  1543                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1544 00000886 89CB                        mov bx, cx
  1545 00000888 D1E3                        shl bx, 1 ; bx := bx * 2
  1546 0000088A 83EB02                      sub bx, 2 ; our index is zero-based, while cx/loop are one-based
  1547 0000088D 03BF[C404]                  add di, word [piece_blocks + bx] ; shift position in the piece 
  1548                                                                       ; to the position of current block
  1549                                      
  1550                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1551                                      ; position di immediately to the left of the block's origin (top left)
  1552                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1553 00000891 4F                          dec di
  1554                                      
  1555                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1556                                      ; set pixel increment to screen width, meaning a vertical line, and check
  1557                                      ; whether the vertical line immediately to the left of block is available
  1558                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1559 00000892 8B1E[A400]                  mov bx, [screen_width]
  1560 00000896 E83900                      call procedure_is_line_available
  1561                                      
  1562                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1563                                      ; if line is not available, we cannot move
  1564                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1565 00000899 84C0                        test al, al ; did we get a 0, meaning success ?
  1566 0000089B 750C                        jnz move_left_done ; no    
  1567                                      
  1568                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1569                                      ; next block of this piece
  1570                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1571 0000089D E2E3                        loop move_left_loop
  1572                                      
  1573                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1574                                      ; we are moving left, so set piece position delta adequately
  1575                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1576 0000089F A1[CE04]                    mov ax, [piece_position_delta]
  1577 000008A2 2B06[A600]                  sub ax, [block_size]
  1578 000008A6 A3[CE04]                    mov [piece_position_delta], ax
  1579                                      
  1580                                  move_left_done:
  1581                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1582                                      ; advance random number
  1583                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1584 000008A9 A0[B604]                    mov al, byte [random_number]
  1585 000008AC 0405                        add al, 5
  1586 000008AE A2[B604]                    mov byte [random_number], al
  1587                                      
  1588 000008B1 C3                          ret
  1589                                  
  1590                                      
  1591                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1592                                  ;
  1593                                  ; di is preserved
  1594                                  ; cx is preserved
  1595                                  ;
  1596                                  ; Given a position, check if a block with the origin at that position
  1597                                  ; can move downward one pixel
  1598                                  ;
  1599                                  ; Input:
  1600                                  ;        di - position
  1601                                  ; Output:
  1602                                  ;        al - 0 if can move
  1603                                  ;
  1604                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1605                                  procedure_can_move_down:
  1606                                  
  1607 000008B2 51                          push cx
  1608 000008B3 57                          push di
  1609                                      
  1610                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1611                                      ; position di right underneath block's left most bottom pixel
  1612                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1613 000008B4 8B0E[A600]                  mov cx, [block_size]
  1614                                  can_move_down_find_delta:
  1615 000008B8 033E[A400]                  add di, [screen_width]
  1616 000008BC E2FA                        loop can_move_down_find_delta
  1617                                      
  1618                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1619                                      ; set pixel increment to one, meaning a horizontal line, and check
  1620                                      ; whether the horizontal line immediately below the block is available
  1621                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1622 000008BE BB0100                      mov bx, 1
  1623 000008C1 E80E00                      call procedure_is_line_available
  1624                                      
  1625                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1626                                      ; if line is not available, this block cannot move down
  1627                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1628 000008C4 84C0                        test al, al ; did we get a 0, meaning success ?
  1629 000008C6 7504                        jnz can_move_down_obstacle_found ; no
  1630                                      
  1631                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1632                                      ; this block can move down, so return this fact
  1633                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1634 000008C8 31C0                        xor ax, ax
  1635 000008CA EB03                        jmp can_move_down_done
  1636                                      
  1637                                  can_move_down_obstacle_found:
  1638                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1639                                      ; return the fact that this block cannot move down
  1640                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1641 000008CC B80100                      mov ax, 1
  1642                                      
  1643                                  can_move_down_done:
  1644                                      
  1645 000008CF 5F                          pop di
  1646 000008D0 59                          pop cx
  1647                                      
  1648 000008D1 C3                          ret
  1649                                  
  1650                                  
  1651                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1652                                  ;
  1653                                  ; di is preserved    
  1654                                  ; cx is preserved
  1655                                  ; bx is preserved
  1656                                  ;
  1657                                  ; Check if a line of length [block_size] is available. 
  1658                                  ; An available line can only contain either:
  1659                                  ;    - black pixels, or
  1660                                  ;    - pixels of the same colour as the falling block
  1661                                  ;
  1662                                  ; Input:
  1663                                  ;        di - position (beginning of line to check)
  1664                                  ;        bx - pixel increment (can be used to change between horizontal
  1665                                  ;                 and vertical lines
  1666                                  ; Output:
  1667                                  ;        al - 0 if line is available, 1 otherwise
  1668                                  ;
  1669                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1670                                  procedure_is_line_available:
  1671                                  
  1672 000008D2 53                          push bx
  1673 000008D3 51                          push cx
  1674 000008D4 57                          push di
  1675                                      
  1676                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1677                                      ; for each pixel of this line
  1678                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1679 000008D5 8B0E[A600]                  mov cx, [block_size]
  1680                                  is_line_available_loop:
  1681                                  
  1682                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1683                                      ; if current pixel is not black, we found an obstacle
  1684                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1685 000008D9 E8C200                      call procedure_read_pixel
  1686 000008DC 84D2                        test dl, dl ; is colour at current location black?
  1687 000008DE 7508                        jnz is_line_available_obstacle_found
  1688                                      
  1689                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1690                                      ; current pixel is black, so continue with next pixel of this line
  1691                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1692                                  is_line_available_loop_next_pixel:    
  1693 000008E0 01DF                        add di, bx ; move to next pixel of this line
  1694 000008E2 E2F5                        loop is_line_available_loop
  1695                                      
  1696                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1697                                      ; if we got here, it means that all pixels are either black or of the same
  1698                                      ; colour as the current piece, so we return success
  1699                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1700 000008E4 31C0                        xor ax, ax
  1701 000008E6 EB14                        jmp is_line_available_loop_done
  1702                                  
  1703                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1704                                      ; one of the pixels of this line was not black
  1705                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1706                                      
  1707                                  is_line_available_obstacle_found:
  1708                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1709                                      ; if this pixel is not the same colour as the falling piece, this line is
  1710                                      ; not available
  1711                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1712 000008E8 53                          push bx
  1713 000008E9 8B1E[BA04]                  mov word bx, [current_piece_colour_index]
  1714 000008ED D1E3                        shl bx, 1 ; two bytes per colour
  1715 000008EF 8A87[B803]                  mov byte al, [colour_falling_piece + bx]
  1716 000008F3 38C2                        cmp dl, al ; if obstacle is a falling block, treat it as a non-obstacle
  1717 000008F5 5B                          pop bx
  1718 000008F6 7502                        jne is_line_available_failure
  1719                                      
  1720                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1721                                      ; this pixel isn't black, but is of the same colour as the falling piece
  1722                                      ; so we don't fail because of it, and we resume loop
  1723                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1724 000008F8 EBE6                        jmp is_line_available_loop_next_pixel
  1725                                      
  1726                                  is_line_available_failure:
  1727                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1728                                      ; return the fact that this line is not available
  1729                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1730 000008FA B001                        mov al, 1
  1731                                      
  1732                                  is_line_available_loop_done:
  1733 000008FC 5F                          pop di
  1734 000008FD 59                          pop cx
  1735 000008FE 5B                          pop bx
  1736                                      
  1737 000008FF C3                          ret
  1738                                  
  1739                                  
  1740                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1741                                  ;
  1742                                  ; ax is preserved
  1743                                  ; bx is preserved
  1744                                  ; cx is preserved
  1745                                  ; dx is preserved
  1746                                  ;
  1747                                  ; Creates a delay lasting a specified number of centiseconds
  1748                                  ;
  1749                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1750                                  procedure_delay:
  1751 00000900 60                      	pusha
  1752                                      
  1753 00000901 803E[B004]00                cmp byte [piece_speed], 0
  1754 00000906 7406                        je .no_skip
  1755                                      
  1756 00000908 FE0E[B004]                  dec byte [piece_speed]
  1757 0000090C 61                          popa
  1758 0000090D C3                          ret
  1759                                      
  1760                                  .no_skip:
  1761 0000090E 803E[6109]00            	cmp byte [tmp_skip_num], 0
  1762 00000913 7406                    	je .speed_end
  1763                                  	
  1764 00000915 FE0E[6109]              	dec byte [tmp_skip_num]
  1765 00000919 61                      	popa
  1766 0000091A C3                      	ret
  1767                                  	
  1768                                  .speed_end:
  1769 0000091B A0[B104]                	mov al, [skip_num]
  1770 0000091E A2[6109]                	mov [tmp_skip_num], al
  1771                                  	
  1772 00000921 B80100                      mov ax, 1
  1773 00000924 E8(2480)                    call os_pause
  1774                                      
  1775 00000927 8B1E[AC04]                  mov bx, [music_counter]
  1776 0000092B F7C30100                    test bx, 1
  1777 0000092F 7517                        jne .no_music
  1778                                      
  1779 00000931 BE[AA00]                    mov si, track00
  1780 00000934 8B00                        mov ax, [si + bx]
  1781                                      
  1782 00000936 3B06[B204]                  cmp ax, [previous_note]
  1783 0000093A 740C                        je .no_music
  1784                                      
  1785 0000093C A3[B204]                    mov [previous_note], ax
  1786                                      
  1787 0000093F 85C0                        test ax, ax
  1788 00000941 7419                        jz .spkr_off
  1789                                      
  1790 00000943 D1E8                        shr ax, 1
  1791 00000945 E8(1B80)                    call os_speaker_tone
  1792                                  	
  1793                                  .no_music:
  1794 00000948 FF06[AC04]                  inc word [music_counter]
  1795 0000094C 813E[AC04]0003          	cmp word [music_counter], 768
  1796 00000952 7506                    	jne .no_reset_ptr
  1797                                  	
  1798 00000954 C706[AC04]0000          	mov word [music_counter], 0
  1799                                  	
  1800                                  .no_reset_ptr:
  1801 0000095A 61                          popa
  1802 0000095B C3                          ret
  1803                                  
  1804                                  .spkr_off:
  1805 0000095C E8(1E80)                	call os_speaker_off
  1806 0000095F EBE7                    	jmp .no_music
  1807                                  	
  1808 00000961 00                      	tmp_skip_num	db 0
  1809                                  	
  1810                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1811                                  ;
  1812                                  ; di is preserved
  1813                                  ; dl is preserved
  1814                                  ; cx is preserved
  1815                                  ;
  1816                                  ; Draw a square at the specified location and using the specified colour
  1817                                  ;
  1818                                  ; Input:
  1819                                  ;        bx - size of square
  1820                                  ;        di - position
  1821                                  ;        dl - colour
  1822                                  ;
  1823                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1824                                  procedure_draw_square:
  1825                                  
  1826                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1827                                      ; draw a rectangle whose height equals its width
  1828                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1829 00000962 89D8                        mov ax, bx
  1830 00000964 E80100                      call procedure_draw_rectangle
  1831                                      
  1832 00000967 C3                          ret
  1833                                      
  1834                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1835                                  ;
  1836                                  ; di is preserved
  1837                                  ; dl is preserved
  1838                                  ; cx is preserved
  1839                                  ;
  1840                                  ; Draw a rectangle at the specified location and using the specified colour
  1841                                  ;
  1842                                  ; Input:
  1843                                  ;        ax - height
  1844                                  ;        bx - width
  1845                                  ;        di - position
  1846                                  ;        dl - colour
  1847                                  ;
  1848                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1849                                  procedure_draw_rectangle:
  1850                                  
  1851 00000968 57                          push di
  1852 00000969 52                          push dx
  1853 0000096A 51                          push cx
  1854                                      
  1855                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1856                                      ; for each horizontal line (there are [height] of them)
  1857                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1858 0000096B 89C1                        mov cx, ax
  1859                                  draw_rectangle_loop:    
  1860                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1861                                      ; draw a bx wide horizontal line
  1862                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1863 0000096D 51                          push cx
  1864 0000096E 57                          push di
  1865 0000096F 89D9                        mov cx, bx
  1866 00000971 E81600                      call procedure_draw_line
  1867                                      
  1868                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1869                                      ; restore di to the beginning of this line
  1870                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1871 00000974 5F                          pop di
  1872                                      
  1873                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1874                                      ; move di down one line, to the beginning of the next line
  1875                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1876 00000975 033E[A400]                  add di, [screen_width]
  1877                                      
  1878                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1879                                      ; restore loop counter
  1880                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1881 00000979 59                          pop cx
  1882                                      
  1883                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1884                                      ; next horizontal line
  1885                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1886 0000097A E2F1                        loop draw_rectangle_loop
  1887                                  
  1888 0000097C 59                          pop cx
  1889 0000097D 5A                          pop dx
  1890 0000097E 5F                          pop di
  1891                                      
  1892 0000097F C3                          ret
  1893                                  
  1894                                  
  1895                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1896                                  ;
  1897                                  ; di is modified to point to the first address after the end of the line    
  1898                                  ;
  1899                                  ; Draw a vertical line
  1900                                  ;
  1901                                  ; Input: 
  1902                                  ;        cx - line length
  1903                                  ;        di - position
  1904                                  ;        dl - colour
  1905                                  ;
  1906                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1907                                  procedure_draw_line_vertical:
  1908                                  
  1909 00000980 E80E00                      call procedure_draw_pixel
  1910                                      
  1911                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1912                                      ; move di one pixel down
  1913                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1914 00000983 033E[A400]                  add di, [screen_width]
  1915                                      
  1916                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1917                                      ; next pixel
  1918                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1919 00000987 E2F7                        loop procedure_draw_line_vertical
  1920                                      
  1921 00000989 C3                          ret
  1922                                  
  1923                                      
  1924                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1925                                  ;
  1926                                  ; di is modified to point to the first address after the end of the line    
  1927                                  ;
  1928                                  ; Draw a horizontal line
  1929                                  ;
  1930                                  ; Input: 
  1931                                  ;        cx - line length
  1932                                  ;        di - position
  1933                                  ;        dl - colour
  1934                                  ;
  1935                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1936                                  procedure_draw_line:
  1937                                  
  1938 0000098A E80400                      call procedure_draw_pixel
  1939                                      
  1940                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1941                                      ; move di one pixel to the right
  1942                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1943 0000098D 47                          inc di
  1944                                      
  1945                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1946                                      ; next pixel
  1947                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1948 0000098E E2FA                        loop procedure_draw_line
  1949                                      
  1950 00000990 C3                          ret
  1951                                  
  1952                                  
  1953                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1954                                  ; 
  1955                                  ; Draw a pixel
  1956                                  ;
  1957                                  ; Input: 
  1958                                  ;        di - position
  1959                                  ;        dl - colour
  1960                                  ;
  1961                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1962                                  procedure_draw_pixel:
  1963                                  
  1964 00000991 50                          push ax
  1965 00000992 06                          push es
  1966                                  
  1967                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1968                                      ; set A000:di to the specified colour
  1969                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1970 00000993 B800A0                      mov ax, 0A000h
  1971 00000996 8EC0                        mov es, ax
  1972 00000998 268815                      mov byte [es:di], dl
  1973                                      
  1974 0000099B 07                          pop es
  1975 0000099C 58                          pop ax
  1976                                      
  1977 0000099D C3                          ret
  1978                                  
  1979                                  
  1980                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1981                                  ;
  1982                                  ; Read a pixel's colour
  1983                                  ;
  1984                                  ; Input:
  1985                                  ;        di - position
  1986                                  ; Output:
  1987                                  ;        dl - colour
  1988                                  ;
  1989                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1990                                  procedure_read_pixel:
  1991                                  
  1992 0000099E 50                          push ax
  1993 0000099F 06                          push es
  1994                                  
  1995                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1996                                      ; read byte at A000:di
  1997                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1998 000009A0 B800A0                      mov ax, 0A000h
  1999 000009A3 8EC0                        mov es, ax
  2000 000009A5 268A15                      mov byte dl, [es:di]
  2001                                      
  2002 000009A8 07                          pop es
  2003 000009A9 58                          pop ax
  2004                                      
  2005 000009AA C3                          ret
  2006                                  
  2007                                  
  2008                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2009                                  ;
  2010                                  ; Draw a border around the entire screen
  2011                                  ;
  2012                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2013                                  procedure_draw_border:
  2014                                  
  2015 000009AB B2C8                        mov dl, 200 ; colour
  2016                                      
  2017 000009AD BB0400                      mov bx, 4
  2018 000009B0 B8C800                      mov ax, 200
  2019                                      
  2020                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2021                                      ; top left to bottom left
  2022                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2023 000009B3 31FF                        xor di, di
  2024 000009B5 E8B0FF                      call procedure_draw_rectangle
  2025                                      
  2026                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2027                                      ; top right to bottom right
  2028                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2029 000009B8 BF3C01                      mov di, 316
  2030 000009BB E8AAFF                      call procedure_draw_rectangle
  2031                                      
  2032 000009BE BB3D01                      mov bx, 317
  2033 000009C1 B80400                      mov ax, 4
  2034                                      
  2035                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2036                                      ; top left to top right
  2037                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2038 000009C4 31FF                        xor di, di
  2039 000009C6 E89FFF                      call procedure_draw_rectangle
  2040                                      
  2041                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2042                                      ; bottom left to bottom right
  2043                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2044 000009C9 BF00F5                      mov di, 62720
  2045 000009CC E899FF                      call procedure_draw_rectangle
  2046                                      
  2047 000009CF C3                          ret
  2048                                  
  2049                                  
  2050                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2051                                  ;
  2052                                  ; Decorate the screen with the play area, border, controls, author, etc.
  2053                                  ;
  2054                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2055                                  procedure_draw_screen:
  2056                                  
  2057 000009D0 E8D8FF                      call procedure_draw_border
  2058                                      
  2059                                  draw_screen_play_area:
  2060                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2061                                      ; draw the box within which pieces fall and the game is played
  2062                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2063 000009D3 B21B                        mov dl, 27 ; colour
  2064                                      
  2065                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2066                                      ; top left to top right
  2067                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2068 000009D5 B93400                      mov cx, 52
  2069 000009D8 BF8637                      mov di, 14214
  2070 000009DB E8ACFF                      call procedure_draw_line
  2071                                      
  2072                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2073                                      ; bottom left to bottom right
  2074                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2075 000009DE B93400                      mov cx, 52
  2076 000009E1 BF06BC                      mov di, 48134
  2077 000009E4 E8A3FF                      call procedure_draw_line
  2078                                  
  2079                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2080                                      ; top left to bottom left
  2081                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2082 000009E7 B96900                      mov cx, 105
  2083 000009EA BFC638                      mov di, 14534
  2084 000009ED E890FF                      call procedure_draw_line_vertical
  2085                                      
  2086                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2087                                      ; top right to bottom right
  2088                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2089 000009F0 B96900                      mov cx, 105
  2090 000009F3 BFF938                      mov di, 14585
  2091 000009F6 E887FF                      call procedure_draw_line_vertical
  2092                                  
  2093                                  draw_screen_next_piece_area:
  2094                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2095                                      ; draw the box within which the next piece is displayed
  2096                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2097                                      
  2098                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2099                                      ; top left to top right
  2100                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2101 000009F9 BF473F                      mov di, 16199
  2102 000009FC B91F00                      mov cx, 31
  2103 000009FF E888FF                      call procedure_draw_line
  2104                                      
  2105                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2106                                      ; bottom left to bottom right
  2107                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2108 00000A02 BFC764                      mov di, 25799
  2109 00000A05 B91F00                      mov cx, 31
  2110 00000A08 E87FFF                      call procedure_draw_line
  2111                                      
  2112                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2113                                      ; top left to bottom left
  2114                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2115 00000A0B BF473F                      mov di, 16199
  2116 00000A0E B91F00                      mov cx, 31
  2117 00000A11 E86CFF                      call procedure_draw_line_vertical
  2118                                      
  2119                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2120                                      ; top right to bottom right
  2121                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2122 00000A14 BF663F                      mov di, 16230
  2123 00000A17 B91F00                      mov cx, 31
  2124 00000A1A E863FF                      call procedure_draw_line_vertical
  2125                                  
  2126                                  draw_screen_strings:
  2127                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2128                                      ; display author string
  2129                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2130 00000A1D B615                        mov dh, 21
  2131 00000A1F B204                        mov dl, 4
  2132 00000A21 BB[0300]                    mov bx, msg_author
  2133 00000A24 E854FC                      call procedure_print_at
  2134                                          
  2135                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2136                                      ; display "Next" string
  2137                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2138 00000A27 B60B                        mov dh, 11
  2139 00000A29 B219                        mov dl, 25
  2140 00000A2B BB[2400]                    mov bx, msg_next
  2141 00000A2E E84AFC                      call procedure_print_at
  2142                                      
  2143                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2144                                      ; display "left" string
  2145                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2146 00000A31 B608                        mov dh, 8
  2147 00000A33 B204                        mov dl, 4
  2148 00000A35 BB[2900]                    mov bx, msg_left
  2149 00000A38 E840FC                      call procedure_print_at
  2150                                      
  2151                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2152                                      ; display "right" string
  2153                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2154 00000A3B B60A                        mov dh, 10
  2155 00000A3D B204                        mov dl, 4
  2156 00000A3F BB[3200]                    mov bx, msg_right
  2157 00000A42 E836FC                      call procedure_print_at
  2158                                      
  2159                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2160                                      ; display "rotate" string
  2161                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2162 00000A45 B60C                        mov dh, 12
  2163 00000A47 B204                        mov dl, 4
  2164 00000A49 BB[3C00]                    mov bx, msg_rotate
  2165 00000A4C E82CFC                      call procedure_print_at
  2166                                      
  2167                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2168                                      ; display "fall" string
  2169                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2170 00000A4F B60E                        mov dh, 14
  2171 00000A51 B204                        mov dl, 4
  2172 00000A53 BB[8F00]                    mov bx, msg_fall
  2173 00000A56 E822FC                      call procedure_print_at
  2174                                      
  2175                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2176                                      ; display "quit" string
  2177                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2178 00000A59 B610                        mov dh, 16
  2179 00000A5B B204                        mov dl, 4
  2180 00000A5D BB[4900]                    mov bx, msg_quit
  2181 00000A60 E818FC                      call procedure_print_at
  2182                                      
  2183                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2184                                      ; display "Lines" string
  2185                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2186 00000A63 BB[5400]                    mov bx, msg_lines
  2187 00000A66 B610                        mov dh, 16
  2188 00000A68 B218                        mov dl, 24
  2189 00000A6A E80EFC                      call procedure_print_at
  2190                                      
  2191                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2192                                      ; display game name string
  2193                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2194 00000A6D BB[6400]                    mov bx, msg_asmtris
  2195 00000A70 B603                        mov dh, 3
  2196 00000A72 B210                        mov dl, 16
  2197 00000A74 E804FC                      call procedure_print_at
  2198                                      
  2199                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2200                                      ; display author string
  2201                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2202 00000A77 B616                        mov dh, 22
  2203 00000A79 B203                        mov dl, 3
  2204 00000A7B BB[6C00]                    mov bx, msg_author2
  2205 00000A7E E8FAFB                      call procedure_print_at
  2206 00000A81 C3                          ret
  2207                                  
  2208                                  
  2209                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2210                                  ;
  2211                                  ; Display the game's animated logo
  2212                                  ;
  2213                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2214                                  procedure_display_logo:
  2215                                  
  2216                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2217                                      ; redraw animated logo only once every four frames
  2218                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2219 00000A82 A1[AE04]                    mov word ax, [current_frame]
  2220 00000A85 83E003                      and ax, 3 ; ax := ax mod 4
  2221 00000A88 7401                        jz display_logo_begin
  2222                                      
  2223 00000A8A C3                          ret
  2224                                      
  2225                                  display_logo_begin:
  2226                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2227                                      ; start at the top left corner of where the logo will be rendered
  2228                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2229 00000A8B BF2913                      mov di, 4905
  2230                                      
  2231                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2232                                      ; for each of the 20 coloured squares on the horizontal
  2233                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2234 00000A8E B91400                      mov cx, 20
  2235                                  display_logo_horizontal_loop:
  2236                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2237                                      ; oscillate ax between 0 and 1 every 8 frames
  2238                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2239 00000A91 A1[AE04]                    mov word ax, [current_frame]    
  2240 00000A94 83E008                      and ax, 8
  2241 00000A97 C1E803                      shr ax, 3
  2242                                      
  2243                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2244                                      ; also use use whether di is even or odd to alternate; this works because
  2245                                      ; since we start with an odd value of di, and the size of each square is
  2246                                      ; also odd, then each alternating square will have alternating odd and even
  2247                                      ; values of di
  2248                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2249 00000A9A 01F8                        add ax, di
  2250 00000A9C 2401                        and al, 1
  2251                                      
  2252                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2253                                      ; we'll alternate between two colours in the palette which are eight slots
  2254                                      ; apart
  2255                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2256 00000A9E C0E003                      shl al, 3
  2257                                      
  2258                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2259                                      ; convert to colour (we'll use colours 192 and 200 alternating), then draw
  2260                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2261 00000AA1 04C0                        add al, 192
  2262 00000AA3 88C2                        mov dl, al
  2263 00000AA5 BB0500                      mov bx, 5
  2264 00000AA8 E8B7FE                      call procedure_draw_square
  2265                                      
  2266                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2267                                      ; save di, and then move to the square directly below, 
  2268                                      ; on the lower horizontal
  2269                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2270 00000AAB 57                          push di
  2271 00000AAC 81C70019                    add di, 6400
  2272                                      
  2273                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2274                                      ; draw a square with parameters other than position like on top horizontal
  2275                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2276 00000AB0 E8AFFE                      call procedure_draw_square
  2277                                      
  2278                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2279                                      ; restore di, advance to the next square to the right, and 
  2280                                      ; loop to process next square
  2281                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2282 00000AB3 5F                          pop di
  2283 00000AB4 01DF                        add di, bx
  2284 00000AB6 E2D9                        loop display_logo_horizontal_loop
  2285                                      
  2286                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2287                                      ; move back to the top left corner of where the logo will be rendered
  2288                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2289 00000AB8 BF2913                      mov di, 4905
  2290                                      
  2291                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2292                                      ; for each of the 5 coloured squares on the vertical
  2293                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2294 00000ABB B90500                      mov cx, 5
  2295                                  display_logo_vertical_loop:
  2296                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2297                                      ; oscillate ax between 0 and 1 every 8 frames, and save the binary value
  2298                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2299 00000ABE A1[AE04]                    mov word ax, [current_frame]    
  2300 00000AC1 83E008                      and ax, 8
  2301 00000AC4 C1E803                      shr ax, 3
  2302 00000AC7 50                          push ax
  2303                                      
  2304                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2305                                      ; since each vertical square is on a different 320 pixel wide horizontal
  2306                                      ; line, we can alternate colours based on the quotient of di/320
  2307                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2308                                      
  2309                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2310                                      ; divide di by 160
  2311                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2312 00000AC8 89F8                        mov ax, di
  2313 00000ACA B3A0                        mov bl, 160
  2314 00000ACC F6F3                        div bl
  2315                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2316                                      ; divide again by 2
  2317                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2318 00000ACE 30E4                        xor ah, ah
  2319 00000AD0 D1E8                        shr ax, 1
  2320                                      
  2321                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2322                                      ; quotient oscillates between odd and even; save that as 0 or 1 in al
  2323                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2324 00000AD2 2401                        and al, 1
  2325                                      
  2326                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2327                                      ; combine with the oscillating 0/1 value we calculated from current frame
  2328                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2329 00000AD4 5B                          pop bx
  2330 00000AD5 00D8                        add al, bl
  2331 00000AD7 2401                        and al, 1
  2332                                      
  2333                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2334                                      ; we'll alternate between two colours in the palette which are eight slots
  2335                                      ; apart
  2336                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2337 00000AD9 C0E003                      shl al, 3
  2338                                      
  2339                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2340                                      ; convert to colour (we'll use colours 192 and 200 alternating), then draw
  2341                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2342 00000ADC 04C0                        add al, 192
  2343 00000ADE 88C2                        mov dl, al
  2344 00000AE0 BB0500                      mov bx, 5
  2345 00000AE3 E87CFE                      call procedure_draw_square
  2346                                      
  2347                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2348                                      ; save di, and then move to the square directly to the right, 
  2349                                      ; on the right hand side vertical
  2350                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2351 00000AE6 57                          push di
  2352 00000AE7 83C764                      add di, 100    
  2353                                      
  2354                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2355                                      ; draw a square with parameters other than position like on 
  2356                                      ; the left hand side vertical
  2357                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2358 00000AEA E875FE                      call procedure_draw_square
  2359                                      
  2360                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2361                                      ; restore di, advance to the next square below, and 
  2362                                      ; loop to process next square
  2363                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2364 00000AED 5F                          pop di
  2365 00000AEE 81C74006                    add di, 1600
  2366 00000AF2 E2CA                        loop display_logo_vertical_loop
  2367                                      
  2368 00000AF4 C3                          ret
  2369                                      
  2370                                      
  2371                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2372                                  ;
  2373                                  ; Hide controls used during game play, and draw "game over" panel overlay
  2374                                  ;
  2375                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2376                                  procedure_display_game_over:
  2377                                  
  2378                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2379                                      ; hide left/right/rotate controls by drawing a black rectangle on top
  2380                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2381 00000AF5 30D2                        xor dl, dl
  2382 00000AF7 B82D00                      mov ax, 45
  2383 00000AFA BB6400                      mov bx, 100
  2384 00000AFD BF5E4C                      mov di, 19550
  2385 00000B00 E865FE                      call procedure_draw_rectangle
  2386                                  
  2387                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2388                                      ; draw "game over" panel
  2389                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2390 00000B03 B228                        mov dl, 40
  2391 00000B05 B81000                      mov ax, 16
  2392 00000B08 BB5800                      mov bx, 88
  2393 00000B0B BF7873                      mov di, 29560
  2394 00000B0E E857FE                      call procedure_draw_rectangle
  2395                                  
  2396                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2397                                      ; draw "game over" message
  2398                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2399 00000B11 B60C                        mov dh, 12
  2400 00000B13 B210                        mov dl, 16
  2401 00000B15 BB[5A00]                    mov bx, msg_game_over
  2402 00000B18 E860FB                      call procedure_print_at
  2403                                  
  2404 00000B1B B60E                        mov dh, 14
  2405 00000B1D B204                        mov dl, 4
  2406 00000B1F BB[9800]                    mov bx, msg_reset
  2407 00000B22 E856FB                      call procedure_print_at
  2408                                      
  2409 00000B25 C3                          ret
  2410                                      
