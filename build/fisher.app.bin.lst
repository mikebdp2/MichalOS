     1                                  ;=====================================================================
     2                                  ;
     3                                  ;   Deep Sea Fisher
     4                                  ;   
     5                                  ;   Written by Jasper Ziller (jziller@maine.rr.com)
     6                                  ;   Version 1.0
     7                                  ;
     8                                  ;   Try to Catch as many fish as possible before loosing all 10 hooks
     9                                  ;      
    10                                  ;   The behavior of a fish can be altered by changing the behavior
    11                                  ;   byte bit mask in the object array.  This value is anded with a
    12                                  ;   one byte counter which is incremented each time through the game
    13                                  ;   loop.  If the result is 0, the fish does not move that cycle.
    14                                  ;
    15                                  ;   The value of the fish is also set in the object array 
    16                                  ;
    17                                  ;=====================================================================
    18                                  
    19                                  %define reclen  8        ;object table record length
    20                                  %define hlimit  12       ;max hook can be from boat
    21                                  %define obcnt   12       ;count of total objects in array
    22                                  %define fishcnt 10       ;number of fish
    23                                  
    24                                  ;---------------------------------------------
    25                                  ;Change these to position the Catch Log window
    26                                  ; upper left corner: col 19, row 4 default
    27                                  
    28                                  %define lbcol 19        ;col        
    29                                  %define lbrow 4         ;row
    30                                  
    31                                  ;--------------------------------
    32                                  
    33                                  ;do not change these
    34                                  %define lbwidth 42      ;width
    35                                  %define lbbot lbrow+18  ;height
    36                                  
    37                                  
    38                                  
    39                                          %include "include/program.inc" ;MikeOS Include file
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; Include file for MichalOS program or kernel module development
     3                              <1> ; ------------------------------------------------------------------
     4                              <1> 
     5                              <1> 	BITS 16
     6                              <1> 	ORG 100h
     7                              <1> 	
     8                              <1> 	%include "include/constants.asm"
     1                              <2> ; ------------------------------------------------------------------
     2                              <2> ; Include file for MichalOS kernel/program development - constants & macros
     3                              <2> ; ------------------------------------------------------------------
     4                              <2> 
     5                              <2> ; ------------------------------------------------------------------
     6                              <2> ; COLOURS (eg for os_draw_background and os_draw_block)
     7                              <2> 
     8                              <2> %DEFINE BLACK_ON_WHITE		11110000b
     9                              <2> %DEFINE WHITE_ON_BLACK		00001111b
    10                              <2> 
    11                              <2> ; ------------------------------------------------------------------
    12                              <2> ; KEYS
    13                              <2> 
    14                              <2> %DEFINE KEY_UP		72
    15                              <2> %DEFINE KEY_DOWN	80
    16                              <2> %DEFINE KEY_LEFT	75
    17                              <2> %DEFINE KEY_RIGHT	77
    18                              <2> 
    19                              <2> %DEFINE KEY_ESC		27
    20                              <2> %DEFINE KEY_ENTER	13
    21                              <2> 
    22                              <2> ; ------------------------------------------------------------------
    23                              <2> ; MACROS
    24                              <2> 
    25                              <2> %macro syscall 1
    26                              <2> 	mov bp, %1
    27                              <2> 	call os_syscall
    28                              <2> %endmacro
    29                              <2> 
    30                              <2> %macro clr 1
    31                              <2> 	xor %1, %1
    32                              <2> %endmacro
    33                              <2> 
    34                              <2> %macro mov16 3
    35                              <2> 	mov %1, (%2 + %3 * 256)
    36                              <2> %endmacro
    37                              <2> 
    38                              <2> %macro movs 2
    39                              <2> 	push %2
    40                              <2> 	pop %1
    41                              <2> %endmacro
    42                              <2> 
    43                              <2> ; ------------------------------------------------------------------
    44                              <2> ; MEMORY LOCATIONS
    45                              <2> 
    46                              <2> %define ADLIB_BUFFER 0500h
    47                              <2> %define DESKTOP_BACKGROUND 0600h
    48                              <2> %define SYSTEM_FONT 1600h
    49                              <2> %define FILE_MANAGER 2600h
    50                              <2> %define DISK_PARAMS 2E00h
    51                              <2> 
    52                              <2> %define DISK_BUFFER 0E000h
    53                              <2> %define CONFIG_FILE 57000
    54                              <2> %define CONFIG_FILE_SIZE 83
    55                              <2> 
    56                              <2> ; ------------------------------------------------------------------
    57                              <2> ; CONFIG FILE LOCATIONS
    58                              <2> 
    59                              <2> %define CONFIG(x) (CONFIG_FILE + x)
    60                              <2> 
    61                              <2> ; 0 = Desktop background color (BYTE)
    62                              <2> %define CONFIG_DESKTOP_BG_COLOR CONFIG(0)
    63                              <2> 
    64                              <2> ; 1 = Window background color (BYTE)
    65                              <2> %define CONFIG_WINDOW_BG_COLOR CONFIG(1)
    66                              <2> 
    67                              <2> ; 2 = Password enabled (BYTE)
    68                              <2> %define CONFIG_PASSWORD_ENABLED CONFIG(2)
    69                              <2> 
    70                              <2> ; 3 - 35 = Password data (STRING, 32 chars + '\0')
    71                              <2> %define CONFIG_PASSWORD CONFIG(3)
    72                              <2> %define CFG_PASSWORD_MAX_INPUT_LENGTH 32
    73                              <2> %define CFG_PASSWORD_MAX_LENGTH 33
    74                              <2> 
    75                              <2> ; 36 - 68 = Username (STRING, 32 chars + '\0')
    76                              <2> %define CONFIG_USERNAME CONFIG(36)
    77                              <2> %define CFG_USERNAME_MAX_INPUT_LENGTH 32
    78                              <2> %define CFG_USERNAME_MAX_LENGTH 33
    79                              <2> 
    80                              <2> ; 69 - Sound enabled on startup (BYTE)
    81                              <2> %define CONFIG_SOUND_ENABLED CONFIG(69)
    82                              <2> 
    83                              <2> ; 70 - Adlib driver number
    84                              <2> %define CONFIG_ADLIB_DRIVER CONFIG(70)
    85                              <2> %define CFG_ADLIB_STD_DRIVER 0
    86                              <2> %define CFG_ADLIB_PWM_DRIVER 1
    87                              <2> %define CFG_ADLIB_PWM_LOUD_DRIVER 2
    88                              <2> 
    89                              <2> ; 71 - Menu screen dimming enabled (BYTE)
    90                              <2> %define CONFIG_MENU_DIMMING CONFIG(71)
    91                              <2> 
    92                              <2> ; 72 - Menu color (BYTE)
    93                              <2> %define CONFIG_MENU_BG_COLOR CONFIG(72)
    94                              <2> 
    95                              <2> ; 73 - "DOS" font enabled (BYTE)
    96                              <2> %define CONFIG_FONT CONFIG(73)
    97                              <2> %define CFG_FONT_MICHALOS 0
    98                              <2> %define CFG_FONT_BIOS 1
    99                              <2> 
   100                              <2> ; 74 - Minutes to wait for screensaver (BYTE)
   101                              <2> %define CONFIG_SCREENSAVER_MINUTES CONFIG(74)
   102                              <2> 
   103                              <2> ; 75 - System stack size in 16-byte blocks (WORD)
   104                              <2> %define CONFIG_STACKSGMT_SIZE CONFIG(75)
   105                              <2> 
   106                              <2> ; 77 - 80 - Unused *******************************
   107                              <2> 
   108                              <2> ; 81 - Minute time offset (WORD)
   109                              <2> %define CONFIG_TIMEZONE_OFFSET CONFIG(81)
   110                              <2> 
   111                              <2> ; ------------------------------------------------------------------
   112                              <2> ; MUSICAL NOTE FREQUENCY LIST
   113                              <2> 
   114                              <2> A2		equ 110
   115                              <2> AS2		equ 117
   116                              <2> B2		equ 124
   117                              <2> C3		equ 131
   118                              <2> CS3		equ 139
   119                              <2> D3		equ 147
   120                              <2> DS3		equ 156
   121                              <2> E3		equ 165
   122                              <2> F3		equ 175
   123                              <2> FS3		equ 185
   124                              <2> G3		equ 196
   125                              <2> GS3		equ 208
   126                              <2> A3		equ 220
   127                              <2> AS3		equ 233
   128                              <2> B3		equ 247
   129                              <2> C4		equ 262
   130                              <2> CS4		equ 277
   131                              <2> D4		equ 294
   132                              <2> DS4		equ 311
   133                              <2> E4		equ 330
   134                              <2> F4		equ 349
   135                              <2> FS4		equ 370
   136                              <2> G4		equ 392
   137                              <2> GS4		equ 415
   138                              <2> A4		equ 440
   139                              <2> AS4		equ 466
   140                              <2> B4		equ 494
   141                              <2> C5		equ 523
   142                              <2> CS5		equ 554
   143                              <2> D5		equ 587
   144                              <2> DS5		equ 622
   145                              <2> E5		equ 659
   146                              <2> F5		equ 698
   147                              <2> FS5		equ 740
   148                              <2> G5		equ 784
   149                              <2> GS5		equ 831
   150                              <2> A5		equ 880
   151                              <2> AS5		equ 932
   152                              <2> B5		equ 988
   153                              <2> C6		equ 1046
   154                              <2> CS6		equ 1109
   155                              <2> D6		equ 1175
   156                              <2> DS6		equ 1245
   157                              <2> E6		equ 1319
   158                              <2> F6		equ 1397
   159                              <2> FS6		equ 1480
   160                              <2> G6		equ 1568
   161                              <2> GS6		equ 1661
   162                              <2> A6		equ 1760
   163                              <2> AS6		equ 1865
   164                              <2> B6		equ 1976
   165                              <2> C7		equ 2093
   166                              <2> CS7		equ 2217
   167                              <2> D7		equ 2349
   168                              <2> DS7		equ 2489
   169                              <2> E7		equ 2637
   170                              <2> F7		equ 2794
   171                              <2> FS7		equ 2960
   172                              <2> G7		equ 3136
   173                              <2> GS7		equ 3322
   174                              <2> A7		equ 3520
   175                              <2> AS7		equ 3729
   176                              <2> B7		equ 3951
   177                              <2> C8		equ 4186
   178                              <2> CS8		equ 4435
   179                              <2> D8		equ 4699
   180                              <2> DS8		equ 4978
   181                              <2> E8		equ 5274
   182                              <2> F8		equ 5588
   183                              <2> FS8		equ 5920
   184                              <2> G8		equ 6272
   185                              <2> GS8		equ 6645
   186                              <2> A8		equ 7040
   187                              <2> AS8		equ 7459
   188                              <2> B8		equ 7902
     9                              <1> 	%include "include/syscalls.asm"
     1                              <2> ; ------------------------------------------------------------------
     2                              <2> ; Include file for MichalOS program development - syscalls
     3                              <2> ; ------------------------------------------------------------------
     4                              <2> 
     5                              <2> ; ==================================================================
     6                              <2> ; MichalOS Sound functions (PC speaker, YM3812)
     7                              <2> ; ==================================================================
     8                              <2> 
     9                              <2> ; ------------------------------------------------------------------
    10                              <2> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
    11                              <2> ; IN: AX = note frequency (in Hz)
    12                              <2> ; OUT: None, registers preserved
    13                              <2> 
    14                              <2> os_speaker_tone equ 32795
    15                              <2> 
    16                              <2> ; ------------------------------------------------------------------
    17                              <2> ; os_speaker_raw_period -- Generate PC speaker tone (call os_speaker_off to turn off)
    18                              <2> ; IN: AX = note period (= 105000000 / 88 / freq)
    19                              <2> ; OUT: None, registers preserved
    20                              <2> 
    21                              <2> os_speaker_raw_period equ 33107
    22                              <2> 
    23                              <2> ; ------------------------------------------------------------------
    24                              <2> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
    25                              <2> ; IN: AX = note frequency, CX = length (in ticks)
    26                              <2> ; OUT: None, registers preserved
    27                              <2> 
    28                              <2> os_speaker_note_length equ 32900
    29                              <2> 
    30                              <2> ; ------------------------------------------------------------------
    31                              <2> ; os_speaker_off -- Turn off PC speaker
    32                              <2> ; IN/OUT: None, registers preserved
    33                              <2> 
    34                              <2> os_speaker_off equ 32798
    35                              <2> 
    36                              <2> ; ------------------------------------------------------------------
    37                              <2> ; os_speaker_muted -- Check if the PC speaker is muted
    38                              <2> ; OUT: ZF set if muted, clear if not
    39                              <2> 
    40                              <2> os_speaker_muted equ 33125
    41                              <2> 
    42                              <2> ; ------------------------------------------------------------------
    43                              <2> ; os_start_adlib -- Starts the selected Adlib driver
    44                              <2> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
    45                              <2> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
    46                              <2> ; Common prescaler values:
    47                              <2> ;		33 = ~1 kHz (1004.362 Hz)
    48                              <2> ;		663 = ~50 Hz (49.991 Hz)
    49                              <2> ;		1820 = ~18.2 Hz (18.211 Hz)
    50                              <2> ; OUT: None, registers preserved
    51                              <2> 
    52                              <2> os_start_adlib equ 32984
    53                              <2> 
    54                              <2> ; ------------------------------------------------------------------
    55                              <2> ; os_stop_adlib -- Stops the Adlib driver
    56                              <2> ; IN/OUT: None, registers preserved
    57                              <2> 
    58                              <2> os_stop_adlib equ 33026
    59                              <2> 
    60                              <2> ; ------------------------------------------------------------------
    61                              <2> ; os_adlib_regwrite -- Write to a YM3812 register
    62                              <2> ; IN: AH/AL - register address/value to write
    63                              <2> 
    64                              <2> os_adlib_regwrite equ 32843
    65                              <2> 
    66                              <2> ; ------------------------------------------------------------------
    67                              <2> ; os_adlib_mute -- Mute the YM3812's current state
    68                              <2> ; IN/OUT: None
    69                              <2> 
    70                              <2> os_adlib_mute equ 33044
    71                              <2> 
    72                              <2> ; ------------------------------------------------------------------
    73                              <2> ; os_adlib_unmute -- Unmute the YM3812's current state
    74                              <2> ; IN/OUT: None
    75                              <2> 
    76                              <2> os_adlib_unmute equ 33089
    77                              <2> 
    78                              <2> ; ------------------------------------------------------------------
    79                              <2> ; os_adlib_calcfreq -- Play a frequency
    80                              <2> ; IN: AX - frequency, CL = channel
    81                              <2> ; OUT: None, registers preserved
    82                              <2> 
    83                              <2> os_adlib_calcfreq equ 32966
    84                              <2> 
    85                              <2> ; ------------------------------------------------------------------
    86                              <2> ; os_adlib_noteoff -- Turns off a note
    87                              <2> ; IN: CL = channel
    88                              <2> ; OUT: None, registers preserved
    89                              <2> 
    90                              <2> os_adlib_noteoff equ 33029
    91                              <2> 
    92                              <2> ; ==================================================================
    93                              <2> ; MichalOS Text display output functions
    94                              <2> ; ==================================================================
    95                              <2> 
    96                              <2> ; ------------------------------------------------------------------
    97                              <2> ; os_putchar -- Puts a character on the screen
    98                              <2> ; IN: AL = character
    99                              <2> ; OUT: None, registers preserved
   100                              <2> 
   101                              <2> os_putchar equ 32981
   102                              <2> 
   103                              <2> ; ------------------------------------------------------------------
   104                              <2> ; os_put_chars -- Puts up to a set amount of characters on the screen
   105                              <2> ; IN: BL = terminator, DS:SI = location, CX = character count
   106                              <2> ; OUT: None, registers preserved
   107                              <2> 
   108                              <2> os_put_chars equ 32996
   109                              <2> 
   110                              <2> ; ------------------------------------------------------------------
   111                              <2> ; os_print_string -- Displays text
   112                              <2> ; IN: DS:SI = message location (zero-terminated string)
   113                              <2> ; OUT: None, registers preserved
   114                              <2> 
   115                              <2> os_print_string equ 32771
   116                              <2> 
   117                              <2> ; ------------------------------------------------------------------
   118                              <2> ; os_print_string_box -- Displays text inside a text-box.
   119                              <2> ; IN: DS:SI = message location (zero-terminated string), DL = left alignment
   120                              <2> ; OUT: None, registers preserved
   121                              <2> 
   122                              <2> os_print_string_box equ 32993
   123                              <2> 
   124                              <2> ; ------------------------------------------------------------------
   125                              <2> ; os_format_string -- Displays colored text
   126                              <2> ; IN: DS:SI = message location (zero-terminated string), BL = text color
   127                              <2> ; OUT: None, registers preserved
   128                              <2> 
   129                              <2> os_format_string equ 32978
   130                              <2> 
   131                              <2> ; ------------------------------------------------------------------
   132                              <2> ; os_clear_screen -- Clears the screen to background
   133                              <2> ; IN/OUT: None, registers preserved
   134                              <2> 
   135                              <2> os_clear_screen equ 32777
   136                              <2> 
   137                              <2> ; ------------------------------------------------------------------
   138                              <2> ; os_move_cursor -- Moves cursor in text mode
   139                              <2> ; IN: DH, DL = row, column
   140                              <2> ; OUT: None, registers preserved
   141                              <2> 
   142                              <2> os_move_cursor equ 32774
   143                              <2> 
   144                              <2> ; ------------------------------------------------------------------
   145                              <2> ; os_get_cursor_pos -- Return position of text cursor
   146                              <2> ; IN: None
   147                              <2> ; OUT: DH, DL = row, column
   148                              <2> 
   149                              <2> os_get_cursor_pos equ 32870
   150                              <2> 
   151                              <2> ; ------------------------------------------------------------------
   152                              <2> ; os_show_cursor -- Turns on cursor in text mode
   153                              <2> ; IN/OUT: None, registers preserved
   154                              <2> 
   155                              <2> os_show_cursor equ 32903
   156                              <2> 
   157                              <2> ; ------------------------------------------------------------------
   158                              <2> ; os_hide_cursor -- Turns off cursor in text mode
   159                              <2> ; IN/OUT: None, registers preserved
   160                              <2> 
   161                              <2> os_hide_cursor equ 32906
   162                              <2> 
   163                              <2> ; ------------------------------------------------------------------
   164                              <2> ; os_draw_block -- Render block of specified colour
   165                              <2> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   166                              <2> ; OUT: None, registers preserved
   167                              <2> 
   168                              <2> os_draw_block equ 32945
   169                              <2> 
   170                              <2> ; ------------------------------------------------------------------
   171                              <2> ; os_file_selector -- Show a file selection dialog
   172                              <2> ; IN: None
   173                              <2> ; OUT: AX = location of filename string (or carry set if Esc pressed)
   174                              <2> 
   175                              <2> os_file_selector equ 32855
   176                              <2> 
   177                              <2> ; ------------------------------------------------------------------
   178                              <2> ; os_file_selector_filtered -- Show a file selection dialog only 
   179                              <2> ; with files mathing the filter
   180                              <2> ; IN: ES:BX = location of file extension list (0 if none)
   181                              <2> ; OUT: DS:AX = location of filename string (or carry set if Esc pressed)
   182                              <2> 
   183                              <2> os_file_selector_filtered equ 33122
   184                              <2> 
   185                              <2> ; ------------------------------------------------------------------
   186                              <2> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
   187                              <2> ; That means, when the user changes the selection, the application will be called back
   188                              <2> ; to change the tooltip's contents.
   189                              <2> ; IN: DS:AX = comma-separated list of strings to show (zero-terminated),
   190                              <2> ;     DS:BX = first help string, DS:CX = second help string
   191                              <2> ;     SI = key/display callback (see os_list_dialog_ex)
   192                              <2> ;     if AX = 0: DI = entry display callback, DX = number of entries
   193                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   194                              <2> 
   195                              <2> os_list_dialog_tooltip equ 32912
   196                              <2> 
   197                              <2> ; ------------------------------------------------------------------
   198                              <2> ; os_list_dialog -- Show a dialog with a list of options
   199                              <2> ; IN: ES:AX = comma-separated list of strings to show (zero-terminated),
   200                              <2> ;     ES:BX = first help string, ES:CX = second help string
   201                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   202                              <2> 
   203                              <2> os_list_dialog equ 32936
   204                              <2> 
   205                              <2> ; ------------------------------------------------------------------
   206                              <2> ; os_list_dialog_ex -- Show a dialog with a list of options
   207                              <2> ; IN: DS:BX = pointer to setup struct
   208                              <2> ;       Addr Size Description
   209                              <2> ;       000h word Pointer to entry display callback (accepts CX as entry ID, prints out result) - valid only if ptr to list is zero
   210                              <2> ;       002h word Pointer to comma-separated list of strings to show (zero-terminated)
   211                              <2> ;       004h word Pointer to key/entry change callback (accepts AX as entry ID, CX as keypress),
   212                              <2> ;       006h word Number of entries (if 0, then it is automatically calculated from 002h)
   213                              <2> ;       008h word Pointer to first help string (if 0, then the list will fill the whole dialog)
   214                              <2> ;       00Ah word Pointer to second help string
   215                              <2> ;       00Ch word (ES) Pointer to history data (points to a 5 byte array)
   216                              <2> ;       00Eh byte Screen X position
   217                              <2> ;       00Fh byte Screen Y position
   218                              <2> ;       010h byte Dialog width
   219                              <2> ;       011h byte Dialog height
   220                              <2> ;       012h word Source segment (used for comma-separated list & help strings)
   221                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   222                              <2> 
   223                              <2> os_list_dialog_ex equ 33113
   224                              <2> 
   225                              <2> ; ------------------------------------------------------------------
   226                              <2> ; os_select_list -- Draws a list of entries (defined by a callback) to select from.
   227                              <2> ; IN: AX = width/height, BL = color, CX = number of entries, DX = X/Y pos,
   228                              <2> ;     SI = callback (if C clear = accepts an entry ID in CX, prints an appropriate string,
   229                              <2> ;     if C set = accepts key input in AX, entry ID in CX; not required to preserve regs),
   230                              <2> ;     ES:DI = pointer to a history struct (word .num_of_entries, word .skip_num, byte .cursor) or 0 if none
   231                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   232                              <2> 
   233                              <2> os_select_list equ 33110
   234                              <2> 
   235                              <2> ; ------------------------------------------------------------------
   236                              <2> ; os_draw_background -- Clear screen with white top and bottom bars
   237                              <2> ; containing text, and a coloured middle section.
   238                              <2> ; IN: DS:AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
   239                              <2> ; OUT: None, registers preserved
   240                              <2> 
   241                              <2> os_draw_background equ 32807
   242                              <2> 
   243                              <2> ; ------------------------------------------------------------------
   244                              <2> ; os_print_newline -- Reset cursor to start of next line
   245                              <2> ; IN/OUT: None, registers preserved
   246                              <2> 
   247                              <2> os_print_newline equ 32783
   248                              <2> 
   249                              <2> ; ------------------------------------------------------------------
   250                              <2> ; os_dump_registers -- Dumps all register contents in hex to the screen
   251                              <2> ; IN: All registers
   252                              <2> ; OUT: None, registers preserved
   253                              <2> 
   254                              <2> os_dump_registers equ 32909
   255                              <2> 
   256                              <2> ; ------------------------------------------------------------------
   257                              <2> ; os_input_dialog -- Get text string from user via a dialog box
   258                              <2> ; IN: ES:AX = string location, DS:BX = message to show
   259                              <2> ; OUT: None, registers preserved
   260                              <2> 
   261                              <2> os_input_dialog equ 32933
   262                              <2> 
   263                              <2> ; ------------------------------------------------------------------
   264                              <2> ; os_password_dialog -- Get a password from user via a dialog box
   265                              <2> ; IN: ES:AX = string location, DS:BX = message to show
   266                              <2> ; OUT: None, registers preserved
   267                              <2> 
   268                              <2> os_password_dialog equ 33041
   269                              <2> 
   270                              <2> ; ------------------------------------------------------------------
   271                              <2> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
   272                              <2> ; IN: DS:AX, DS:BX, DS:CX = string locations (set registers to 0 for no display),
   273                              <2> ; IN: DX = 0 for single 'OK' dialog,
   274                              <2> ;          1 for two-button 'OK' and 'Cancel' ('OK' selected by default),
   275                              <2> ;          2 for two-button 'OK' and 'Cancel' ('Cancel' selected by default)
   276                              <2> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   277                              <2> ; NOTE: Each string is limited to 40 characters
   278                              <2> 
   279                              <2> os_dialog_box equ 32825
   280                              <2> 
   281                              <2> ; ------------------------------------------------------------------
   282                              <2> ; os_print_space -- Print a space to the screen
   283                              <2> ; IN/OUT: None, registers preserved
   284                              <2> 
   285                              <2> os_print_space equ 32873
   286                              <2> 
   287                              <2> ; ------------------------------------------------------------------
   288                              <2> ; os_print_digit -- Displays contents of AX as a single digit
   289                              <2> ; Works up to base 37, ie digits 0-Z
   290                              <2> ; IN: AX = "digit" to format and print
   291                              <2> ; OUT: None, registers preserved
   292                              <2> 
   293                              <2> os_print_digit equ 32879
   294                              <2> 
   295                              <2> ; ------------------------------------------------------------------
   296                              <2> ; os_print_1hex -- Displays low nibble of AL in hex format
   297                              <2> ; IN: AL = number to format and print
   298                              <2> ; OUT: None, registers preserved
   299                              <2> 
   300                              <2> os_print_1hex equ 32882
   301                              <2> 
   302                              <2> ; ------------------------------------------------------------------
   303                              <2> ; os_print_2hex -- Displays AL in hex format
   304                              <2> ; IN: AL = number to format and print
   305                              <2> ; OUT: None, registers preserved
   306                              <2> 
   307                              <2> os_print_2hex equ 32885
   308                              <2> 
   309                              <2> ; ------------------------------------------------------------------
   310                              <2> ; os_print_4hex -- Displays AX in hex format
   311                              <2> ; IN: AX = number to format and print
   312                              <2> ; OUT: None, registers preserved
   313                              <2> 
   314                              <2> os_print_4hex equ 32888
   315                              <2> 
   316                              <2> ; ------------------------------------------------------------------
   317                              <2> ; os_print_8hex - Displays EAX in hex format
   318                              <2> ; IN: EAX = unsigned integer
   319                              <2> ; OUT: None, registers preserved
   320                              <2> 
   321                              <2> os_print_8hex equ 33065
   322                              <2> 
   323                              <2> ; ------------------------------------------------------------------
   324                              <2> ; os_print_int -- Prints an integer in decimal.
   325                              <2> ; IN: AX = unsigned integer
   326                              <2> ; OUT: None, registers preserved
   327                              <2> 
   328                              <2> os_print_int equ 33101
   329                              <2> 
   330                              <2> ; ------------------------------------------------------------------
   331                              <2> ; os_print_32int -- Prints a 32 bit integer in decimal.
   332                              <2> ; IN: EAX = unsigned integer
   333                              <2> ; OUT: None, registers preserved
   334                              <2> 
   335                              <2> os_print_32int equ 32951
   336                              <2> 
   337                              <2> ; ------------------------------------------------------------------
   338                              <2> ; os_input_string -- Take string from keyboard entry
   339                              <2> ; IN: ES:AX = location of string
   340                              <2> ; OUT: None, registers preserved
   341                              <2> 
   342                              <2> os_input_string equ 32819
   343                              <2> 
   344                              <2> ; ------------------------------------------------------------------
   345                              <2> ; os_input_password -- Take password from keyboard entry
   346                              <2> ; IN: ES:AX = location of string
   347                              <2> ; OUT: None, registers preserved
   348                              <2> 
   349                              <2> os_input_password equ 33077
   350                              <2> 
   351                              <2> ; ------------------------------------------------------------------
   352                              <2> ; os_set_max_input_length -- Set the maximum length for the next string input
   353                              <2> ; IN: AL = maximum number of characters
   354                              <2> ; OUT: None, registers preserved
   355                              <2> 
   356                              <2> os_set_max_input_length equ 33131
   357                              <2> 
   358                              <2> ; ------------------------------------------------------------------
   359                              <2> ; os_input_string_ex -- Take string from keyboard entry
   360                              <2> ; IN: ES:AX = location of string, CH = 0 if normal input, 1 if password input,
   361                              <2> ;     DS:SI = callback on keys where AL = 0 (input: AX = keypress)
   362                              <2> ; OUT: None, registers preserved
   363                              <2> 
   364                              <2> os_input_string_ex equ 33119
   365                              <2> 
   366                              <2> ; ------------------------------------------------------------------
   367                              <2> ; os_color_selector - Pops up a color selector.
   368                              <2> ; IN: None
   369                              <2> ; OUT: color number (0-15)
   370                              <2> 
   371                              <2> os_color_selector equ 33053
   372                              <2> 
   373                              <2> ; ------------------------------------------------------------------
   374                              <2> ; os_temp_box -- Draws a dialog box with up to 5 lines of text.
   375                              <2> ; IN: DS:SI/AX/BX/CX/DX = string locations (or 0 for no display)
   376                              <2> ; OUT: None, registers preserved
   377                              <2> 
   378                              <2> os_temp_box equ 33086
   379                              <2> 
   380                              <2> ; ------------------------------------------------------------------
   381                              <2> ; os_reset_font -- Resets the font to the selected default.
   382                              <2> ; IN/OUT = None, registers preserved
   383                              <2> 
   384                              <2> os_reset_font equ 32990
   385                              <2> 
   386                              <2> ; ------------------------------------------------------------------
   387                              <2> ; os_draw_logo -- Draws the MichalOS logo.
   388                              <2> ; IN: None
   389                              <2> ; OUT: A very beautiful logo :-)
   390                              <2> 
   391                              <2> os_draw_logo equ 32852
   392                              <2> 
   393                              <2> ; ------------------------------------------------------------------
   394                              <2> ; os_draw_icon -- Draws an icon (in the MichalOS format).
   395                              <2> ; IN: DS:SI = address of the icon
   396                              <2> ; OUT: None, registers preserved
   397                              <2> 
   398                              <2> os_draw_icon equ 33023
   399                              <2> 
   400                              <2> ; ------------------------------------------------------------------
   401                              <2> ; os_option_menu -- Show a menu with a list of options
   402                              <2> ; IN: AX = comma-separated list of strings to show (zero-terminated)
   403                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
   404                              <2> 
   405                              <2> os_option_menu equ 32876
   406                              <2> 
   407                              <2> ; ==================================================================
   408                              <2> ; MichalOS Graphics functions
   409                              <2> ; Some graphics routines have been borrowed from TachyonOS
   410                              <2> ; ==================================================================
   411                              <2> 
   412                              <2> ; ------------------------------------------------------------------
   413                              <2> ; os_init_graphics_mode -- Initializes graphics mode.
   414                              <2> ; IN/OUT: None, registers preserved
   415                              <2> 
   416                              <2> os_init_graphics_mode equ 33020
   417                              <2> 
   418                              <2> ; ------------------------------------------------------------------
   419                              <2> ; os_init_text_mode -- Deinitializes graphics mode.
   420                              <2> ; IN/OUT: None, registers preserved
   421                              <2> 
   422                              <2> os_init_text_mode equ 33095
   423                              <2> 
   424                              <2> ; ------------------------------------------------------------------
   425                              <2> ; os_set_pixel -- Sets a pixel on the screen to a given value.
   426                              <2> ; IN: ES = destination memory segment, CX = X coordinate, AX = Y coordinate, BL = color
   427                              <2> ; OUT: None, registers preserved
   428                              <2> 
   429                              <2> os_set_pixel equ 33017
   430                              <2> 
   431                              <2> ; ------------------------------------------------------------------
   432                              <2> ; os_draw_line -- Draws a line with the Bresenham's line algorithm.
   433                              <2> ; Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
   434                              <2> ; IN: ES = destination memory segment, CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
   435                              <2> ; OUT: None, registers preserved
   436                              <2> 
   437                              <2> os_draw_line equ 32999
   438                              <2> 
   439                              <2> ; ------------------------------------------------------------------
   440                              <2> ; os_draw_rectangle -- Draws a rectangle.
   441                              <2> ; IN: ES = destination memory segment, CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
   442                              <2> ; OUT: None, registers preserved
   443                              <2> 
   444                              <2> os_draw_rectangle equ 33047
   445                              <2> 
   446                              <2> ; ------------------------------------------------------------------
   447                              <2> ; os_draw_polygon -- Draws a freeform shape.
   448                              <2> ; IN: ES = destination memory segment, BH = number of points, BL = colour, SI = location of shape points data
   449                              <2> ; OUT: None, registers preserved
   450                              <2> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
   451                              <2> 
   452                              <2> os_draw_polygon equ 33002
   453                              <2> 
   454                              <2> ; ------------------------------------------------------------------
   455                              <2> ; os_clear_graphics -- Clears the graphics screen with a given color.
   456                              <2> ; IN: ES = destination memory segment, BL = colour to set
   457                              <2> ; OUT: None, registers preserved
   458                              <2> 
   459                              <2> os_clear_graphics equ 33008
   460                              <2> 
   461                              <2> ; ----------------------------------------
   462                              <2> ; os_draw_circle -- draw a circular shape
   463                              <2> ; IN: ES = destination memory segment, AL = colour, BX = radius, CX = middle X, DX = middle y
   464                              <2> ; OUT: None, registers preserved
   465                              <2> 
   466                              <2> os_draw_circle equ 33005
   467                              <2> 
   468                              <2> ; ==================================================================
   469                              <2> ; MichalOS Keyboard input handling functions
   470                              <2> ; ==================================================================
   471                              <2> 
   472                              <2> ; ------------------------------------------------------------------
   473                              <2> ; os_wait_for_key -- Waits for keypress and returns key
   474                              <2> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
   475                              <2> ; IN: None
   476                              <2> ; OUT: AX = key pressed, other regs preserved
   477                              <2> 
   478                              <2> os_wait_for_key equ 32786
   479                              <2> 
   480                              <2> ; ------------------------------------------------------------------
   481                              <2> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   482                              <2> ; Also handles special keyboard shortcuts.
   483                              <2> ; IN: None
   484                              <2> ; OUT: AX = 0 if no key pressed, otherwise scan code
   485                              <2> 
   486                              <2> os_check_for_key equ 32789
   487                              <2> 
   488                              <2> ; ==================================================================
   489                              <2> ; MichalOS Port I/O functions
   490                              <2> ; ==================================================================
   491                              <2> 
   492                              <2> ; ------------------------------------------------------------------
   493                              <2> ; os_serial_port_enable -- Set up the serial port for transmitting data
   494                              <2> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
   495                              <2> ; OUT: None, registers preserved
   496                              <2> 
   497                              <2> os_serial_port_enable equ 32954
   498                              <2> 
   499                              <2> ; ------------------------------------------------------------------
   500                              <2> ; os_send_via_serial -- Send a byte via the serial port
   501                              <2> ; IN: AL = byte to send via serial
   502                              <2> ; OUT: AH = Bit 7 clear on success
   503                              <2> 
   504                              <2> os_send_via_serial equ 32861
   505                              <2> 
   506                              <2> ; ------------------------------------------------------------------
   507                              <2> ; os_get_via_serial -- Get a byte from the serial port
   508                              <2> ; IN: None
   509                              <2> ; OUT: AL = byte that was received, AH = Bit 7 clear on success
   510                              <2> 
   511                              <2> os_get_via_serial equ 32864
   512                              <2> 
   513                              <2> ; ==================================================================
   514                              <2> ; MichalOS Disk access functions
   515                              <2> ; ==================================================================
   516                              <2> 
   517                              <2> ; ------------------------------------------------------------------
   518                              <2> ; os_report_free_space -- Returns the amount of free space on disk
   519                              <2> ; IN: None
   520                              <2> ; OUT: AX = Number of sectors free
   521                              <2> 
   522                              <2> os_report_free_space equ 32894
   523                              <2> 
   524                              <2> ; ------------------------------------------------------------------
   525                              <2> ; os_get_file_list -- Generate comma-separated string of files on floppy
   526                              <2> ; IN/OUT: AX = location to store zero-terminated filename string
   527                              <2> 
   528                              <2> os_get_file_list equ 32831
   529                              <2> 
   530                              <2> ; ------------------------------------------------------------------
   531                              <2> ; os_load_file -- Load a file into RAM
   532                              <2> ; IN: AX = location of filename, ES:CX = location in RAM to load file
   533                              <2> ; OUT: BX = file size (in bytes), carry set if file not found
   534                              <2> 
   535                              <2> os_load_file equ 32801
   536                              <2> 
   537                              <2> ; --------------------------------------------------------------------------
   538                              <2> ; os_write_file -- Save (max 64K) file to disk
   539                              <2> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
   540                              <2> ; OUT: Carry clear if OK, set if failure
   541                              <2> 
   542                              <2> os_write_file equ 32915
   543                              <2> 
   544                              <2> ; --------------------------------------------------------------------------
   545                              <2> ; os_file_exists -- Check for presence of file on the floppy
   546                              <2> ; IN: AX = filename location; OUT: carry clear if found, set if not
   547                              <2> 
   548                              <2> os_file_exists equ 32918
   549                              <2> 
   550                              <2> ; --------------------------------------------------------------------------
   551                              <2> ; os_create_file -- Creates a new 0-byte file on the floppy disk
   552                              <2> ; IN: AX = location of filename
   553                              <2> ; OUT: None, registers preserved
   554                              <2> 
   555                              <2> os_create_file equ 32921
   556                              <2> 
   557                              <2> ; --------------------------------------------------------------------------
   558                              <2> ; os_remove_file -- Deletes the specified file from the filesystem
   559                              <2> ; IN: AX = location of filename to remove
   560                              <2> 
   561                              <2> os_remove_file equ 32924
   562                              <2> 
   563                              <2> ; --------------------------------------------------------------------------
   564                              <2> ; os_rename_file -- Change the name of a file on the disk
   565                              <2> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
   566                              <2> ; OUT: carry set on error
   567                              <2> 
   568                              <2> os_rename_file equ 32927
   569                              <2> 
   570                              <2> ; --------------------------------------------------------------------------
   571                              <2> ; os_get_file_size -- Get file size information for specified file
   572                              <2> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
   573                              <2> ; or carry set if file not found
   574                              <2> 
   575                              <2> os_get_file_size equ 32930
   576                              <2> 
   577                              <2> ; --------------------------------------------------------------------------
   578                              <2> ; os_get_file_datetime -- Get file write time/date information for specified file
   579                              <2> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
   580                              <2> ; or carry set if file not found
   581                              <2> 
   582                              <2> os_get_file_datetime equ 33011
   583                              <2> 
   584                              <2> ; --------------------------------------------------------------------------
   585                              <2> ; os_get_boot_disk -- Returns the boot disk number.
   586                              <2> ; IN: None
   587                              <2> ; OUT: DL = boot disk number for use in INT 13h calls
   588                              <2> 
   589                              <2> os_get_boot_disk equ 33062
   590                              <2> 
   591                              <2> ; ==================================================================
   592                              <2> ; MichalOS Miscellaneous functions
   593                              <2> ; ==================================================================
   594                              <2> 
   595                              <2> ; ------------------------------------------------------------------
   596                              <2> ; os_read_config_byte -- Reads a byte from the config
   597                              <2> ; IN: BX = offset
   598                              <2> ; OUT: AL = value
   599                              <2> 
   600                              <2> os_read_config_byte equ 33134
   601                              <2> 
   602                              <2> ; ------------------------------------------------------------------
   603                              <2> ; os_read_config_word -- Reads a word from the config
   604                              <2> ; IN: BX = offset
   605                              <2> ; OUT: AX = value
   606                              <2> 
   607                              <2> os_read_config_word equ 33137
   608                              <2> 
   609                              <2> ; ------------------------------------------------------------------
   610                              <2> ; os_write_config_byte -- Writes a byte to the config
   611                              <2> ; NOTE: This will only affect the config in memory,
   612                              <2> ; run os_save_config to save the changes to disk!
   613                              <2> ; IN: BX = offset, AL = value
   614                              <2> ; OUT: None, registers preserved
   615                              <2> 
   616                              <2> os_write_config_byte equ 33140
   617                              <2> 
   618                              <2> ; ------------------------------------------------------------------
   619                              <2> ; os_write_config_word -- Writes a byte to the config
   620                              <2> ; NOTE: This will only affect the config in memory,
   621                              <2> ; run os_save_config to save the changes to disk!
   622                              <2> ; IN: BX = offset, AX = value
   623                              <2> ; OUT: None, registers preserved
   624                              <2> 
   625                              <2> os_write_config_word equ 33143
   626                              <2> 
   627                              <2> ; ------------------------------------------------------------------
   628                              <2> ; os_save_config -- Saves the current config to disk
   629                              <2> ; OUT: Carry set if error
   630                              <2> 
   631                              <2> os_save_config equ 33146
   632                              <2> 
   633                              <2> ; ------------------------------------------------------------------
   634                              <2> ; os_exit -- Exits the application, launches another one (if possible)
   635                              <2> ; IN: AX = if not 0, then ptr to filename of application to be launched,
   636                              <2> ;     BX = 1 if the application calling os_exit should be re-launched after
   637                              <2> ;     the requested application exits
   638                              <2> ; OUT: None, register preserved
   639                              <2> 
   640                              <2> os_exit equ 32780
   641                              <2> 
   642                              <2> ; ------------------------------------------------------------------
   643                              <2> ; os_clear_registers -- Clear all registers
   644                              <2> ; IN: None
   645                              <2> ; OUT: Cleared registers
   646                              <2> 
   647                              <2> os_clear_registers equ 32975
   648                              <2> 
   649                              <2> ; ------------------------------------------------------------------
   650                              <2> ; os_get_os_name -- Get the OS name string
   651                              <2> ; IN: None
   652                              <2> ; OUT: DS:SI = OS name string, zero-terminated
   653                              <2> 
   654                              <2> os_get_os_name equ 33083
   655                              <2> 
   656                              <2> ; ------------------------------------------------------------------
   657                              <2> ; os_get_memory -- Gets the amount of system RAM.
   658                              <2> ; IN: None
   659                              <2> ; OUT: AX = conventional memory (in kB), BX = high memory (in kB)
   660                              <2> 
   661                              <2> os_get_memory equ 33050
   662                              <2> 
   663                              <2> ; ------------------------------------------------------------------
   664                              <2> ; os_int_1Ah -- Middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
   665                              <2> ; IN/OUT: same as int 1Ah
   666                              <2> 
   667                              <2> os_int_1Ah equ 33032
   668                              <2> 
   669                              <2> ; ==================================================================
   670                              <2> ; MichalOS/MikeOS 4.5 BASIC interpreter
   671                              <2> ; ==================================================================
   672                              <2> 
   673                              <2> ; ------------------------------------------------------------------
   674                              <2> ; The BASIC interpreter execution starts here -- a parameter string
   675                              <2> ; is passed in SI and copied into the first string, unless SI = 0
   676                              <2> 
   677                              <2> os_run_basic equ 32963
   678                              <2> 
   679                              <2> ; ==================================================================
   680                              <2> ; MichalOS Math functions
   681                              <2> ; ==================================================================
   682                              <2> 
   683                              <2> ; ------------------------------------------------------------------
   684                              <2> ; os_get_random -- Return a random integer between low and high (inclusive)
   685                              <2> ; IN: AX = low integer, BX = high integer
   686                              <2> ; OUT: CX = random integer
   687                              <2> 
   688                              <2> os_get_random equ 32948
   689                              <2> 
   690                              <2> ; ------------------------------------------------------------------
   691                              <2> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
   692                              <2> ; IN: AL = BCD number
   693                              <2> ; OUT: AX = integer value
   694                              <2> 
   695                              <2> os_bcd_to_int equ 32846
   696                              <2> 
   697                              <2> ; ------------------------------------------------------------------
   698                              <2> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
   699                              <2> ; IN: AL = integer value
   700                              <2> ; OUT: AL = BCD number
   701                              <2> 
   702                              <2> os_int_to_bcd equ 33035
   703                              <2> 
   704                              <2> ; ------------------------------------------------------------------
   705                              <2> ; os_math_power -- Calculates EAX^EBX.
   706                              <2> ; IN: EAX^EBX = input
   707                              <2> ; OUT: EAX = result
   708                              <2> 
   709                              <2> os_math_power equ 33071
   710                              <2> 
   711                              <2> ; ------------------------------------------------------------------
   712                              <2> ; os_math_root -- Approximates the EBXth root of EAX.
   713                              <2> ; IN: EAX = input, EBX = root
   714                              <2> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   715                              <2> 
   716                              <2> os_math_root equ 33074
   717                              <2> 
   718                              <2> ; ==================================================================
   719                              <2> ; MichalOS String manipulation functions
   720                              <2> ; ==================================================================
   721                              <2> 
   722                              <2> ; ------------------------------------------------------------------
   723                              <2> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
   724                              <2> ; IN: DS:SI = Input string/Output string
   725                              <2> ; OUT: None, registers preserved
   726                              <2> 
   727                              <2> os_string_encrypt equ 33014
   728                              <2> 
   729                              <2> ; ------------------------------------------------------------------
   730                              <2> ; os_string_add -- Add a string on top of another string
   731                              <2> ; IN: DS:AX = Main string, DS:BX = Added string
   732                              <2> ; OUT: None, registers preserved
   733                              <2> 
   734                              <2> os_string_add equ 32897
   735                              <2> 
   736                              <2> ; ------------------------------------------------------------------
   737                              <2> ; os_string_length -- Return length of a string
   738                              <2> ; IN: DS:AX = string location
   739                              <2> ; OUT AX = length (other regs preserved)
   740                              <2> 
   741                              <2> os_string_length equ 32810
   742                              <2> 
   743                              <2> ; ------------------------------------------------------------------
   744                              <2> ; os_string_reverse -- Reverse the characters in a string
   745                              <2> ; IN: DS:SI = string location
   746                              <2> ; OUT: None, registers preserved
   747                              <2> 
   748                              <2> os_string_reverse equ 32939
   749                              <2> 
   750                              <2> ; ------------------------------------------------------------------
   751                              <2> ; os_find_char_in_string -- Find location of character in a string
   752                              <2> ; IN: DS:SI = string location, AL = character to find
   753                              <2> ; OUT: AX = location in string, or 0 if char not present
   754                              <2> 
   755                              <2> os_find_char_in_string equ 32867
   756                              <2> 
   757                              <2> ; ------------------------------------------------------------------
   758                              <2> ; os_string_uppercase -- Convert zero-terminated string to upper case
   759                              <2> ; IN: DS:AX = string location
   760                              <2> ; OUT: None, registers preserved
   761                              <2> 
   762                              <2> os_string_uppercase equ 32813
   763                              <2> 
   764                              <2> ; ------------------------------------------------------------------
   765                              <2> ; os_string_lowercase -- Convert zero-terminated string to lower case
   766                              <2> ; IN: DS:AX = string location
   767                              <2> ; OUT: None, registers preserved
   768                              <2> 
   769                              <2> os_string_lowercase equ 32816
   770                              <2> 
   771                              <2> ; ------------------------------------------------------------------
   772                              <2> ; os_string_copy -- Copy one string into another
   773                              <2> ; IN: DS:SI = source, ES:DI = destination (programmer ensure sufficient room)
   774                              <2> ; OUT: None, registers preserved
   775                              <2> 
   776                              <2> os_string_copy equ 32822
   777                              <2> 
   778                              <2> ; ------------------------------------------------------------------
   779                              <2> ; os_string_join -- Join two strings into a third string
   780                              <2> ; IN: DS:AX = string one, DS:BX = string two, ES:CX = destination string
   781                              <2> ; OUT: None, registers preserved
   782                              <2> 
   783                              <2> os_string_join equ 32828
   784                              <2> 
   785                              <2> ; ------------------------------------------------------------------
   786                              <2> ; os_string_chomp -- Strip leading and trailing spaces from a string
   787                              <2> ; IN: DS:AX = string location
   788                              <2> ; OUT: None, registers preserved
   789                              <2> 
   790                              <2> os_string_chomp equ 32837
   791                              <2> 
   792                              <2> ; ------------------------------------------------------------------
   793                              <2> ; os_string_compare -- See if two strings match
   794                              <2> ; IN: DS:SI = string one, DS:DI = string two
   795                              <2> ; OUT: carry set if same, clear if different
   796                              <2> 
   797                              <2> os_string_compare equ 32834
   798                              <2> 
   799                              <2> ; ------------------------------------------------------------------
   800                              <2> ; os_string_parse -- Take string (eg "run foo bar baz") and return
   801                              <2> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
   802                              <2> ; IN: DS:SI = string
   803                              <2> ; OUT: AX, BX, CX, DX = individual strings
   804                              <2> 
   805                              <2> os_string_parse equ 32960
   806                              <2> 
   807                              <2> ; ------------------------------------------------------------------
   808                              <2> ; os_string_to_int -- Convert decimal string to integer value
   809                              <2> ; IN: DS:SI = string location (max 5 chars, up to '65535')
   810                              <2> ; OUT: AX = number
   811                              <2> 
   812                              <2> os_string_to_int equ 32942
   813                              <2> 
   814                              <2> ; ------------------------------------------------------------------
   815                              <2> ; os_string_to_hex -- Convert hexadecimal string to integer value
   816                              <2> ; IN: DS:SI = string location (max 8 chars, up to 'FFFFFFFF')
   817                              <2> ; OUT: EAX = number
   818                              <2> 
   819                              <2> os_string_to_hex equ 32840
   820                              <2> 
   821                              <2> ; ------------------------------------------------------------------
   822                              <2> ; os_int_to_string -- Convert unsigned integer to string
   823                              <2> ; IN: AX = unsigned int
   824                              <2> ; OUT: DS:AX = string location
   825                              <2> 
   826                              <2> os_int_to_string equ 32792
   827                              <2> 
   828                              <2> ; ------------------------------------------------------------------
   829                              <2> ; os_sint_to_string -- Convert signed integer to string
   830                              <2> ; IN: AX = signed int
   831                              <2> ; OUT: DS:AX = string location
   832                              <2> 
   833                              <2> os_sint_to_string equ 32957
   834                              <2> 
   835                              <2> ; ------------------------------------------------------------------
   836                              <2> ; os_get_time_string -- Get current time in a string (eg '10:25')
   837                              <2> ; IN: ES:BX = string location
   838                              <2> ; OUT: None, registers preserved
   839                              <2> 
   840                              <2> os_get_time_string equ 32849
   841                              <2> 
   842                              <2> ; ------------------------------------------------------------------
   843                              <2> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
   844                              <2> ; IN: ES:BX = string location
   845                              <2> ; OUT: None, registers preserved
   846                              <2> 
   847                              <2> os_get_date_string equ 32858
   848                              <2> 
   849                              <2> ; ------------------------------------------------------------------
   850                              <2> ; os_string_tokenize -- Reads tokens separated by specified char from
   851                              <2> ; a string. Returns pointer to next token, or 0 if none left
   852                              <2> ; IN: AL = separator char, DS:SI = beginning
   853                              <2> ; OUT: DI = next token or 0 if none
   854                              <2> 
   855                              <2> os_string_tokenize equ 32972
   856                              <2> 
   857                              <2> ; ------------------------------------------------------------------
   858                              <2> ; os_string_callback_tokenizer -- Prints a token from string, requests are done by callback
   859                              <2> ; IN: DS:AX = comma-separated string
   860                              <2> ; OUT: AL = AH = max length of any token, CX = number of entries in the list,
   861                              <2> ;      DX:SI = callback location (if C clear, accepts CX as entry ID, prints out result)
   862                              <2> 
   863                              <2> os_string_callback_tokenizer equ 33128
   864                              <2> 
   865                              <2> ; ------------------------------------------------------------------
   866                              <2> ; os_32int_to_string -- Converts an unsigned 32-bit integer into a string
   867                              <2> ; IN: EAX = unsigned int
   868                              <2> ; OUT: DS:AX = string location
   869                              <2> 
   870                              <2> os_32int_to_string equ 33059
   871                              <2> 
   872                              <2> ; ------------------------------------------------------------------
   873                              <2> ; os_string_to_32int -- Converts a string into a 32-bit integer
   874                              <2> ; IN: DS:SI = string location
   875                              <2> ; OUT: EAX = unsigned integer
   876                              <2> 
   877                              <2> os_string_to_32int equ 33068
   878                              <2> 
   879                              <2> ; ==================================================================
   880                              <2> ; MichalOS ZX7 decompression routine
   881                              <2> ; ==================================================================
   882                              <2> 
   883                              <2> ; ------------------------------------------------------------------
   884                              <2> ; os_decompress_zx7 -- Decompresses ZX7-packed data.
   885                              <2> ; IN: DS:SI = source, ES:DI = destination
   886                              <2> ; OUT: None, registers preserved
   887                              <2> 
   888                              <2> os_decompress_zx7 equ 33038
   889                              <2> 
   890                              <2> ; ==================================================================
   891                              <2> ; MichalOS Interrupt management & app timer functions
   892                              <2> ; ==================================================================
   893                              <2> 
   894                              <2> ; -----------------------------------------------------------------
   895                              <2> ; os_modify_int_handler -- Change location of interrupt handler
   896                              <2> ; IN: CL = int number, DI:SI = handler location
   897                              <2> ; OUT: None, registers preserved
   898                              <2> 
   899                              <2> os_modify_int_handler equ 33056
   900                              <2> 
   901                              <2> ; -----------------------------------------------------------------
   902                              <2> ; os_get_int_handler -- Change location of interrupt handler
   903                              <2> ; IN: CL = int number
   904                              <2> ; OUT: DI:SI = handler location
   905                              <2> 
   906                              <2> os_get_int_handler equ 33080
   907                              <2> 
   908                              <2> ; ------------------------------------------------------------------
   909                              <2> ; os_pause -- Delay execution for a specified number of ticks (18.2 Hz by default)
   910                              <2> ; IN: AX = amount of ticks to wait
   911                              <2> ; OUT: None, registers preserved
   912                              <2> 
   913                              <2> os_pause equ 32804
   914                              <2> 
   915                              <2> ; -----------------------------------------------------------------
   916                              <2> ; os_attach_app_timer -- Attach a timer interrupt to an application and sets the timer speed
   917                              <2> ; Formula: speed = (105000000 / 88) / frequency
   918                              <2> ; IN: DS:SI = handler location, CX = speed
   919                              <2> ; OUT: None, registers preserved
   920                              <2> 
   921                              <2> os_attach_app_timer equ 32969
   922                              <2> 
   923                              <2> ; -----------------------------------------------------------------
   924                              <2> ; os_return_app_timer -- Returns the timer interrupt back to the system and resets the timer speed
   925                              <2> ; IN/OUT: None, registers preserved
   926                              <2> 
   927                              <2> os_return_app_timer equ 32987
   928                              <2> 
   929                              <2> ; -----------------------------------------------------------------
   930                              <2> ; os_set_timer_speed -- Sets the timer's trigger speed.
   931                              <2> ; Formula: speed = (105000000 / 88) / frequency
   932                              <2> ; IN: CX = speed
   933                              <2> ; OUT: Nothing, registers preserved
   934                              <2> 
   935                              <2> os_set_timer_speed equ 32891
   936                              <2> 
   937                              <2> ; ==================================================================
   938                              <2> ; MichalOS Low-level disk driver
   939                              <2> ; ==================================================================
   940                              <2> 
   941                              <2> ; --------------------------------------------------------------------------
   942                              <2> ; os_disk_read_sector -- Read a single sector from disk
   943                              <2> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   944                              <2> 
   945                              <2> os_disk_read_sector equ 33092
   946                              <2> 
   947                              <2> ; --------------------------------------------------------------------------
   948                              <2> ; os_disk_read_multiple_sectors -- Read multiple sectors from disk
   949                              <2> ; IN: EAX = sector ID, CX = number of sectors, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   950                              <2> 
   951                              <2> os_disk_read_multiple_sectors equ 33104
   952                              <2> 
   953                              <2> ; --------------------------------------------------------------------------
   954                              <2> ; os_disk_write_sector -- Write a single sector to disk
   955                              <2> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   956                              <2> 
   957                              <2> os_disk_write_sector equ 33098
   958                              <2> 
   959                              <2> ; --------------------------------------------------------------------------
   960                              <2> ; os_disk_write_multiple_sectors -- Write multiple sectors to disk
   961                              <2> ; IN: EAX = sector ID, CX = number of sectors, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   962                              <2> 
   963                              <2> os_disk_write_multiple_sectors equ 33116
   964                              <2> 
    10                              <1> 
    11                              <1> %macro oscall 1
    12                              <1> 	mov bp, %1
    13                              <1> 	int 40h
    14                              <1> %endmacro
    15                              <1> 
    16                              <1> ; -----------------------------------------------------------------
    40                                  
    41 00000000 E82700                  start:  call init               ;initialize game
    42                                  
    43                                          ;game loop
    44                                  
    45 00000003 E83B01                  loop:   call inp                ;check for keypress
    46 00000006 3D1B01                          cmp ax,011Bh            ;was it Esc ?
    47 00000009 0F846A02                        je gameover             ;if yes, exit game
    48                                  
    49 0000000D E84001                          call move_obs           ;move objects (ax must contain scancode)
    50 00000010 E8B401                          call coll               ;check for collisions
    51 00000013 E83F02                          call score              ;calc current score
    52 00000016 E89400                          call drawscreen         ;refresh screen
    53                                  
    54 00000019 B80200                          mov ax,2                ;set game speed 
    55 0000001C E8(2480)                        call os_pause   
    56                                  
    57 0000001F A0[4A03]                        mov al,[goflag]         ;check game over flag
    58 00000022 3C01                            cmp al,1               
    59 00000024 0F844F02                        je gameover             ;game over, exit
    60 00000028 EBD9                            jmp loop                
    61                                  
    62                                          ;end game loop
    63                                  
    64                                  ;------------------------------------------------
    65                                  ;Initialize game
    66                                  
    67                                  init:   
    68 0000002A E8(0980)                        call os_clear_screen
    69 0000002D E8(8A80)                        call os_hide_cursor 
    70 00000030 E83A00                          call start_screen
    71 00000033 E8(1280)                        call os_wait_for_key
    72                                  
    73 00000036 3D1B01                          cmp ax,011Bh            ;Escaping before starting game?
    74 00000039 0F843A02                        je gameover             ;if yes, exit game
    75                                  
    76 0000003D E8(0980)                        call os_clear_screen
    77                                  
    78                                          ;draw the sky
    79 00000040 B370                            mov bl,0x70             ;color
    80 00000042 B202                            mov dl,2                ;x start
    81 00000044 B601                            mov dh,1                ;y start
    82 00000046 BE4C00                          mov si,76               ;width
    83 00000049 BF0C00                          mov di,12               ;y end
    84 0000004C E8(B180)                        call os_draw_block      ;draw
    85                                                  
    86                                          ;print the score message
    87 0000004F B204                            mov dl,4                ;col
    88 00000051 B602                            mov dh,2                ;row
    89 00000053 E8(0680)                        call os_move_cursor
    90 00000056 BE[B203]                        mov si,scmsg            
    91 00000059 E8(0380)                        call os_print_string
    92                                  
    93                                          ;print the hooks left message
    94 0000005C B204                            mov dl,4                ;col
    95 0000005E B603                            mov dh,3                ;row
    96 00000060 E8(0680)                        call os_move_cursor
    97 00000063 BE[C003]                        mov si,hkmsg            
    98 00000066 E8(0380)                        call os_print_string
    99                                  
   100 00000069 E84100                          call drawscreen         ;draw the rest of the screen
   101 0000006C C3                              ret
   102                                  
   103                                  ;------------------------------------------------
   104                                  ; Draw the start screen
   105                                  
   106                                  start_screen:
   107                                  
   108                                          ;screen background
   109 0000006D B8[5203]                        mov ax,boat             ;boat graphic at top  
   110 00000070 83C003                          add ax,3                ;graphic offset
   111 00000073 BB[4205]                        mov bx,credit           ;credit at bottom
   112 00000076 B91000                          mov cx,0x10             ;color
   113 00000079 E8(2780)                        call os_draw_background
   114                                  
   115                                          ;message block background
   116 0000007C B370                            mov bl,0x70             
   117 0000007E B20F                            mov dl,15
   118 00000080 B606                            mov dh,6
   119 00000082 BE3200                          mov si,50
   120 00000085 BF1400                          mov di,20
   121 00000088 E8(B180)                        call os_draw_block     
   122                                  
   123                                          ;print the instructions
   124 0000008B B210                    pmsg:   mov dl,16               ;col
   125 0000008D B606                            mov dh,6                ;row
   126 0000008F 30C9                            xor cl,cl
   127 00000091 BE[0E04]                        mov si,intro            ;message pointer
   128 00000094 80F90B                  .loop   cmp cl,11               ;number of lines in message
   129 00000097 7413                            je .exit
   130 00000099 31C0                            xor ax,ax
   131 0000009B 8A04                            mov al,byte [si]        ;get number of chars in line
   132 0000009D 46                              inc si                  ;point to string
   133 0000009E FEC6                            inc dh                  ;set to next row
   134 000000A0 E8(0680)                        call os_move_cursor
   135 000000A3 E8(0380)                        call os_print_string
   136 000000A6 01C6                            add si,ax               ;point to next row in message
   137 000000A8 FEC1                            inc cl
   138 000000AA EBE8                            jmp .loop
   139 000000AC C3                      .exit   ret
   140                                  
   141                                  ;------------------------------------------------
   142                                  ;Draw the screen
   143                                  ;
   144                                  ;This will get run each time through the game loop
   145                                  
   146                                  drawscreen:
   147                                  
   148                                          ;draw the ocean -------------------------
   149                                  
   150 000000AD B310                            mov bl,0x10
   151 000000AF B202                            mov dl,2
   152 000000B1 B60C                            mov dh,12
   153 000000B3 BE4C00                          mov si,76
   154 000000B6 BF1800                          mov di,24
   155 000000B9 E8(B180)                        call os_draw_block     
   156                                                 
   157                                          ;erase line and hook --------------------
   158                                  
   159 000000BC B310                            mov bl,0x10             ;ocean color
   160 000000BE 8A16[5203]                      mov dl,[boat]           ;boat x
   161 000000C2 8A36[5303]                      mov dh,[boat+1]         ;boat y
   162 000000C6 FEC6                            inc dh                  ;just under boat
   163 000000C8 BE0100                          mov si,1                ;one column wide
   164 000000CB BF1800                          mov di,24               ;to bottom of ocean
   165 000000CE E8(B180)                        call os_draw_block      ;draw ocean
   166                                         
   167                                          ;draw objects in array ------------------
   168                                  
   169 000000D1 30C9                    .obs    xor cl,cl               ;loop counter
   170 000000D3 BB[5203]                        mov bx,objects          ;object array
   171 000000D6 80F90C                  .obloop cmp cl,obcnt            ;last object?
   172 000000D9 7414                            je .line
   173 000000DB 8B17                            mov dx,[bx+0]           ;x and y values (as word)
   174 000000DD E8(0680)                        call os_move_cursor
   175 000000E0 89DE                            mov si,bx               ;print graphic
   176 000000E2 83C603                          add si,3                ;graphic offset
   177 000000E5 E8(0380)                        call os_print_string
   178 000000E8 83C308                          add bx,reclen           ;next object
   179 000000EB FEC1                            inc cl                  ;loop counter
   180 000000ED EBE7                            jmp .obloop
   181                                  
   182                                          ;draw line between boat and hook --------
   183                                  
   184 000000EF A0[5B03]                .line   mov al,[hook+1]         ;check if hook is up
   185 000000F2 2A06[5303]                      sub al,[boat+1]         ;y position
   186 000000F6 3C01                            cmp al,1                
   187 000000F8 741D                            je .score               ;all reeled in
   188 000000FA 8A16[5203]                      mov dl,[boat]           ;boat x for line x
   189 000000FE 8A36[5303]                      mov dh,[boat+1]         ;boat y + 1 for line start
   190 00000102 FEC6                            inc dh                  ;first line segment
   191 00000104 3A36[5B03]              .loop   cmp dh,[hook+1]         ;is it at hook yet?
   192 00000108 740D                            je .score
   193 0000010A E8(0680)                        call os_move_cursor
   194 0000010D BE[5003]                        mov si,line             ;line graphic
   195 00000110 E8(0380)                        call os_print_string
   196 00000113 FEC6                            inc dh
   197 00000115 EBED                            jmp .loop
   198                                  
   199                                          ;erase old score and hook count ---------
   200                                  
   201 00000117 B370                    .score  mov bl,0x70             ;sky color
   202 00000119 B211                            mov dl,17
   203 0000011B B602                            mov dh,2
   204 0000011D BE0600                          mov si,6
   205 00000120 BF0400                          mov di,4
   206 00000123 E8(B180)                        call os_draw_block     
   207                                  
   208                                          ;display score --------------------------
   209                                  
   210 00000126 B211                            mov dl,17               ;col
   211 00000128 B602                            mov dh,2                ;row
   212 0000012A E8(0680)                        call os_move_cursor
   213 0000012D A1[4B03]                        mov ax,[total]
   214 00000130 E8(4D81)                        call os_print_int
   215                                  
   216                                          ;display hook count ---------------------
   217                                  
   218 00000133 B211                            mov dl,17               ;col
   219 00000135 B603                            mov dh,3                ;row
   220 00000137 E8(0680)                        call os_move_cursor
   221 0000013A A1[4D03]                        mov ax,[hooks]
   222 0000013D E8(4D81)                        call os_print_int
   223                                  
   224 00000140 C3                              ret
   225                                  
   226                                  ;------------------------------------------------
   227                                  ;Get scan code if a key is pressed
   228                                  
   229 00000141 B401                    inp:    mov ah,1        ;check for key press
   230 00000143 CD16                            int 16h         
   231 00000145 7406                            jz .nokey       ;no key pressed
   232 00000147 30E4                            xor ah,ah       ;get key from buffer into al
   233 00000149 CD16                            int 16h
   234 0000014B EB02                            jmp .exit
   235 0000014D 31C0                    .nokey  xor ax,ax       ;set return to 0
   236 0000014F C3                      .exit   ret
   237                                  
   238                                  ;------------------------------------------------
   239                                  ; Move objects
   240                                  ; Must be called with scancode in AX
   241                                  
   242                                  move_obs:
   243                                          ;user input
   244 00000150 3D0050                          cmp ax,5000h            ;down arrow
   245 00000153 7407                            je .down
   246 00000155 3D0048                          cmp ax,4800h            ;up arrow
   247 00000158 7413                            je .up
   248 0000015A EB22                            jmp movefish
   249                                  
   250 0000015C A0[5B03]                .down   mov al,[hook+1]         ;check hook limit
   251 0000015F 2A06[5303]                      sub al,[boat+1]
   252 00000163 3C0C                            cmp al,hlimit
   253 00000165 7417                            je  movefish            ;at bottom of sea
   254 00000167 FE06[5B03]                      inc byte [hook+1]       ;lower hook
   255 0000016B EB11                            jmp movefish
   256 0000016D A0[5B03]                .up     mov al,[hook+1]         ;check hook limit
   257 00000170 2A06[5303]                      sub al,[boat+1]
   258 00000174 3C01                            cmp al,1                            
   259 00000176 7406                            je  movefish            ;all reeled in
   260 00000178 FE0E[5B03]                      dec byte [hook+1]       ;raise hook                
   261 0000017C EB00                            jmp movefish
   262                                  
   263                                  movefish:
   264 0000017E FE06[4F03]                      inc byte [behav]        ;inc behavior byte
   265 00000182 30C9                            xor cl,cl               ;loop counter
   266 00000184 BB[6203]                        mov bx,fish             ;fish array
   267 00000187 80F90A                  .obloop cmp cl,fishcnt          ;last fish?
   268 0000018A 743A                            je .exit
   269 0000018C A0[4F03]                        mov al,[behav]
   270 0000018F 224702                          and al,[bx+2]           ;fish behavior mask
   271 00000192 3C00                            cmp al,0
   272 00000194 7429                            je .endl                ;doesn't move this loop
   273 00000196 8A4706                          mov al,[bx+6]           ;direction flag
   274 00000199 3C00                            cmp al,0                ;0=east, 1=west
   275 0000019B 7411                            je .eastf
   276 0000019D 8A07                    .westf  mov al,[bx+0]           ;x position
   277 0000019F 3C02                            cmp al,2                ;check if at start of screen
   278 000001A1 7705                            ja .wmove
   279 000001A3 C6074D                          mov byte [bx+0], 77     ;reset to start
   280 000001A6 EB17                            jmp .endl
   281 000001A8 FEC8                    .wmove  dec al
   282 000001AA 8807                            mov [bx+0],al
   283 000001AC EB11                            jmp .endl
   284 000001AE 8A07                    .eastf  mov al,[bx+0]           ;x position
   285 000001B0 3C4D                            cmp al,77               ;check if at end of screen
   286 000001B2 7205                            jb .emove
   287 000001B4 C60702                          mov byte [bx+0], 2      ;reset to start
   288 000001B7 EB06                            jmp .endl
   289 000001B9 FEC0                    .emove  inc al
   290 000001BB 8807                            mov [bx+0],al
   291 000001BD EB00                            jmp .endl
   292 000001BF 83C308                  .endl   add bx,reclen           ;next fish 
   293 000001C2 FEC1                            inc cl                  ;loop counter
   294 000001C4 EBC1                            jmp .obloop
   295 000001C6 C3                      .exit   ret
   296                                                                               
   297                                  ;------------------------------------------------
   298                                  ; Collisions
   299                                  
   300                                  ; collisions possible
   301                                  ;  hook with fish hits boat (point)
   302                                  ;  fish hits empty hook (catch)
   303                                  ;  fish hits line (loose hook)
   304                                  
   305                                  ;  if a fish is caught, replace hook graphic with fish graphic
   306                                  
   307                                          ;hook with fish hits boat ---------------
   308                                  
   309 000001C7 A0[5303]                coll:   mov al,[boat+1]         ;y pos of boat
   310 000001CA FEC0                            inc al                  ;just below
   311 000001CC 3A06[5B03]                      cmp al,[hook+1]         ;is hook right under the boat?
   312 000001D0 7527                            jne hkcoll              ;no, next collision
   313 000001D2 A0[5D03]                        mov al,[hook+3]         ;is this a hook
   314 000001D5 3CA8                            cmp al,0xA8             ;or a fish
   315 000001D7 7420                            je hkcoll               ;no, next collision
   316                                  
   317                                          ;find the fish that was caught
   318 000001D9 30C9                    .obs    xor cl,cl               ;loop counter
   319 000001DB BB[6203]                        mov bx,fish             ;fish array
   320 000001DE 80F90A                  .obloop cmp cl,fishcnt          ;last fish?
   321 000001E1 7416                            je hkcoll
   322 000001E3 3A4703                          cmp al,[bx+3]           ;is this our fish?
   323 000001E6 750A                            jne .eloop
   324 000001E8 FE4705                          inc byte [bx+5]         ;increment caught count
   325 000001EB C606[5D03]A8                    mov [hook+3],byte 0xA8  ;reset hook
   326 000001F0 EB07                            jmp hkcoll              ;done
   327 000001F2 83C308                  .eloop  add bx,reclen           ;next object
   328 000001F5 FEC1                            inc cl                  ;loop counter
   329 000001F7 EBE5                            jmp .obloop
   330                                  
   331                                          ;did a fish hit an empty hook? ----------
   332                                  
   333 000001F9 30C9                    hkcoll: xor cl,cl               ;loop counter
   334 000001FB BB[6203]                        mov bx,fish             ;fish array
   335 000001FE 80F90A                  .obloop cmp cl,fishcnt          ;last object?
   336 00000201 7451                            je .exit
   337 00000203 8A07                            mov al,[bx+0]           ;x and y values
   338 00000205 3A06[5203]                      cmp al, [boat+0]        ;is the fish under the boat?
   339 00000209 7542                            jne .eloop              ;no, next fish
   340 0000020B 8A4701                          mov al,[bx+1]           ;check y value
   341 0000020E 3A06[5B03]                      cmp al,[hook+1]         ;is fish below hook?
   342 00000212 7739                            ja .eloop               ;fish is below hook
   343 00000214 741C                            je .hook                ;fish hit hook
   344                                                                  ;fish hit line
   345 00000216 C606[5D03]A8            .line   mov [hook+3], byte 0xA8 ;if fish on hook, drop
   346 0000021B C606[5B03]0C                    mov [hook+1], byte 12   ;reset hook to boat
   347 00000220 FF0E[4D03]                      dec word [hooks]        ;lost a hook
   348 00000224 833E[4D03]00                    cmp word [hooks], 0     ;check hooks left
   349 00000229 7522                            jne .eloop              ;still have some hooks
   350 0000022B C606[4A03]01                    mov [goflag], byte 1    ;game over :(
   351 00000230 EB22                            jmp .exit
   352                                  
   353 00000232 A0[5D03]                .hook   mov al, [hook+3]        ;is hook free?
   354 00000235 3CA8                            cmp al, 0xA8            ;hook graphic
   355 00000237 7514                            jne .eloop              ;a fish is already on hook
   356 00000239 8A4703                          mov al,[bx+3]           ;caught! get fish graphic
   357 0000023C A2[5D03]                        mov [hook+3], al        ;replace hook
   358                                  
   359 0000023F 807F0601                        cmp [bx+6], byte 1      ;which way was fish moving?
   360 00000243 7405                            je .west                ;1 = east bound, 0 = west bound
   361 00000245 C60702                          mov [bx+0], byte 2      ;reset east bound fish
   362 00000248 EB03                            jmp .eloop
   363 0000024A C6074D                  .west   mov [bx+0], byte 77     ;reset west bound fish
   364                                  
   365 0000024D 83C308                  .eloop  add bx,reclen           ;next object
   366 00000250 FEC1                            inc cl                  ;loop counter
   367 00000252 EBAA                            jmp .obloop
   368                                  
   369 00000254 C3                      .exit   ret
   370                                  
   371                                  ;------------------------------------------------
   372                                  ;calc score
   373                                  
   374 00000255 31D2                    score:  xor dx,dx               ;running sum
   375 00000257 30C9                            xor cl,cl               ;loop counter
   376 00000259 BB[6203]                        mov bx,fish             ;fish array
   377 0000025C 80F90A                  .obloop cmp cl,fishcnt          ;last fish?
   378 0000025F 7411                            je .exit
   379 00000261 31C0                            xor ax,ax
   380 00000263 8A4707                          mov al,[bx+7]           ;fish value
   381 00000266 F66705                          mul byte [bx+5]         ;times number caught
   382 00000269 01C2                            add dx,ax               ;add to current total
   383 0000026B 83C308                          add bx,reclen           ;next object
   384 0000026E FEC1                            inc cl                  ;loop counter
   385 00000270 EBEA                            jmp .obloop
   386 00000272 8916[4B03]              .exit   mov [total],dx          ;set score
   387 00000276 C3                              ret
   388                                  
   389                                  ;------------------------------------------------
   390                                  ;Show catch log
   391                                  
   392                                  
   393                                  gameover:
   394                                          ;draw green border
   395 00000277 B320                            mov bl,0x20
   396 00000279 B213                            mov dl,lbcol            
   397 0000027B B604                            mov dh,lbrow            
   398 0000027D BE2A00                          mov si,lbwidth          
   399 00000280 BF1600                          mov di,lbbot            
   400 00000283 E8(B180)                        call os_draw_block     
   401                                  
   402                                          ;draw catch log sheet
   403 00000286 B370                            mov bl,0x70
   404 00000288 B214                            mov dl,lbcol+1
   405 0000028A B605                            mov dh,lbrow+1
   406 0000028C BE2800                          mov si,lbwidth-2
   407 0000028F BF1500                          mov di,lbbot-1
   408 00000292 E8(B180)                        call os_draw_block     
   409                                  
   410                                          ;print Catch Log
   411 00000295 B215                            mov dl,lbcol+2
   412 00000297 B606                            mov dh,lbrow+2
   413 00000299 E8(0680)                        call os_move_cursor
   414 0000029C BE[CE03]                        mov si,gomsg
   415 0000029F E8(0380)                        call os_print_string
   416                                  
   417                                          ;date
   418 000002A2 B22E                            mov dl,lbcol+27
   419 000002A4 B606                            mov dh,lbrow+2
   420 000002A6 E8(0680)                        call os_move_cursor
   421 000002A9 BB[4F05]                        mov bx,dtbuff                   ;set buffer pointer
   422 000002AC E8(5A80)                        call os_get_date_string         ;get current date in bx
   423 000002AF 89DE                            mov si,bx
   424 000002B1 E8(0380)                        call os_print_string
   425                                  
   426                                          ;Column Headings
   427 000002B4 B218                            mov dl,lbcol+5
   428 000002B6 B608                            mov dh,lbrow+4
   429 000002B8 E8(0680)                        call os_move_cursor
   430 000002BB BE[D803]                        mov si,head1
   431 000002BE E8(0380)                        call os_print_string
   432 000002C1 B609                            mov dh,lbrow+5
   433 000002C3 E8(0680)                        call os_move_cursor
   434 000002C6 BE[EF03]                        mov si,head2
   435 000002C9 E8(0380)                        call os_print_string
   436                                  
   437                                          ;display individual fish counts 
   438 000002CC B218                            mov dl,lbcol+5          ;first column
   439 000002CE B60A                            mov dh,lbrow+6          ;first row 
   440 000002D0 30C9                            xor cl,cl               ;loop counter
   441 000002D2 BB[6203]                        mov bx,fish             ;fish array
   442 000002D5 80F90A                  .obloop cmp cl,fishcnt          ;last fish?
   443 000002D8 745E                            je .hold
   444 000002DA E8(0680)                        call os_move_cursor
   445 000002DD 89DE                            mov si,bx               ;current fish
   446 000002DF 83C603                          add si,3                ;graphic
   447 000002E2 E8(0380)                        call os_print_string    ;show
   448 000002E5 B225                            mov dl,lbcol+18         ;right col
   449 000002E7 31C0                            xor ax,ax
   450 000002E9 8A4707                          mov al,[bx+7]           ;fish value
   451 000002EC E8(1880)                        call os_int_to_string   ;convert to string
   452 000002EF 89C6                            mov si,ax               ;set string pointer
   453 000002F1 E8(2A80)                        call os_string_length   ;right justify
   454 000002F4 28C2                            sub dl,al               ;by shifting back string length
   455 000002F6 E8(0680)                        call os_move_cursor
   456 000002F9 E8(0380)                        call os_print_string
   457 000002FC B22E                            mov dl,lbcol+27          ;right col
   458 000002FE 31C0                            xor ax,ax
   459 00000300 8A4705                          mov al,[bx+5]           ;number caught
   460 00000303 E8(1880)                        call os_int_to_string   ;convert to string
   461 00000306 89C6                            mov si,ax               ;set string pointer
   462 00000308 E8(2A80)                        call os_string_length   ;right justify
   463 0000030B 28C2                            sub dl,al               ;by shifting back string length
   464 0000030D E8(0680)                        call os_move_cursor
   465 00000310 E8(0380)                        call os_print_string
   466 00000313 B236                            mov dl,lbcol+35         ;right col
   467 00000315 31C0                            xor ax,ax
   468 00000317 8A4707                          mov al,[bx+7]           ;value
   469 0000031A F66705                          mul byte [bx+5]         ;times number caught
   470 0000031D E8(1880)                        call os_int_to_string   ;convert to string
   471 00000320 89C6                            mov si,ax               ;set string pointer
   472 00000322 E8(2A80)                        call os_string_length   ;right justify
   473 00000325 28C2                            sub dl,al               ;by shifting back string length
   474 00000327 E8(0680)                        call os_move_cursor
   475 0000032A E8(0380)                        call os_print_string
   476 0000032D 83C308                  .eloop  add bx,reclen           ;next object
   477 00000330 FEC6                            inc dh                  ;row
   478 00000332 B218                            mov dl,lbcol+5          ;start col
   479 00000334 FEC1                            inc cl                  ;loop counter
   480 00000336 EB9D                            jmp .obloop
   481 00000338 E8(1280)                .hold   call os_wait_for_key
   482 0000033B 3D1B01                          cmp ax,011Bh            ;Esc key
   483 0000033E 75F8                            jne .hold
   484 00000340 E8(0980)                        call os_clear_screen
   485 00000343 EB01                            jmp exit
   486 00000345 C3                              ret
   487                                  
   488                                  ;------------------------------------------------
   489                                  
   490 00000346 E8(8780)                exit:   call os_show_cursor
   491 00000349 C3                              ret    
   492                                  
   493                                  
   494                                  ;data ----------------------------------------
   495                                  
   496 0000034A 00                      goflag  db 0            ;0 = running, 1 = game over
   497 0000034B 0000                    total   dw 0            ;score total
   498 0000034D 0A00                    hooks   dw 10           ;hooks left
   499 0000034F 00                      behav   db 0            ;will inc 1 each time thru game loop
   500 00000350 B300                    line    db 0xB3,0       ;graphic only (x and y from boat)
   501                                  
   502                                  objects:        
   503                                             ;x,y,behavior,graphic,term,caught,direction,value
   504 00000352 260B00AD00000000        boat:   db 38,11,00000000b,0xAD,0,0,0,0       
   505 0000035A 260C00A800000000        hook:   db 38,12,00000000b,0xA8,0,0,0,0       
   506 00000362 020D14AF00000001        fish:   db 02,13,00010100b,0xAF,0,0,0,1   
   507 0000036A 4D0E44F700000104                db 77,14,01000100b,0xF7,0,0,1,4  
   508 00000372 4D0F02AE00000109                db 77,15,00000010b,0xAE,0,0,1,9       
   509 0000037A 021024E900000010                db 02,16,00100100b,0xE9,0,0,0,16       
   510 00000382 021102EC00000019                db 02,17,00000010b,0xEC,0,0,0,25       
   511 0000038A 4D1208ED00000124                db 77,18,00001000b,0xED,0,0,1,36       
   512 00000392 021320E000000031                db 02,19,00100000b,0xE0,0,0,0,49       
   513 0000039A 4D1424CF00000140                db 77,20,00100100b,0xCF,0,0,1,64       
   514 000003A2 021540F000000051                db 02,21,01000000b,0xF0,0,0,0,81       
   515 000003AA 4D1610E500000164                db 77,22,00010000b,0xE5,0,0,1,100       
   516                                  
   517 000003B2 546F74616C2053636F-     scmsg   db 'Total Score: ',0
   517 000003BB 72653A2000         
   518 000003C0 486F6F6B73204C6566-     hkmsg   db 'Hooks Left:  ',0
   518 000003C9 743A202000         
   519                                  
   520 000003CE 4361746368204C6F67-     gomsg   db 'Catch Log',0
   520 000003D7 00                 
   521 000003D8 202020202020204D61-     head1   db '       Market   Number',0
   521 000003E1 726B65742020204E75-
   521 000003EA 6D62657200         
   522 000003EF 466973682020205661-     head2   db 'Fish   Value    Caught   Score',0
   522 000003F8 6C7565202020204361-
   522 00000401 756768742020205363-
   522 0000040A 6F726500           
   523                                  
   524                                          ;line length (including 0), Message, 0
   525 0000040E 104465657020536561-     intro:  db 16,'Deep Sea Fisher',0
   525 00000417 2046697368657200   
   526 0000041F 0100                            db 1,0
   527 00000421 274361746368206120-             db 39,'Catch a fish and reel it in for points',0
   527 0000042A 6669736820616E6420-
   527 00000433 7265656C2069742069-
   527 0000043C 6E20666F7220706F69-
   527 00000445 6E747300           
   528 00000449 315468652064656570-             db 49,'The deeper the fish, the more points it is worth',0
   528 00000452 657220746865206669-
   528 0000045B 73682C20746865206D-
   528 00000464 6F726520706F696E74-
   528 0000046D 732069742069732077-
   528 00000476 6F72746800         
   529 0000047B 2B4966206120666973-             db 43,'If a fish hits your line, you loose a hook',0
   529 00000484 68206869747320796F-
   529 0000048D 7572206C696E652C20-
   529 00000496 796F75206C6F6F7365-
   529 0000049F 206120686F6F6B00   
   530 000004A7 2D5768656E20796F75-             db 45,'When you run out of hooks, the game is over!',0
   530 000004B0 2072756E206F757420-
   530 000004B9 6F6620686F6F6B732C-
   530 000004C2 207468652067616D65-
   530 000004CB 206973206F76657221-
   530 000004D4 00                 
   531 000004D5 0100                            db 1,0
   532 000004D7 2D5570206172726F77-             db 45,'Up arrow raises hook, Down arrow lowers hook',0
   532 000004E0 207261697365732068-
   532 000004E9 6F6F6B2C20446F776E-
   532 000004F2 206172726F77206C6F-
   532 000004FB 7765727320686F6F6B-
   532 00000504 00                 
   533 00000505 235072657373204573-             db 35,'Press Esc at any time to quit game',0
   533 0000050E 6320617420616E7920-
   533 00000517 74696D6520746F2071-
   533 00000520 7569742067616D6500 
   534 00000529 0100                            db 1,0
   535 0000052B 14507265737320456E-             db 20,'Press Enter to start',0
   535 00000534 74657220746F207374-
   535 0000053D 61727400           
   536 00000541 00                      es      db 0
   537 00000542 467573656B69204761-     credit: db 'Fuseki Games',0
   537 0000054B 6D657300           
   538 0000054F 00<rep 40h>             dtbuff: times 64 db 0
   539 0000058F DCDCDCB0B2B0B0B2B0-     seabed: db 0xDC,0xDC,0xDC,0xB0,0xB2,0xB0,0xB0,0xB2,0xB0,0
   539 00000598 00                 
   540                                  
   541                                  
