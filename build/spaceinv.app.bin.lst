     1                                  ; ------------------------------------------------------------------
     2                                  ; Space Inventors
     3                                  ; ------------------------------------------------------------------
     4                                  
     5                                  	%INCLUDE "include/program.inc"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; Include file for MichalOS program or kernel module development
     3                              <1> ; ------------------------------------------------------------------
     4                              <1> 
     5                              <1> 	BITS 16
     6                              <1> 	ORG 100h
     7                              <1> 	
     8                              <1> 	%include "include/constants.asm"
     1                              <2> ; ------------------------------------------------------------------
     2                              <2> ; Include file for MichalOS kernel/program development - constants & macros
     3                              <2> ; ------------------------------------------------------------------
     4                              <2> 
     5                              <2> ; ------------------------------------------------------------------
     6                              <2> ; COLOURS (eg for os_draw_background and os_draw_block)
     7                              <2> 
     8                              <2> %DEFINE BLACK_ON_WHITE		11110000b
     9                              <2> %DEFINE WHITE_ON_BLACK		00001111b
    10                              <2> 
    11                              <2> ; ------------------------------------------------------------------
    12                              <2> ; KEYS
    13                              <2> 
    14                              <2> %DEFINE KEY_UP		72
    15                              <2> %DEFINE KEY_DOWN	80
    16                              <2> %DEFINE KEY_LEFT	75
    17                              <2> %DEFINE KEY_RIGHT	77
    18                              <2> 
    19                              <2> %DEFINE KEY_ESC		27
    20                              <2> %DEFINE KEY_ENTER	13
    21                              <2> 
    22                              <2> ; ------------------------------------------------------------------
    23                              <2> ; MACROS
    24                              <2> 
    25                              <2> %macro syscall 1
    26                              <2> 	mov bp, %1
    27                              <2> 	call os_syscall
    28                              <2> %endmacro
    29                              <2> 
    30                              <2> %macro clr 1
    31                              <2> 	xor %1, %1
    32                              <2> %endmacro
    33                              <2> 
    34                              <2> %macro mov16 3
    35                              <2> 	mov %1, (%2 + %3 * 256)
    36                              <2> %endmacro
    37                              <2> 
    38                              <2> %macro movs 2
    39                              <2> 	push %2
    40                              <2> 	pop %1
    41                              <2> %endmacro
    42                              <2> 
    43                              <2> ; ------------------------------------------------------------------
    44                              <2> ; MEMORY LOCATIONS
    45                              <2> 
    46                              <2> %define ADLIB_BUFFER 0500h
    47                              <2> %define DESKTOP_BACKGROUND 0600h
    48                              <2> %define SYSTEM_FONT 1600h
    49                              <2> %define FILE_MANAGER 2600h
    50                              <2> %define DISK_PARAMS 2E00h
    51                              <2> 
    52                              <2> %define DISK_BUFFER 0E000h
    53                              <2> %define CONFIG_FILE 57000
    54                              <2> %define CONFIG_FILE_SIZE 83
    55                              <2> 
    56                              <2> ; ------------------------------------------------------------------
    57                              <2> ; CONFIG FILE LOCATIONS
    58                              <2> 
    59                              <2> %define CONFIG(x) (CONFIG_FILE + x)
    60                              <2> 
    61                              <2> ; 0 = Desktop background color (BYTE)
    62                              <2> %define CONFIG_DESKTOP_BG_COLOR CONFIG(0)
    63                              <2> 
    64                              <2> ; 1 = Window background color (BYTE)
    65                              <2> %define CONFIG_WINDOW_BG_COLOR CONFIG(1)
    66                              <2> 
    67                              <2> ; 2 = Password enabled (BYTE)
    68                              <2> %define CONFIG_PASSWORD_ENABLED CONFIG(2)
    69                              <2> 
    70                              <2> ; 3 - 35 = Password data (STRING, 32 chars + '\0')
    71                              <2> %define CONFIG_PASSWORD CONFIG(3)
    72                              <2> %define CFG_PASSWORD_MAX_INPUT_LENGTH 32
    73                              <2> %define CFG_PASSWORD_MAX_LENGTH 33
    74                              <2> 
    75                              <2> ; 36 - 68 = Username (STRING, 32 chars + '\0')
    76                              <2> %define CONFIG_USERNAME CONFIG(36)
    77                              <2> %define CFG_USERNAME_MAX_INPUT_LENGTH 32
    78                              <2> %define CFG_USERNAME_MAX_LENGTH 33
    79                              <2> 
    80                              <2> ; 69 - Sound enabled on startup (BYTE)
    81                              <2> %define CONFIG_SOUND_ENABLED CONFIG(69)
    82                              <2> 
    83                              <2> ; 70 - Adlib driver number
    84                              <2> %define CONFIG_ADLIB_DRIVER CONFIG(70)
    85                              <2> %define CFG_ADLIB_STD_DRIVER 0
    86                              <2> %define CFG_ADLIB_PWM_DRIVER 1
    87                              <2> %define CFG_ADLIB_PWM_LOUD_DRIVER 2
    88                              <2> 
    89                              <2> ; 71 - Menu screen dimming enabled (BYTE)
    90                              <2> %define CONFIG_MENU_DIMMING CONFIG(71)
    91                              <2> 
    92                              <2> ; 72 - Menu color (BYTE)
    93                              <2> %define CONFIG_MENU_BG_COLOR CONFIG(72)
    94                              <2> 
    95                              <2> ; 73 - "DOS" font enabled (BYTE)
    96                              <2> %define CONFIG_FONT CONFIG(73)
    97                              <2> %define CFG_FONT_MICHALOS 0
    98                              <2> %define CFG_FONT_BIOS 1
    99                              <2> 
   100                              <2> ; 74 - Minutes to wait for screensaver (BYTE)
   101                              <2> %define CONFIG_SCREENSAVER_MINUTES CONFIG(74)
   102                              <2> 
   103                              <2> ; 75 - System stack size in 16-byte blocks (WORD)
   104                              <2> %define CONFIG_STACKSGMT_SIZE CONFIG(75)
   105                              <2> 
   106                              <2> ; 77 - 80 - Unused *******************************
   107                              <2> 
   108                              <2> ; 81 - Minute time offset (WORD)
   109                              <2> %define CONFIG_TIMEZONE_OFFSET CONFIG(81)
   110                              <2> 
   111                              <2> ; ------------------------------------------------------------------
   112                              <2> ; MUSICAL NOTE FREQUENCY LIST
   113                              <2> 
   114                              <2> A2		equ 110
   115                              <2> AS2		equ 117
   116                              <2> B2		equ 124
   117                              <2> C3		equ 131
   118                              <2> CS3		equ 139
   119                              <2> D3		equ 147
   120                              <2> DS3		equ 156
   121                              <2> E3		equ 165
   122                              <2> F3		equ 175
   123                              <2> FS3		equ 185
   124                              <2> G3		equ 196
   125                              <2> GS3		equ 208
   126                              <2> A3		equ 220
   127                              <2> AS3		equ 233
   128                              <2> B3		equ 247
   129                              <2> C4		equ 262
   130                              <2> CS4		equ 277
   131                              <2> D4		equ 294
   132                              <2> DS4		equ 311
   133                              <2> E4		equ 330
   134                              <2> F4		equ 349
   135                              <2> FS4		equ 370
   136                              <2> G4		equ 392
   137                              <2> GS4		equ 415
   138                              <2> A4		equ 440
   139                              <2> AS4		equ 466
   140                              <2> B4		equ 494
   141                              <2> C5		equ 523
   142                              <2> CS5		equ 554
   143                              <2> D5		equ 587
   144                              <2> DS5		equ 622
   145                              <2> E5		equ 659
   146                              <2> F5		equ 698
   147                              <2> FS5		equ 740
   148                              <2> G5		equ 784
   149                              <2> GS5		equ 831
   150                              <2> A5		equ 880
   151                              <2> AS5		equ 932
   152                              <2> B5		equ 988
   153                              <2> C6		equ 1046
   154                              <2> CS6		equ 1109
   155                              <2> D6		equ 1175
   156                              <2> DS6		equ 1245
   157                              <2> E6		equ 1319
   158                              <2> F6		equ 1397
   159                              <2> FS6		equ 1480
   160                              <2> G6		equ 1568
   161                              <2> GS6		equ 1661
   162                              <2> A6		equ 1760
   163                              <2> AS6		equ 1865
   164                              <2> B6		equ 1976
   165                              <2> C7		equ 2093
   166                              <2> CS7		equ 2217
   167                              <2> D7		equ 2349
   168                              <2> DS7		equ 2489
   169                              <2> E7		equ 2637
   170                              <2> F7		equ 2794
   171                              <2> FS7		equ 2960
   172                              <2> G7		equ 3136
   173                              <2> GS7		equ 3322
   174                              <2> A7		equ 3520
   175                              <2> AS7		equ 3729
   176                              <2> B7		equ 3951
   177                              <2> C8		equ 4186
   178                              <2> CS8		equ 4435
   179                              <2> D8		equ 4699
   180                              <2> DS8		equ 4978
   181                              <2> E8		equ 5274
   182                              <2> F8		equ 5588
   183                              <2> FS8		equ 5920
   184                              <2> G8		equ 6272
   185                              <2> GS8		equ 6645
   186                              <2> A8		equ 7040
   187                              <2> AS8		equ 7459
   188                              <2> B8		equ 7902
     9                              <1> 	%include "include/syscalls.asm"
     1                              <2> ; ------------------------------------------------------------------
     2                              <2> ; Include file for MichalOS program development - syscalls
     3                              <2> ; ------------------------------------------------------------------
     4                              <2> 
     5                              <2> ; ==================================================================
     6                              <2> ; MichalOS Sound functions (PC speaker, YM3812)
     7                              <2> ; ==================================================================
     8                              <2> 
     9                              <2> ; ------------------------------------------------------------------
    10                              <2> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
    11                              <2> ; IN: AX = note frequency (in Hz)
    12                              <2> ; OUT: None, registers preserved
    13                              <2> 
    14                              <2> os_speaker_tone equ 32795
    15                              <2> 
    16                              <2> ; ------------------------------------------------------------------
    17                              <2> ; os_speaker_raw_period -- Generate PC speaker tone (call os_speaker_off to turn off)
    18                              <2> ; IN: AX = note period (= 105000000 / 88 / freq)
    19                              <2> ; OUT: None, registers preserved
    20                              <2> 
    21                              <2> os_speaker_raw_period equ 33107
    22                              <2> 
    23                              <2> ; ------------------------------------------------------------------
    24                              <2> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
    25                              <2> ; IN: AX = note frequency, CX = length (in ticks)
    26                              <2> ; OUT: None, registers preserved
    27                              <2> 
    28                              <2> os_speaker_note_length equ 32900
    29                              <2> 
    30                              <2> ; ------------------------------------------------------------------
    31                              <2> ; os_speaker_off -- Turn off PC speaker
    32                              <2> ; IN/OUT: None, registers preserved
    33                              <2> 
    34                              <2> os_speaker_off equ 32798
    35                              <2> 
    36                              <2> ; ------------------------------------------------------------------
    37                              <2> ; os_speaker_muted -- Check if the PC speaker is muted
    38                              <2> ; OUT: ZF set if muted, clear if not
    39                              <2> 
    40                              <2> os_speaker_muted equ 33125
    41                              <2> 
    42                              <2> ; ------------------------------------------------------------------
    43                              <2> ; os_start_adlib -- Starts the selected Adlib driver
    44                              <2> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
    45                              <2> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
    46                              <2> ; Common prescaler values:
    47                              <2> ;		33 = ~1 kHz (1004.362 Hz)
    48                              <2> ;		663 = ~50 Hz (49.991 Hz)
    49                              <2> ;		1820 = ~18.2 Hz (18.211 Hz)
    50                              <2> ; OUT: None, registers preserved
    51                              <2> 
    52                              <2> os_start_adlib equ 32984
    53                              <2> 
    54                              <2> ; ------------------------------------------------------------------
    55                              <2> ; os_stop_adlib -- Stops the Adlib driver
    56                              <2> ; IN/OUT: None, registers preserved
    57                              <2> 
    58                              <2> os_stop_adlib equ 33026
    59                              <2> 
    60                              <2> ; ------------------------------------------------------------------
    61                              <2> ; os_adlib_regwrite -- Write to a YM3812 register
    62                              <2> ; IN: AH/AL - register address/value to write
    63                              <2> 
    64                              <2> os_adlib_regwrite equ 32843
    65                              <2> 
    66                              <2> ; ------------------------------------------------------------------
    67                              <2> ; os_adlib_mute -- Mute the YM3812's current state
    68                              <2> ; IN/OUT: None
    69                              <2> 
    70                              <2> os_adlib_mute equ 33044
    71                              <2> 
    72                              <2> ; ------------------------------------------------------------------
    73                              <2> ; os_adlib_unmute -- Unmute the YM3812's current state
    74                              <2> ; IN/OUT: None
    75                              <2> 
    76                              <2> os_adlib_unmute equ 33089
    77                              <2> 
    78                              <2> ; ------------------------------------------------------------------
    79                              <2> ; os_adlib_calcfreq -- Play a frequency
    80                              <2> ; IN: AX - frequency, CL = channel
    81                              <2> ; OUT: None, registers preserved
    82                              <2> 
    83                              <2> os_adlib_calcfreq equ 32966
    84                              <2> 
    85                              <2> ; ------------------------------------------------------------------
    86                              <2> ; os_adlib_noteoff -- Turns off a note
    87                              <2> ; IN: CL = channel
    88                              <2> ; OUT: None, registers preserved
    89                              <2> 
    90                              <2> os_adlib_noteoff equ 33029
    91                              <2> 
    92                              <2> ; ==================================================================
    93                              <2> ; MichalOS Text display output functions
    94                              <2> ; ==================================================================
    95                              <2> 
    96                              <2> ; ------------------------------------------------------------------
    97                              <2> ; os_putchar -- Puts a character on the screen
    98                              <2> ; IN: AL = character
    99                              <2> ; OUT: None, registers preserved
   100                              <2> 
   101                              <2> os_putchar equ 32981
   102                              <2> 
   103                              <2> ; ------------------------------------------------------------------
   104                              <2> ; os_put_chars -- Puts up to a set amount of characters on the screen
   105                              <2> ; IN: BL = terminator, DS:SI = location, CX = character count
   106                              <2> ; OUT: None, registers preserved
   107                              <2> 
   108                              <2> os_put_chars equ 32996
   109                              <2> 
   110                              <2> ; ------------------------------------------------------------------
   111                              <2> ; os_print_string -- Displays text
   112                              <2> ; IN: DS:SI = message location (zero-terminated string)
   113                              <2> ; OUT: None, registers preserved
   114                              <2> 
   115                              <2> os_print_string equ 32771
   116                              <2> 
   117                              <2> ; ------------------------------------------------------------------
   118                              <2> ; os_print_string_box -- Displays text inside a text-box.
   119                              <2> ; IN: DS:SI = message location (zero-terminated string), DL = left alignment
   120                              <2> ; OUT: None, registers preserved
   121                              <2> 
   122                              <2> os_print_string_box equ 32993
   123                              <2> 
   124                              <2> ; ------------------------------------------------------------------
   125                              <2> ; os_format_string -- Displays colored text
   126                              <2> ; IN: DS:SI = message location (zero-terminated string), BL = text color
   127                              <2> ; OUT: None, registers preserved
   128                              <2> 
   129                              <2> os_format_string equ 32978
   130                              <2> 
   131                              <2> ; ------------------------------------------------------------------
   132                              <2> ; os_clear_screen -- Clears the screen to background
   133                              <2> ; IN/OUT: None, registers preserved
   134                              <2> 
   135                              <2> os_clear_screen equ 32777
   136                              <2> 
   137                              <2> ; ------------------------------------------------------------------
   138                              <2> ; os_move_cursor -- Moves cursor in text mode
   139                              <2> ; IN: DH, DL = row, column
   140                              <2> ; OUT: None, registers preserved
   141                              <2> 
   142                              <2> os_move_cursor equ 32774
   143                              <2> 
   144                              <2> ; ------------------------------------------------------------------
   145                              <2> ; os_get_cursor_pos -- Return position of text cursor
   146                              <2> ; IN: None
   147                              <2> ; OUT: DH, DL = row, column
   148                              <2> 
   149                              <2> os_get_cursor_pos equ 32870
   150                              <2> 
   151                              <2> ; ------------------------------------------------------------------
   152                              <2> ; os_show_cursor -- Turns on cursor in text mode
   153                              <2> ; IN/OUT: None, registers preserved
   154                              <2> 
   155                              <2> os_show_cursor equ 32903
   156                              <2> 
   157                              <2> ; ------------------------------------------------------------------
   158                              <2> ; os_hide_cursor -- Turns off cursor in text mode
   159                              <2> ; IN/OUT: None, registers preserved
   160                              <2> 
   161                              <2> os_hide_cursor equ 32906
   162                              <2> 
   163                              <2> ; ------------------------------------------------------------------
   164                              <2> ; os_draw_block -- Render block of specified colour
   165                              <2> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   166                              <2> ; OUT: None, registers preserved
   167                              <2> 
   168                              <2> os_draw_block equ 32945
   169                              <2> 
   170                              <2> ; ------------------------------------------------------------------
   171                              <2> ; os_file_selector -- Show a file selection dialog
   172                              <2> ; IN: None
   173                              <2> ; OUT: AX = location of filename string (or carry set if Esc pressed)
   174                              <2> 
   175                              <2> os_file_selector equ 32855
   176                              <2> 
   177                              <2> ; ------------------------------------------------------------------
   178                              <2> ; os_file_selector_filtered -- Show a file selection dialog only 
   179                              <2> ; with files mathing the filter
   180                              <2> ; IN: ES:BX = location of file extension list (0 if none)
   181                              <2> ; OUT: DS:AX = location of filename string (or carry set if Esc pressed)
   182                              <2> 
   183                              <2> os_file_selector_filtered equ 33122
   184                              <2> 
   185                              <2> ; ------------------------------------------------------------------
   186                              <2> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
   187                              <2> ; That means, when the user changes the selection, the application will be called back
   188                              <2> ; to change the tooltip's contents.
   189                              <2> ; IN: DS:AX = comma-separated list of strings to show (zero-terminated),
   190                              <2> ;     DS:BX = first help string, DS:CX = second help string
   191                              <2> ;     SI = key/display callback (see os_list_dialog_ex)
   192                              <2> ;     if AX = 0: DI = entry display callback, DX = number of entries
   193                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   194                              <2> 
   195                              <2> os_list_dialog_tooltip equ 32912
   196                              <2> 
   197                              <2> ; ------------------------------------------------------------------
   198                              <2> ; os_list_dialog -- Show a dialog with a list of options
   199                              <2> ; IN: ES:AX = comma-separated list of strings to show (zero-terminated),
   200                              <2> ;     ES:BX = first help string, ES:CX = second help string
   201                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   202                              <2> 
   203                              <2> os_list_dialog equ 32936
   204                              <2> 
   205                              <2> ; ------------------------------------------------------------------
   206                              <2> ; os_list_dialog_ex -- Show a dialog with a list of options
   207                              <2> ; IN: DS:BX = pointer to setup struct
   208                              <2> ;       Addr Size Description
   209                              <2> ;       000h word Pointer to entry display callback (accepts CX as entry ID, prints out result) - valid only if ptr to list is zero
   210                              <2> ;       002h word Pointer to comma-separated list of strings to show (zero-terminated)
   211                              <2> ;       004h word Pointer to key/entry change callback (accepts AX as entry ID, CX as keypress),
   212                              <2> ;       006h word Number of entries (if 0, then it is automatically calculated from 002h)
   213                              <2> ;       008h word Pointer to first help string (if 0, then the list will fill the whole dialog)
   214                              <2> ;       00Ah word Pointer to second help string
   215                              <2> ;       00Ch word (ES) Pointer to history data (points to a 5 byte array)
   216                              <2> ;       00Eh byte Screen X position
   217                              <2> ;       00Fh byte Screen Y position
   218                              <2> ;       010h byte Dialog width
   219                              <2> ;       011h byte Dialog height
   220                              <2> ;       012h word Source segment (used for comma-separated list & help strings)
   221                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   222                              <2> 
   223                              <2> os_list_dialog_ex equ 33113
   224                              <2> 
   225                              <2> ; ------------------------------------------------------------------
   226                              <2> ; os_select_list -- Draws a list of entries (defined by a callback) to select from.
   227                              <2> ; IN: AX = width/height, BL = color, CX = number of entries, DX = X/Y pos,
   228                              <2> ;     SI = callback (if C clear = accepts an entry ID in CX, prints an appropriate string,
   229                              <2> ;     if C set = accepts key input in AX, entry ID in CX; not required to preserve regs),
   230                              <2> ;     ES:DI = pointer to a history struct (word .num_of_entries, word .skip_num, byte .cursor) or 0 if none
   231                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
   232                              <2> 
   233                              <2> os_select_list equ 33110
   234                              <2> 
   235                              <2> ; ------------------------------------------------------------------
   236                              <2> ; os_draw_background -- Clear screen with white top and bottom bars
   237                              <2> ; containing text, and a coloured middle section.
   238                              <2> ; IN: DS:AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
   239                              <2> ; OUT: None, registers preserved
   240                              <2> 
   241                              <2> os_draw_background equ 32807
   242                              <2> 
   243                              <2> ; ------------------------------------------------------------------
   244                              <2> ; os_print_newline -- Reset cursor to start of next line
   245                              <2> ; IN/OUT: None, registers preserved
   246                              <2> 
   247                              <2> os_print_newline equ 32783
   248                              <2> 
   249                              <2> ; ------------------------------------------------------------------
   250                              <2> ; os_dump_registers -- Dumps all register contents in hex to the screen
   251                              <2> ; IN: All registers
   252                              <2> ; OUT: None, registers preserved
   253                              <2> 
   254                              <2> os_dump_registers equ 32909
   255                              <2> 
   256                              <2> ; ------------------------------------------------------------------
   257                              <2> ; os_input_dialog -- Get text string from user via a dialog box
   258                              <2> ; IN: ES:AX = string location, DS:BX = message to show
   259                              <2> ; OUT: None, registers preserved
   260                              <2> 
   261                              <2> os_input_dialog equ 32933
   262                              <2> 
   263                              <2> ; ------------------------------------------------------------------
   264                              <2> ; os_password_dialog -- Get a password from user via a dialog box
   265                              <2> ; IN: ES:AX = string location, DS:BX = message to show
   266                              <2> ; OUT: None, registers preserved
   267                              <2> 
   268                              <2> os_password_dialog equ 33041
   269                              <2> 
   270                              <2> ; ------------------------------------------------------------------
   271                              <2> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
   272                              <2> ; IN: DS:AX, DS:BX, DS:CX = string locations (set registers to 0 for no display),
   273                              <2> ; IN: DX = 0 for single 'OK' dialog,
   274                              <2> ;          1 for two-button 'OK' and 'Cancel' ('OK' selected by default),
   275                              <2> ;          2 for two-button 'OK' and 'Cancel' ('Cancel' selected by default)
   276                              <2> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   277                              <2> ; NOTE: Each string is limited to 40 characters
   278                              <2> 
   279                              <2> os_dialog_box equ 32825
   280                              <2> 
   281                              <2> ; ------------------------------------------------------------------
   282                              <2> ; os_print_space -- Print a space to the screen
   283                              <2> ; IN/OUT: None, registers preserved
   284                              <2> 
   285                              <2> os_print_space equ 32873
   286                              <2> 
   287                              <2> ; ------------------------------------------------------------------
   288                              <2> ; os_print_digit -- Displays contents of AX as a single digit
   289                              <2> ; Works up to base 37, ie digits 0-Z
   290                              <2> ; IN: AX = "digit" to format and print
   291                              <2> ; OUT: None, registers preserved
   292                              <2> 
   293                              <2> os_print_digit equ 32879
   294                              <2> 
   295                              <2> ; ------------------------------------------------------------------
   296                              <2> ; os_print_1hex -- Displays low nibble of AL in hex format
   297                              <2> ; IN: AL = number to format and print
   298                              <2> ; OUT: None, registers preserved
   299                              <2> 
   300                              <2> os_print_1hex equ 32882
   301                              <2> 
   302                              <2> ; ------------------------------------------------------------------
   303                              <2> ; os_print_2hex -- Displays AL in hex format
   304                              <2> ; IN: AL = number to format and print
   305                              <2> ; OUT: None, registers preserved
   306                              <2> 
   307                              <2> os_print_2hex equ 32885
   308                              <2> 
   309                              <2> ; ------------------------------------------------------------------
   310                              <2> ; os_print_4hex -- Displays AX in hex format
   311                              <2> ; IN: AX = number to format and print
   312                              <2> ; OUT: None, registers preserved
   313                              <2> 
   314                              <2> os_print_4hex equ 32888
   315                              <2> 
   316                              <2> ; ------------------------------------------------------------------
   317                              <2> ; os_print_8hex - Displays EAX in hex format
   318                              <2> ; IN: EAX = unsigned integer
   319                              <2> ; OUT: None, registers preserved
   320                              <2> 
   321                              <2> os_print_8hex equ 33065
   322                              <2> 
   323                              <2> ; ------------------------------------------------------------------
   324                              <2> ; os_print_int -- Prints an integer in decimal.
   325                              <2> ; IN: AX = unsigned integer
   326                              <2> ; OUT: None, registers preserved
   327                              <2> 
   328                              <2> os_print_int equ 33101
   329                              <2> 
   330                              <2> ; ------------------------------------------------------------------
   331                              <2> ; os_print_32int -- Prints a 32 bit integer in decimal.
   332                              <2> ; IN: EAX = unsigned integer
   333                              <2> ; OUT: None, registers preserved
   334                              <2> 
   335                              <2> os_print_32int equ 32951
   336                              <2> 
   337                              <2> ; ------------------------------------------------------------------
   338                              <2> ; os_input_string -- Take string from keyboard entry
   339                              <2> ; IN: ES:AX = location of string
   340                              <2> ; OUT: None, registers preserved
   341                              <2> 
   342                              <2> os_input_string equ 32819
   343                              <2> 
   344                              <2> ; ------------------------------------------------------------------
   345                              <2> ; os_input_password -- Take password from keyboard entry
   346                              <2> ; IN: ES:AX = location of string
   347                              <2> ; OUT: None, registers preserved
   348                              <2> 
   349                              <2> os_input_password equ 33077
   350                              <2> 
   351                              <2> ; ------------------------------------------------------------------
   352                              <2> ; os_set_max_input_length -- Set the maximum length for the next string input
   353                              <2> ; IN: AL = maximum number of characters
   354                              <2> ; OUT: None, registers preserved
   355                              <2> 
   356                              <2> os_set_max_input_length equ 33131
   357                              <2> 
   358                              <2> ; ------------------------------------------------------------------
   359                              <2> ; os_input_string_ex -- Take string from keyboard entry
   360                              <2> ; IN: ES:AX = location of string, CH = 0 if normal input, 1 if password input,
   361                              <2> ;     DS:SI = callback on keys where AL = 0 (input: AX = keypress)
   362                              <2> ; OUT: None, registers preserved
   363                              <2> 
   364                              <2> os_input_string_ex equ 33119
   365                              <2> 
   366                              <2> ; ------------------------------------------------------------------
   367                              <2> ; os_color_selector - Pops up a color selector.
   368                              <2> ; IN: None
   369                              <2> ; OUT: color number (0-15)
   370                              <2> 
   371                              <2> os_color_selector equ 33053
   372                              <2> 
   373                              <2> ; ------------------------------------------------------------------
   374                              <2> ; os_temp_box -- Draws a dialog box with up to 5 lines of text.
   375                              <2> ; IN: DS:SI/AX/BX/CX/DX = string locations (or 0 for no display)
   376                              <2> ; OUT: None, registers preserved
   377                              <2> 
   378                              <2> os_temp_box equ 33086
   379                              <2> 
   380                              <2> ; ------------------------------------------------------------------
   381                              <2> ; os_reset_font -- Resets the font to the selected default.
   382                              <2> ; IN/OUT = None, registers preserved
   383                              <2> 
   384                              <2> os_reset_font equ 32990
   385                              <2> 
   386                              <2> ; ------------------------------------------------------------------
   387                              <2> ; os_draw_logo -- Draws the MichalOS logo.
   388                              <2> ; IN: None
   389                              <2> ; OUT: A very beautiful logo :-)
   390                              <2> 
   391                              <2> os_draw_logo equ 32852
   392                              <2> 
   393                              <2> ; ------------------------------------------------------------------
   394                              <2> ; os_draw_icon -- Draws an icon (in the MichalOS format).
   395                              <2> ; IN: DS:SI = address of the icon
   396                              <2> ; OUT: None, registers preserved
   397                              <2> 
   398                              <2> os_draw_icon equ 33023
   399                              <2> 
   400                              <2> ; ------------------------------------------------------------------
   401                              <2> ; os_option_menu -- Show a menu with a list of options
   402                              <2> ; IN: AX = comma-separated list of strings to show (zero-terminated)
   403                              <2> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
   404                              <2> 
   405                              <2> os_option_menu equ 32876
   406                              <2> 
   407                              <2> ; ==================================================================
   408                              <2> ; MichalOS Graphics functions
   409                              <2> ; Some graphics routines have been borrowed from TachyonOS
   410                              <2> ; ==================================================================
   411                              <2> 
   412                              <2> ; ------------------------------------------------------------------
   413                              <2> ; os_init_graphics_mode -- Initializes graphics mode.
   414                              <2> ; IN/OUT: None, registers preserved
   415                              <2> 
   416                              <2> os_init_graphics_mode equ 33020
   417                              <2> 
   418                              <2> ; ------------------------------------------------------------------
   419                              <2> ; os_init_text_mode -- Deinitializes graphics mode.
   420                              <2> ; IN/OUT: None, registers preserved
   421                              <2> 
   422                              <2> os_init_text_mode equ 33095
   423                              <2> 
   424                              <2> ; ------------------------------------------------------------------
   425                              <2> ; os_set_pixel -- Sets a pixel on the screen to a given value.
   426                              <2> ; IN: ES = destination memory segment, CX = X coordinate, AX = Y coordinate, BL = color
   427                              <2> ; OUT: None, registers preserved
   428                              <2> 
   429                              <2> os_set_pixel equ 33017
   430                              <2> 
   431                              <2> ; ------------------------------------------------------------------
   432                              <2> ; os_draw_line -- Draws a line with the Bresenham's line algorithm.
   433                              <2> ; Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
   434                              <2> ; IN: ES = destination memory segment, CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
   435                              <2> ; OUT: None, registers preserved
   436                              <2> 
   437                              <2> os_draw_line equ 32999
   438                              <2> 
   439                              <2> ; ------------------------------------------------------------------
   440                              <2> ; os_draw_rectangle -- Draws a rectangle.
   441                              <2> ; IN: ES = destination memory segment, CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
   442                              <2> ; OUT: None, registers preserved
   443                              <2> 
   444                              <2> os_draw_rectangle equ 33047
   445                              <2> 
   446                              <2> ; ------------------------------------------------------------------
   447                              <2> ; os_draw_polygon -- Draws a freeform shape.
   448                              <2> ; IN: ES = destination memory segment, BH = number of points, BL = colour, SI = location of shape points data
   449                              <2> ; OUT: None, registers preserved
   450                              <2> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
   451                              <2> 
   452                              <2> os_draw_polygon equ 33002
   453                              <2> 
   454                              <2> ; ------------------------------------------------------------------
   455                              <2> ; os_clear_graphics -- Clears the graphics screen with a given color.
   456                              <2> ; IN: ES = destination memory segment, BL = colour to set
   457                              <2> ; OUT: None, registers preserved
   458                              <2> 
   459                              <2> os_clear_graphics equ 33008
   460                              <2> 
   461                              <2> ; ----------------------------------------
   462                              <2> ; os_draw_circle -- draw a circular shape
   463                              <2> ; IN: ES = destination memory segment, AL = colour, BX = radius, CX = middle X, DX = middle y
   464                              <2> ; OUT: None, registers preserved
   465                              <2> 
   466                              <2> os_draw_circle equ 33005
   467                              <2> 
   468                              <2> ; ==================================================================
   469                              <2> ; MichalOS Keyboard input handling functions
   470                              <2> ; ==================================================================
   471                              <2> 
   472                              <2> ; ------------------------------------------------------------------
   473                              <2> ; os_wait_for_key -- Waits for keypress and returns key
   474                              <2> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
   475                              <2> ; IN: None
   476                              <2> ; OUT: AX = key pressed, other regs preserved
   477                              <2> 
   478                              <2> os_wait_for_key equ 32786
   479                              <2> 
   480                              <2> ; ------------------------------------------------------------------
   481                              <2> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   482                              <2> ; Also handles special keyboard shortcuts.
   483                              <2> ; IN: None
   484                              <2> ; OUT: AX = 0 if no key pressed, otherwise scan code
   485                              <2> 
   486                              <2> os_check_for_key equ 32789
   487                              <2> 
   488                              <2> ; ==================================================================
   489                              <2> ; MichalOS Port I/O functions
   490                              <2> ; ==================================================================
   491                              <2> 
   492                              <2> ; ------------------------------------------------------------------
   493                              <2> ; os_serial_port_enable -- Set up the serial port for transmitting data
   494                              <2> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
   495                              <2> ; OUT: None, registers preserved
   496                              <2> 
   497                              <2> os_serial_port_enable equ 32954
   498                              <2> 
   499                              <2> ; ------------------------------------------------------------------
   500                              <2> ; os_send_via_serial -- Send a byte via the serial port
   501                              <2> ; IN: AL = byte to send via serial
   502                              <2> ; OUT: AH = Bit 7 clear on success
   503                              <2> 
   504                              <2> os_send_via_serial equ 32861
   505                              <2> 
   506                              <2> ; ------------------------------------------------------------------
   507                              <2> ; os_get_via_serial -- Get a byte from the serial port
   508                              <2> ; IN: None
   509                              <2> ; OUT: AL = byte that was received, AH = Bit 7 clear on success
   510                              <2> 
   511                              <2> os_get_via_serial equ 32864
   512                              <2> 
   513                              <2> ; ==================================================================
   514                              <2> ; MichalOS Disk access functions
   515                              <2> ; ==================================================================
   516                              <2> 
   517                              <2> ; ------------------------------------------------------------------
   518                              <2> ; os_report_free_space -- Returns the amount of free space on disk
   519                              <2> ; IN: None
   520                              <2> ; OUT: AX = Number of sectors free
   521                              <2> 
   522                              <2> os_report_free_space equ 32894
   523                              <2> 
   524                              <2> ; ------------------------------------------------------------------
   525                              <2> ; os_get_file_list -- Generate comma-separated string of files on floppy
   526                              <2> ; IN/OUT: AX = location to store zero-terminated filename string
   527                              <2> 
   528                              <2> os_get_file_list equ 32831
   529                              <2> 
   530                              <2> ; ------------------------------------------------------------------
   531                              <2> ; os_load_file -- Load a file into RAM
   532                              <2> ; IN: AX = location of filename, ES:CX = location in RAM to load file
   533                              <2> ; OUT: BX = file size (in bytes), carry set if file not found
   534                              <2> 
   535                              <2> os_load_file equ 32801
   536                              <2> 
   537                              <2> ; --------------------------------------------------------------------------
   538                              <2> ; os_write_file -- Save (max 64K) file to disk
   539                              <2> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
   540                              <2> ; OUT: Carry clear if OK, set if failure
   541                              <2> 
   542                              <2> os_write_file equ 32915
   543                              <2> 
   544                              <2> ; --------------------------------------------------------------------------
   545                              <2> ; os_file_exists -- Check for presence of file on the floppy
   546                              <2> ; IN: AX = filename location; OUT: carry clear if found, set if not
   547                              <2> 
   548                              <2> os_file_exists equ 32918
   549                              <2> 
   550                              <2> ; --------------------------------------------------------------------------
   551                              <2> ; os_create_file -- Creates a new 0-byte file on the floppy disk
   552                              <2> ; IN: AX = location of filename
   553                              <2> ; OUT: None, registers preserved
   554                              <2> 
   555                              <2> os_create_file equ 32921
   556                              <2> 
   557                              <2> ; --------------------------------------------------------------------------
   558                              <2> ; os_remove_file -- Deletes the specified file from the filesystem
   559                              <2> ; IN: AX = location of filename to remove
   560                              <2> 
   561                              <2> os_remove_file equ 32924
   562                              <2> 
   563                              <2> ; --------------------------------------------------------------------------
   564                              <2> ; os_rename_file -- Change the name of a file on the disk
   565                              <2> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
   566                              <2> ; OUT: carry set on error
   567                              <2> 
   568                              <2> os_rename_file equ 32927
   569                              <2> 
   570                              <2> ; --------------------------------------------------------------------------
   571                              <2> ; os_get_file_size -- Get file size information for specified file
   572                              <2> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
   573                              <2> ; or carry set if file not found
   574                              <2> 
   575                              <2> os_get_file_size equ 32930
   576                              <2> 
   577                              <2> ; --------------------------------------------------------------------------
   578                              <2> ; os_get_file_datetime -- Get file write time/date information for specified file
   579                              <2> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
   580                              <2> ; or carry set if file not found
   581                              <2> 
   582                              <2> os_get_file_datetime equ 33011
   583                              <2> 
   584                              <2> ; --------------------------------------------------------------------------
   585                              <2> ; os_get_boot_disk -- Returns the boot disk number.
   586                              <2> ; IN: None
   587                              <2> ; OUT: DL = boot disk number for use in INT 13h calls
   588                              <2> 
   589                              <2> os_get_boot_disk equ 33062
   590                              <2> 
   591                              <2> ; ==================================================================
   592                              <2> ; MichalOS Miscellaneous functions
   593                              <2> ; ==================================================================
   594                              <2> 
   595                              <2> ; ------------------------------------------------------------------
   596                              <2> ; os_read_config_byte -- Reads a byte from the config
   597                              <2> ; IN: BX = offset
   598                              <2> ; OUT: AL = value
   599                              <2> 
   600                              <2> os_read_config_byte equ 33134
   601                              <2> 
   602                              <2> ; ------------------------------------------------------------------
   603                              <2> ; os_read_config_word -- Reads a word from the config
   604                              <2> ; IN: BX = offset
   605                              <2> ; OUT: AX = value
   606                              <2> 
   607                              <2> os_read_config_word equ 33137
   608                              <2> 
   609                              <2> ; ------------------------------------------------------------------
   610                              <2> ; os_write_config_byte -- Writes a byte to the config
   611                              <2> ; NOTE: This will only affect the config in memory,
   612                              <2> ; run os_save_config to save the changes to disk!
   613                              <2> ; IN: BX = offset, AL = value
   614                              <2> ; OUT: None, registers preserved
   615                              <2> 
   616                              <2> os_write_config_byte equ 33140
   617                              <2> 
   618                              <2> ; ------------------------------------------------------------------
   619                              <2> ; os_write_config_word -- Writes a byte to the config
   620                              <2> ; NOTE: This will only affect the config in memory,
   621                              <2> ; run os_save_config to save the changes to disk!
   622                              <2> ; IN: BX = offset, AX = value
   623                              <2> ; OUT: None, registers preserved
   624                              <2> 
   625                              <2> os_write_config_word equ 33143
   626                              <2> 
   627                              <2> ; ------------------------------------------------------------------
   628                              <2> ; os_save_config -- Saves the current config to disk
   629                              <2> ; OUT: Carry set if error
   630                              <2> 
   631                              <2> os_save_config equ 33146
   632                              <2> 
   633                              <2> ; ------------------------------------------------------------------
   634                              <2> ; os_exit -- Exits the application, launches another one (if possible)
   635                              <2> ; IN: AX = if not 0, then ptr to filename of application to be launched,
   636                              <2> ;     BX = 1 if the application calling os_exit should be re-launched after
   637                              <2> ;     the requested application exits
   638                              <2> ; OUT: None, register preserved
   639                              <2> 
   640                              <2> os_exit equ 32780
   641                              <2> 
   642                              <2> ; ------------------------------------------------------------------
   643                              <2> ; os_clear_registers -- Clear all registers
   644                              <2> ; IN: None
   645                              <2> ; OUT: Cleared registers
   646                              <2> 
   647                              <2> os_clear_registers equ 32975
   648                              <2> 
   649                              <2> ; ------------------------------------------------------------------
   650                              <2> ; os_get_os_name -- Get the OS name string
   651                              <2> ; IN: None
   652                              <2> ; OUT: DS:SI = OS name string, zero-terminated
   653                              <2> 
   654                              <2> os_get_os_name equ 33083
   655                              <2> 
   656                              <2> ; ------------------------------------------------------------------
   657                              <2> ; os_get_memory -- Gets the amount of system RAM.
   658                              <2> ; IN: None
   659                              <2> ; OUT: AX = conventional memory (in kB), BX = high memory (in kB)
   660                              <2> 
   661                              <2> os_get_memory equ 33050
   662                              <2> 
   663                              <2> ; ------------------------------------------------------------------
   664                              <2> ; os_int_1Ah -- Middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
   665                              <2> ; IN/OUT: same as int 1Ah
   666                              <2> 
   667                              <2> os_int_1Ah equ 33032
   668                              <2> 
   669                              <2> ; ==================================================================
   670                              <2> ; MichalOS/MikeOS 4.5 BASIC interpreter
   671                              <2> ; ==================================================================
   672                              <2> 
   673                              <2> ; ------------------------------------------------------------------
   674                              <2> ; The BASIC interpreter execution starts here -- a parameter string
   675                              <2> ; is passed in SI and copied into the first string, unless SI = 0
   676                              <2> 
   677                              <2> os_run_basic equ 32963
   678                              <2> 
   679                              <2> ; ==================================================================
   680                              <2> ; MichalOS Math functions
   681                              <2> ; ==================================================================
   682                              <2> 
   683                              <2> ; ------------------------------------------------------------------
   684                              <2> ; os_get_random -- Return a random integer between low and high (inclusive)
   685                              <2> ; IN: AX = low integer, BX = high integer
   686                              <2> ; OUT: CX = random integer
   687                              <2> 
   688                              <2> os_get_random equ 32948
   689                              <2> 
   690                              <2> ; ------------------------------------------------------------------
   691                              <2> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
   692                              <2> ; IN: AL = BCD number
   693                              <2> ; OUT: AX = integer value
   694                              <2> 
   695                              <2> os_bcd_to_int equ 32846
   696                              <2> 
   697                              <2> ; ------------------------------------------------------------------
   698                              <2> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
   699                              <2> ; IN: AL = integer value
   700                              <2> ; OUT: AL = BCD number
   701                              <2> 
   702                              <2> os_int_to_bcd equ 33035
   703                              <2> 
   704                              <2> ; ------------------------------------------------------------------
   705                              <2> ; os_math_power -- Calculates EAX^EBX.
   706                              <2> ; IN: EAX^EBX = input
   707                              <2> ; OUT: EAX = result
   708                              <2> 
   709                              <2> os_math_power equ 33071
   710                              <2> 
   711                              <2> ; ------------------------------------------------------------------
   712                              <2> ; os_math_root -- Approximates the EBXth root of EAX.
   713                              <2> ; IN: EAX = input, EBX = root
   714                              <2> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   715                              <2> 
   716                              <2> os_math_root equ 33074
   717                              <2> 
   718                              <2> ; ==================================================================
   719                              <2> ; MichalOS String manipulation functions
   720                              <2> ; ==================================================================
   721                              <2> 
   722                              <2> ; ------------------------------------------------------------------
   723                              <2> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
   724                              <2> ; IN: DS:SI = Input string/Output string
   725                              <2> ; OUT: None, registers preserved
   726                              <2> 
   727                              <2> os_string_encrypt equ 33014
   728                              <2> 
   729                              <2> ; ------------------------------------------------------------------
   730                              <2> ; os_string_add -- Add a string on top of another string
   731                              <2> ; IN: DS:AX = Main string, DS:BX = Added string
   732                              <2> ; OUT: None, registers preserved
   733                              <2> 
   734                              <2> os_string_add equ 32897
   735                              <2> 
   736                              <2> ; ------------------------------------------------------------------
   737                              <2> ; os_string_length -- Return length of a string
   738                              <2> ; IN: DS:AX = string location
   739                              <2> ; OUT AX = length (other regs preserved)
   740                              <2> 
   741                              <2> os_string_length equ 32810
   742                              <2> 
   743                              <2> ; ------------------------------------------------------------------
   744                              <2> ; os_string_reverse -- Reverse the characters in a string
   745                              <2> ; IN: DS:SI = string location
   746                              <2> ; OUT: None, registers preserved
   747                              <2> 
   748                              <2> os_string_reverse equ 32939
   749                              <2> 
   750                              <2> ; ------------------------------------------------------------------
   751                              <2> ; os_find_char_in_string -- Find location of character in a string
   752                              <2> ; IN: DS:SI = string location, AL = character to find
   753                              <2> ; OUT: AX = location in string, or 0 if char not present
   754                              <2> 
   755                              <2> os_find_char_in_string equ 32867
   756                              <2> 
   757                              <2> ; ------------------------------------------------------------------
   758                              <2> ; os_string_uppercase -- Convert zero-terminated string to upper case
   759                              <2> ; IN: DS:AX = string location
   760                              <2> ; OUT: None, registers preserved
   761                              <2> 
   762                              <2> os_string_uppercase equ 32813
   763                              <2> 
   764                              <2> ; ------------------------------------------------------------------
   765                              <2> ; os_string_lowercase -- Convert zero-terminated string to lower case
   766                              <2> ; IN: DS:AX = string location
   767                              <2> ; OUT: None, registers preserved
   768                              <2> 
   769                              <2> os_string_lowercase equ 32816
   770                              <2> 
   771                              <2> ; ------------------------------------------------------------------
   772                              <2> ; os_string_copy -- Copy one string into another
   773                              <2> ; IN: DS:SI = source, ES:DI = destination (programmer ensure sufficient room)
   774                              <2> ; OUT: None, registers preserved
   775                              <2> 
   776                              <2> os_string_copy equ 32822
   777                              <2> 
   778                              <2> ; ------------------------------------------------------------------
   779                              <2> ; os_string_join -- Join two strings into a third string
   780                              <2> ; IN: DS:AX = string one, DS:BX = string two, ES:CX = destination string
   781                              <2> ; OUT: None, registers preserved
   782                              <2> 
   783                              <2> os_string_join equ 32828
   784                              <2> 
   785                              <2> ; ------------------------------------------------------------------
   786                              <2> ; os_string_chomp -- Strip leading and trailing spaces from a string
   787                              <2> ; IN: DS:AX = string location
   788                              <2> ; OUT: None, registers preserved
   789                              <2> 
   790                              <2> os_string_chomp equ 32837
   791                              <2> 
   792                              <2> ; ------------------------------------------------------------------
   793                              <2> ; os_string_compare -- See if two strings match
   794                              <2> ; IN: DS:SI = string one, DS:DI = string two
   795                              <2> ; OUT: carry set if same, clear if different
   796                              <2> 
   797                              <2> os_string_compare equ 32834
   798                              <2> 
   799                              <2> ; ------------------------------------------------------------------
   800                              <2> ; os_string_parse -- Take string (eg "run foo bar baz") and return
   801                              <2> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
   802                              <2> ; IN: DS:SI = string
   803                              <2> ; OUT: AX, BX, CX, DX = individual strings
   804                              <2> 
   805                              <2> os_string_parse equ 32960
   806                              <2> 
   807                              <2> ; ------------------------------------------------------------------
   808                              <2> ; os_string_to_int -- Convert decimal string to integer value
   809                              <2> ; IN: DS:SI = string location (max 5 chars, up to '65535')
   810                              <2> ; OUT: AX = number
   811                              <2> 
   812                              <2> os_string_to_int equ 32942
   813                              <2> 
   814                              <2> ; ------------------------------------------------------------------
   815                              <2> ; os_string_to_hex -- Convert hexadecimal string to integer value
   816                              <2> ; IN: DS:SI = string location (max 8 chars, up to 'FFFFFFFF')
   817                              <2> ; OUT: EAX = number
   818                              <2> 
   819                              <2> os_string_to_hex equ 32840
   820                              <2> 
   821                              <2> ; ------------------------------------------------------------------
   822                              <2> ; os_int_to_string -- Convert unsigned integer to string
   823                              <2> ; IN: AX = unsigned int
   824                              <2> ; OUT: DS:AX = string location
   825                              <2> 
   826                              <2> os_int_to_string equ 32792
   827                              <2> 
   828                              <2> ; ------------------------------------------------------------------
   829                              <2> ; os_sint_to_string -- Convert signed integer to string
   830                              <2> ; IN: AX = signed int
   831                              <2> ; OUT: DS:AX = string location
   832                              <2> 
   833                              <2> os_sint_to_string equ 32957
   834                              <2> 
   835                              <2> ; ------------------------------------------------------------------
   836                              <2> ; os_get_time_string -- Get current time in a string (eg '10:25')
   837                              <2> ; IN: ES:BX = string location
   838                              <2> ; OUT: None, registers preserved
   839                              <2> 
   840                              <2> os_get_time_string equ 32849
   841                              <2> 
   842                              <2> ; ------------------------------------------------------------------
   843                              <2> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
   844                              <2> ; IN: ES:BX = string location
   845                              <2> ; OUT: None, registers preserved
   846                              <2> 
   847                              <2> os_get_date_string equ 32858
   848                              <2> 
   849                              <2> ; ------------------------------------------------------------------
   850                              <2> ; os_string_tokenize -- Reads tokens separated by specified char from
   851                              <2> ; a string. Returns pointer to next token, or 0 if none left
   852                              <2> ; IN: AL = separator char, DS:SI = beginning
   853                              <2> ; OUT: DI = next token or 0 if none
   854                              <2> 
   855                              <2> os_string_tokenize equ 32972
   856                              <2> 
   857                              <2> ; ------------------------------------------------------------------
   858                              <2> ; os_string_callback_tokenizer -- Prints a token from string, requests are done by callback
   859                              <2> ; IN: DS:AX = comma-separated string
   860                              <2> ; OUT: AL = AH = max length of any token, CX = number of entries in the list,
   861                              <2> ;      DX:SI = callback location (if C clear, accepts CX as entry ID, prints out result)
   862                              <2> 
   863                              <2> os_string_callback_tokenizer equ 33128
   864                              <2> 
   865                              <2> ; ------------------------------------------------------------------
   866                              <2> ; os_32int_to_string -- Converts an unsigned 32-bit integer into a string
   867                              <2> ; IN: EAX = unsigned int
   868                              <2> ; OUT: DS:AX = string location
   869                              <2> 
   870                              <2> os_32int_to_string equ 33059
   871                              <2> 
   872                              <2> ; ------------------------------------------------------------------
   873                              <2> ; os_string_to_32int -- Converts a string into a 32-bit integer
   874                              <2> ; IN: DS:SI = string location
   875                              <2> ; OUT: EAX = unsigned integer
   876                              <2> 
   877                              <2> os_string_to_32int equ 33068
   878                              <2> 
   879                              <2> ; ==================================================================
   880                              <2> ; MichalOS ZX7 decompression routine
   881                              <2> ; ==================================================================
   882                              <2> 
   883                              <2> ; ------------------------------------------------------------------
   884                              <2> ; os_decompress_zx7 -- Decompresses ZX7-packed data.
   885                              <2> ; IN: DS:SI = source, ES:DI = destination
   886                              <2> ; OUT: None, registers preserved
   887                              <2> 
   888                              <2> os_decompress_zx7 equ 33038
   889                              <2> 
   890                              <2> ; ==================================================================
   891                              <2> ; MichalOS Interrupt management & app timer functions
   892                              <2> ; ==================================================================
   893                              <2> 
   894                              <2> ; -----------------------------------------------------------------
   895                              <2> ; os_modify_int_handler -- Change location of interrupt handler
   896                              <2> ; IN: CL = int number, DI:SI = handler location
   897                              <2> ; OUT: None, registers preserved
   898                              <2> 
   899                              <2> os_modify_int_handler equ 33056
   900                              <2> 
   901                              <2> ; -----------------------------------------------------------------
   902                              <2> ; os_get_int_handler -- Change location of interrupt handler
   903                              <2> ; IN: CL = int number
   904                              <2> ; OUT: DI:SI = handler location
   905                              <2> 
   906                              <2> os_get_int_handler equ 33080
   907                              <2> 
   908                              <2> ; ------------------------------------------------------------------
   909                              <2> ; os_pause -- Delay execution for a specified number of ticks (18.2 Hz by default)
   910                              <2> ; IN: AX = amount of ticks to wait
   911                              <2> ; OUT: None, registers preserved
   912                              <2> 
   913                              <2> os_pause equ 32804
   914                              <2> 
   915                              <2> ; -----------------------------------------------------------------
   916                              <2> ; os_attach_app_timer -- Attach a timer interrupt to an application and sets the timer speed
   917                              <2> ; Formula: speed = (105000000 / 88) / frequency
   918                              <2> ; IN: DS:SI = handler location, CX = speed
   919                              <2> ; OUT: None, registers preserved
   920                              <2> 
   921                              <2> os_attach_app_timer equ 32969
   922                              <2> 
   923                              <2> ; -----------------------------------------------------------------
   924                              <2> ; os_return_app_timer -- Returns the timer interrupt back to the system and resets the timer speed
   925                              <2> ; IN/OUT: None, registers preserved
   926                              <2> 
   927                              <2> os_return_app_timer equ 32987
   928                              <2> 
   929                              <2> ; -----------------------------------------------------------------
   930                              <2> ; os_set_timer_speed -- Sets the timer's trigger speed.
   931                              <2> ; Formula: speed = (105000000 / 88) / frequency
   932                              <2> ; IN: CX = speed
   933                              <2> ; OUT: Nothing, registers preserved
   934                              <2> 
   935                              <2> os_set_timer_speed equ 32891
   936                              <2> 
   937                              <2> ; ==================================================================
   938                              <2> ; MichalOS Low-level disk driver
   939                              <2> ; ==================================================================
   940                              <2> 
   941                              <2> ; --------------------------------------------------------------------------
   942                              <2> ; os_disk_read_sector -- Read a single sector from disk
   943                              <2> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   944                              <2> 
   945                              <2> os_disk_read_sector equ 33092
   946                              <2> 
   947                              <2> ; --------------------------------------------------------------------------
   948                              <2> ; os_disk_read_multiple_sectors -- Read multiple sectors from disk
   949                              <2> ; IN: EAX = sector ID, CX = number of sectors, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   950                              <2> 
   951                              <2> os_disk_read_multiple_sectors equ 33104
   952                              <2> 
   953                              <2> ; --------------------------------------------------------------------------
   954                              <2> ; os_disk_write_sector -- Write a single sector to disk
   955                              <2> ; IN: EAX = sector ID, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   956                              <2> 
   957                              <2> os_disk_write_sector equ 33098
   958                              <2> 
   959                              <2> ; --------------------------------------------------------------------------
   960                              <2> ; os_disk_write_multiple_sectors -- Write multiple sectors to disk
   961                              <2> ; IN: EAX = sector ID, CX = number of sectors, ES:SI = 512 byte buffer, DL = drive number, OUT: carry set if error
   962                              <2> 
   963                              <2> os_disk_write_multiple_sectors equ 33116
   964                              <2> 
    10                              <1> 
    11                              <1> %macro oscall 1
    12                              <1> 	mov bp, %1
    13                              <1> 	int 40h
    14                              <1> %endmacro
    15                              <1> 
    16                              <1> ; -----------------------------------------------------------------
     6                                  
     7 00000000 E9E700                  	jmp start
     8                                  	
     9                                  	; Global constants & variables
    10                                  	
    11 00000003 0024123609              	color_palette		db 00000000b, 00100100b, 00010010b, 00110110b, 00001001b
    12 00000008 80C0E0F0F8FCFE          	counter_table		db 10000000b, 11000000b, 11100000b, 11110000b, 11111000b, 11111100b, 11111110b
    13 0000000F F10B3103B114EA0BF8-     	screen_mapping		dw 3057, 817, 5297, 3050, 3064
    13 00000018 0B                 
    14 00000019 0000000000000000        	blanksprite			db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
    15 00000021 030F1F3F7373FFFFFF-     	character1			db 03h, 0Fh, 1Fh, 3Fh, 73h, 73h, 0FFh, 0FFh, 0FFh, 0EFh, 77h, 78h, 3Fh, 1Fh, 0Fh, 03h
    15 0000002A EF77783F1F0F03     
    16 00000031 57656C636F6D652074-     	welcome_msg			db 'Welcome to Space Inventors!', 13, 10, 13, 10
    16 0000003A 6F2053706163652049-
    16 00000043 6E76656E746F727321-
    16 0000004C 0D0A0D0A           
    17 00000050 507265737320457363-     	welcome_msg2		db 'Press Escape to quit the game', 13, 10
    17 00000059 61706520746F207175-
    17 00000062 697420746865206761-
    17 0000006B 6D650D0A           
    18 0000006F 507265737320616E79-     	welcome_msg3		db 'Press any other key to start!', 0
    18 00000078 206F74686572206B65-
    18 00000081 7920746F2073746172-
    18 0000008A 742100             
    19 0000008D 47414D45204F564552-     	gameover_msg		db 'GAME OVER!', 13, 10
    19 00000096 210D0A             
    20 00000099 596F75722066696E61-     	gameover_msg2		db 'Your final score is: ', 0
    20 000000A2 6C2073636F72652069-
    20 000000AB 733A2000           
    21 000000AF 507265737320456E74-     	gameover_msg3		db 'Press Enter to start again, or', 13, 10
    21 000000B8 657220746F20737461-
    21 000000C1 727420616761696E2C-
    21 000000CA 206F720D0A         
    22 000000CF 707265737320457363-     	gameover_msg4		db 'press Escape to quit', 0
    22 000000D8 61706520746F207175-
    22 000000E1 697400             
    23                                  	play_area			equ 4000h
    24 000000E4 00                      	current_piece		db 0
    25 000000E5 00000000                	current_score		dd 0
    26 000000E9 00                      	game_begun			db 0
    27                                  	
    28                                  start:
    29 000000EA B80D00                  	mov ax, 000Dh
    30 000000ED CD10                    	int 10h
    31                                  
    32                                  	; Reprogram the timer to 60 Hz
    33                                  	
    34 000000EF B9AE4D                  	mov cx, 19886					; 60 Hz
    35 000000F2 E8(7B80)                	call os_set_timer_speed
    36                                  	
    37                                  	; Reprogram the color palette
    38                                  	
    39 000000F5 B80010                  	mov ax, 1000h
    40                                  	clr bl
    31 000000F8 30DB                <1>  xor %1, %1
    41 000000FA BE[0300]                	mov si, color_palette
    42                                  	
    43                                  .palette_loop:
    44 000000FD 8A3C                    	mov bh, [si]
    45 000000FF CD10                    	int 10h
    46                                  	
    47 00000101 46                      	inc si
    48 00000102 FEC3                    	inc bl
    49 00000104 80FB05                  	cmp bl, 5
    50 00000107 7CF4                    	jl .palette_loop
    51                                  
    52                                  	; Set up plane masking
    53                                  	
    54 00000109 BACE03                  	mov dx, 3CEh
    55 0000010C B80500                  	mov ax, 0005h
    56 0000010F EF                      	out dx, ax
    57                                  
    58                                  game_title_screen:
    59                                  
    60                                  	; TO-DO: Display a NICE title screen
    61                                  
    62                                  	clr dx
    31 00000110 31D2                <1>  xor %1, %1
    63 00000112 E8(0680)                	call os_move_cursor
    64 00000115 BE[3100]                	mov si, welcome_msg
    65 00000118 B30F                    	mov bl, 15
    66 0000011A E8(D280)                	call os_format_string
    67                                  	
    68 0000011D E8(1280)                	call os_wait_for_key
    69                                  	
    70 00000120 3C1B                    	cmp al, 27
    71 00000122 0F842601                	je game_over.exit
    72                                  	
    73                                  game_start:
    74 00000126 E82901                  	call clear_screen
    75                                  
    76 00000129 66C706[E500]000000-     	mov dword [current_score], 0	; Clear all the variables
    76 00000131 00                 
    77 00000132 C606[E400]00            	mov byte [current_piece], 0
    78 00000137 C606[E900]00            	mov byte [game_begun], 0
    79                                  	
    80 0000013C BF0040                  	mov di, play_area
    81 0000013F B90A00                  	mov cx, 10						; Use WORDs to make it faster
    82                                  	clr ax
    31 00000142 31C0                <1>  xor %1, %1
    83 00000144 F3AB                    	rep stosw
    84                                  	
    85                                  .main_loop:
    86 00000146 E88B01                  	call check_for_creature
    87                                  
    88 00000149 C606[E900]01            	mov byte [game_begun], 1
    89                                  	
    90 0000014E E84402                  	call get_random_piece
    91 00000151 E87F02                  	call update_screen				; Draw it all out
    92                                  
    93 00000154 803E[1902]01            	cmp byte [sfx], 1
    94 00000159 7509                    	jne .no_sfx
    95                                  
    96 0000015B B80B02                  	mov ax, 523
    97 0000015E B90200                  	mov cx, 2
    98 00000161 E8(8480)                	call os_speaker_note_length
    99                                  
   100                                  .no_sfx:
   101 00000164 E80501                  	call clear_counter				; Clear the current counter
   102                                  	clr cx							; Reset the time counter
    31 00000167 31C9                <1>  xor %1, %1
   103                                  	
   104                                  .key_detect:
   105 00000169 F4                      	hlt								; Wait for ~1/60th of a second
   106                                  
   107 0000016A E81A01                  	call draw_counter
   108                                  	
   109 0000016D E8(1580)                	call os_check_for_key
   110                                  
   111 00000170 80FC48                  	cmp ah, 72						; Up arrow key
   112 00000173 7430                    	je .go_up
   113                                  	
   114 00000175 80FC4B                  	cmp ah, 75						; Left arrow key
   115 00000178 7431                    	je .go_left
   116                                  	
   117 0000017A 80FC4D                  	cmp ah, 77						; Right arrow key
   118 0000017D 7432                    	je .go_right
   119                                  	
   120 0000017F 80FC50                  	cmp ah, 80						; Down arrow key
   121 00000182 7433                    	je .go_down
   122                                  	
   123 00000184 3C1B                    	cmp al, 27						; Escape key
   124 00000186 0F849000                	je game_over
   125                                  
   126 0000018A 66A1[E500]              	mov eax, [current_score]
   127 0000018E 66BB10270000            	mov ebx, 10000
   128                                  	clr edx
    31 00000194 6631D2              <1>  xor %1, %1
   129 00000197 66F7F3                  	div ebx
   130                                  	
   131 0000019A 40                      	inc ax
   132 0000019B 01C1                    	add cx, ax
   133                                  	
   134 0000019D 81F94001                	cmp cx, 320
   135 000001A1 7D77                    	jge game_over
   136                                  	
   137 000001A3 EBC4                    	jmp .key_detect					; If none from the above were pressed, check again
   138                                  	
   139                                  .go_up:
   140 000001A5 60                      	pusha
   141 000001A6 B90400                  	mov cx, 4						; Go up
   142 000001A9 EB12                    	jmp .go_somewhere
   143                                  	
   144                                  .go_left:
   145 000001AB 60                      	pusha
   146 000001AC B90C00                  	mov cx, 12						; Go left
   147 000001AF EB0C                    	jmp .go_somewhere
   148                                  	
   149                                  .go_right:
   150 000001B1 60                      	pusha
   151 000001B2 B91000                  	mov cx, 16						; Go right
   152 000001B5 EB06                    	jmp .go_somewhere
   153                                  	
   154                                  .go_down:
   155 000001B7 60                      	pusha
   156 000001B8 B90800                  	mov cx, 8						; Go down
   157 000001BB EB00                    	jmp .go_somewhere
   158                                  	
   159                                  .go_somewhere:
   160 000001BD 0FB61E[E400]            	movzx bx, byte [current_piece]
   161 000001C2 8A870040                	mov al, [play_area + bx]		; Get the current piece
   162 000001C6 53                      	push bx
   163 000001C7 01CB                    	add bx, cx						; Go to the previously selected destination
   164 000001C9 80BF004000              	cmp byte [play_area + bx], 0	; Is the destination already occupied?
   165 000001CE 7430                    	je .good
   166                                  	
   167 000001D0 66813E[E500]E80300-     	cmp dword [current_score], 1000
   167 000001D8 00                 
   168 000001D9 7C0B                    	jl .small_punish
   169                                  	
   170 000001DB 66812E[E500]E80300-     	sub dword [current_score], 1000	; That's a punishment!
   170 000001E3 00                 
   171 000001E4 EB09                    	jmp .end_punish
   172                                  	
   173                                  .small_punish:
   174 000001E6 66C706[E500]000000-     	mov dword [current_score], 0
   174 000001EE 00                 
   175                                  
   176                                  .end_punish:
   177 000001EF E8E101                  	call update_screen
   178                                  	
   179 000001F2 B84100                  	mov ax, 523 / 8
   180 000001F5 B90A00                  	mov cx, 10
   181 000001F8 E8(8480)                	call os_speaker_note_length
   182                                  
   183 000001FB 5B                      	pop bx
   184 000001FC 61                      	popa
   185 000001FD E969FF                  	jmp .key_detect
   186                                  	
   187                                  .good:
   188 00000200 88870040                	mov [play_area + bx], al
   189 00000204 5B                      	pop bx
   190                                  	
   191 00000205 C687004000              	mov byte [play_area + bx], 0	; Clear the current piece
   192                                  	
   193 0000020A 668306[E500]0A          	add dword [current_score], 10	; Add some score
   194                                  
   195 00000210 C606[1902]01            	mov byte [sfx], 1
   196                                  
   197 00000215 61                      	popa
   198 00000216 E92DFF                  	jmp .main_loop
   199                                  	
   200 00000219 00                      	sfx			db 0
   201                                  
   202                                  game_over:
   203 0000021A C606[1902]01            	mov byte [sfx], 1
   204                                  
   205 0000021F E83000                  	call clear_screen
   206                                  	
   207                                  	clr dx
    31 00000222 31D2                <1>  xor %1, %1
   208 00000224 E8(0680)                	call os_move_cursor
   209                                  	
   210 00000227 BE[8D00]                	mov si, gameover_msg			; Print the game over screen
   211 0000022A B30F                    	mov bl, 15
   212 0000022C E8(D280)                	call os_format_string
   213                                  	
   214 0000022F 66A1[E500]              	mov eax, [current_score]		; Get the current score...
   215 00000233 E8(B780)                	call os_print_32int
   216 00000236 E8(0F80)                	call os_print_newline
   217                                  	
   218 00000239 BE[AF00]                	mov si, gameover_msg3
   219 0000023C E8(D280)                	call os_format_string
   220                                  	
   221                                  .loop:
   222 0000023F E8(1280)                	call os_wait_for_key
   223 00000242 3C0D                    	cmp al, 13
   224 00000244 0F84DEFE                	je game_start					; We want to play again!
   225 00000248 3C1B                    	cmp al, 27
   226 0000024A 75F3                    	jne .loop						; Do we want to quit?
   227                                  	
   228                                  .exit:
   229                                  	; Reprogram the timer back to 18.2 Hz
   230                                  	
   231                                  	clr cx							; 18.2 Hz
    31 0000024C 31C9                <1>  xor %1, %1
   232 0000024E E8(7B80)                	call os_set_timer_speed
   233                                  	
   234 00000251 C3                      	ret
   235                                  
   236                                  ; Clear the entire screen.
   237                                  ; IN: nothing
   238                                  ; OUT: nothing
   239                                  clear_screen:
   240 00000252 60                      	pusha
   241 00000253 06                      	push es
   242                                  	
   243 00000254 BAC403                  	mov dx, 3C4h					; Select all EGA color planes
   244 00000257 B8020F                  	mov ax, 0F02h
   245 0000025A EF                      	out dx, ax
   246                                  	
   247                                  	clr di
    31 0000025B 31FF                <1>  xor %1, %1
   248 0000025D B800A0                  	mov ax, 0A000h
   249 00000260 8EC0                    	mov es, ax
   250                                  
   251                                  	clr ax							; Use WORDs to make it faster
    31 00000262 31C0                <1>  xor %1, %1
   252 00000264 B9A00F                  	mov cx, 4000
   253 00000267 F3AB                    	rep stosw
   254                                  	
   255 00000269 07                      	pop es
   256 0000026A 61                      	popa
   257 0000026B C3                      	ret
   258                                  
   259                                  ; Clears the time counter.
   260                                  ; IN: nothing
   261                                  ; OUT: nothing
   262                                  clear_counter:
   263 0000026C 60                      	pusha
   264 0000026D 06                      	push es
   265                                  	
   266 0000026E BAC403                  	mov dx, 3C4h					; Select all EGA color planes
   267 00000271 B8020F                  	mov ax, 0F02h
   268 00000274 EF                      	out dx, ax
   269                                  	
   270 00000275 BFB01D                  	mov di, 7600					; 7600: X=0, Y=190
   271 00000278 B800A0                  	mov ax, 0A000h
   272 0000027B 8EC0                    	mov es, ax
   273                                  
   274                                  	clr ax							; Use WORDs to make it faster
    31 0000027D 31C0                <1>  xor %1, %1
   275 0000027F B9C800                  	mov cx, 200
   276 00000282 F3AB                    	rep stosw
   277                                  	
   278 00000284 07                      	pop es
   279 00000285 61                      	popa
   280 00000286 C3                      	ret
   281                                  
   282                                  ; Draw the cime counter.
   283                                  ; IN: CX = value (0-320)
   284                                  ; OUT: nothing
   285                                  draw_counter:
   286 00000287 60                      	pusha
   287 00000288 06                      	push es
   288 00000289 BAC403                  	mov dx, 3C4h					; Select all EGA color planes
   289 0000028C B8020F                  	mov ax, 0F02h
   290 0000028F EF                      	out dx, ax
   291                                  	
   292 00000290 89C8                    	mov ax, cx
   293                                  	clr dx
    31 00000292 31D2                <1>  xor %1, %1
   294 00000294 BB0800                  	mov bx, 8
   295 00000297 F7F3                    	div bx							; How many 8-bit cells can we fill?
   296                                  	
   297 00000299 52                      	push dx							; Save the remainder for later
   298 0000029A BB00A0                  	mov bx, 0A000h
   299 0000029D 8EC3                    	mov es, bx
   300 0000029F BFB01D                  	mov di, 7600					; 7600: X=0, Y=190
   301                                  	
   302 000002A2 89C1                    	mov cx, ax
   303 000002A4 85C9                    	test cx, cx						; Is the counter value < 8?
   304 000002A6 740B                    	jz .draw_remainder
   305                                  	
   306 000002A8 B0FF                    	mov al, 255
   307                                  	
   308                                  .full_loop:
   309                                  	clr bx
    31 000002AA 31DB                <1>  xor %1, %1
   310 000002AC E81600                  	call .draw_cell
   311                                  
   312 000002AF 47                      	inc di
   313 000002B0 49                      	dec cx
   314 000002B1 75F7                    	jnz .full_loop
   315                                  	
   316                                  .draw_remainder:
   317 000002B3 5B                      	pop bx
   318                                  	
   319 000002B4 85DB                    	test bx, bx
   320 000002B6 740A                    	jz .exit
   321                                  	
   322 000002B8 4B                      	dec bx
   323                                  	
   324 000002B9 8A87[0800]              	mov al, [counter_table + bx]
   325                                  	clr bx
    31 000002BD 31DB                <1>  xor %1, %1
   326 000002BF E80300                  	call .draw_cell
   327                                  	
   328                                  .exit:
   329 000002C2 07                      	pop es
   330 000002C3 61                      	popa
   331 000002C4 C3                      	ret
   332                                  	
   333                                  .draw_cell:							; AL = bit field (???), EBX = 0, EDI = pointer to VRAM
   334 000002C5 57                      	push di
   335 000002C6 01DF                    	add di, bx
   336 000002C8 AA                      	stosb
   337 000002C9 5F                      	pop di
   338                                  	
   339                                  ;	mov [es:di + bx], al
   340 000002CA 83C328                  	add bx, 40
   341 000002CD 81FB9001                	cmp bx, 400
   342 000002D1 75F2                    	jne .draw_cell
   343 000002D3 C3                      	ret
   344                                  	
   345                                  ; Checks if there is any fully assembled creature.
   346                                  ; IN: nothing
   347                                  ; OUT: nothing
   348                                  check_for_creature:
   349 000002D4 60                      	pusha
   350 000002D5 BB0400                  	mov bx, 4	; Point it to the 1st slot after the 'current piece box'
   351                                  
   352                                  .loop:
   353 000002D8 80BF004000              	cmp byte [play_area + 0 + bx], 0
   354 000002DD 0F848500                	je .empty_space
   355 000002E1 80BF014000              	cmp byte [play_area + 1 + bx], 0
   356 000002E6 747E                    	je .empty_space
   357 000002E8 80BF024000              	cmp byte [play_area + 2 + bx], 0
   358 000002ED 7477                    	je .empty_space
   359 000002EF 80BF034000              	cmp byte [play_area + 3 + bx], 0
   360 000002F4 7470                    	je .empty_space
   361                                  
   362 000002F6 668106[E500]EA0100-     	add dword [current_score], 490			; We've got an assembled creature, add 500 to the score (10 was already given)
   362 000002FE 00                 
   363                                  	
   364 000002FF B8DC00                  	mov ax, 220
   365                                  
   366 00000302 8A8F0040                	mov cl, [play_area + 0 + bx]			; Is the creature assembled with the same pieces?
   367 00000306 3A8F0140                	cmp cl, [play_area + 1 + bx]
   368 0000030A 7518                    	jne .not_the_same
   369                                  	
   370 0000030C 3A8F0240                	cmp cl, [play_area + 2 + bx]
   371 00000310 7512                    	jne .not_the_same
   372                                  	
   373 00000312 3A8F0340                	cmp cl, [play_area + 3 + bx]
   374 00000316 750C                    	jne .not_the_same
   375                                  	
   376 00000318 B84A01                  	mov ax, 330
   377 0000031B 668106[E500]E80300-     	add dword [current_score], 1000			; Add some more to motivate the player
   377 00000323 00                 
   378                                  	
   379                                  .not_the_same:
   380 00000324 B90400                  	mov cx, 4
   381                                  
   382 00000327 66C78700400F0F0F0F      	mov dword [play_area + bx], 0F0F0F0Fh	; Perform a little animation
   383 00000330 E8A000                  	call update_screen
   384                                  
   385 00000333 E8(8480)                	call os_speaker_note_length
   386                                  
   387 00000336 66C787004000000000      	mov dword [play_area + bx], 0
   388 0000033F E89100                  	call update_screen
   389                                  
   390 00000342 D1E0                    	shl ax, 1
   391 00000344 E8(8480)                	call os_speaker_note_length
   392                                  
   393 00000347 66C78700400F0F0F0F      	mov dword [play_area + bx], 0F0F0F0Fh	; (make all 4 squares blink)
   394 00000350 E88000                  	call update_screen
   395                                  
   396 00000353 D1E0                    	shl ax, 1
   397 00000355 E8(8480)                	call os_speaker_note_length
   398                                  
   399 00000358 C606[1902]00            	mov byte [sfx], 0
   400                                  
   401 0000035D 66C787004000000000      	mov dword [play_area + bx], 0			; Clear the whole box (4 bytes = 1 dword)
   402                                  	
   403                                  .empty_space:
   404 00000366 83C304                  	add bx, 4
   405 00000369 83FB14                  	cmp bx, 20								; Are we done with all the squares?
   406 0000036C 0F8568FF                	jne .loop
   407                                  	
   408 00000370 BF0040                  	mov di, play_area
   409                                  	clr bx
    31 00000373 31DB                <1>  xor %1, %1
   410                                  	clr al
    31 00000375 30C0                <1>  xor %1, %1
   411                                  	
   412                                  .empty_loop:
   413 00000377 0201                    	add al, [di + bx]
   414 00000379 43                      	inc bx
   415 0000037A 83FB14                  	cmp bx, 20
   416 0000037D 75F8                    	jne .empty_loop
   417                                  	
   418 0000037F 84C0                    	test al, al								; Are all the squares empty?
   419 00000381 7510                    	jnz .no_bonus
   420                                  	
   421 00000383 803E[E900]00            	cmp byte [game_begun], 0				; Are we at the start of the game (on start, the board is empty)
   422 00000388 7409                    	je .no_bonus
   423                                  	
   424 0000038A 668106[E500]102700-     	add dword [current_score], 10000		; That's a lottery prize!
   424 00000392 00                 
   425                                  	
   426                                  .no_bonus:
   427 00000393 61                      	popa
   428 00000394 C3                      	ret
   429                                  
   430                                  
   431                                  ; Gets a random piece, and places it randomly (if the slot is empty, of course).
   432                                  ; IN: nothing
   433                                  ; OUT: nothing
   434                                  get_random_piece:
   435 00000395 60                      	pusha
   436                                  
   437 00000396 B80100                  	mov ax, 1						; Get a random number from 1...
   438 00000399 BB0400                  	mov bx, 4						; ...to 4
   439 0000039C E8(B480)                	call os_get_random				; Pick a random color
   440 0000039F 51                      	push cx
   441                                  	
   442                                  .try_again:
   443                                  	clr ax
    31 000003A0 31C0                <1>  xor %1, %1
   444 000003A2 BB0300                  	mov bx, 3
   445 000003A5 E8(B480)                	call os_get_random				; Pick a random slot (0-3)
   446 000003A8 89CB                    	mov bx, cx
   447                                  	
   448                                  .check_for_emptiness:				; Check all the areas, if there's an empty space for the tile
   449 000003AA 80BF044000              	cmp byte [play_area + 4 + bx], 0
   450 000003AF 7417                    	je .empty_space
   451 000003B1 80BF084000              	cmp byte [play_area + 8 + bx], 0
   452 000003B6 7410                    	je .empty_space
   453 000003B8 80BF0C4000              	cmp byte [play_area + 12 + bx], 0
   454 000003BD 7409                    	je .empty_space
   455 000003BF 80BF104000              	cmp byte [play_area + 16 + bx], 0
   456 000003C4 7402                    	je .empty_space
   457                                  	
   458 000003C6 EBD8                    	jmp .try_again
   459                                  	
   460                                  .empty_space:
   461 000003C8 58                      	pop ax
   462 000003C9 88870040                	mov [play_area + bx], al		; Put the random piece in the middle
   463 000003CD 881E[E400]              	mov [current_piece], bl			; Store the current piece
   464 000003D1 61                      	popa
   465 000003D2 C3                      	ret
   466                                  
   467                                  ; Updates the screen.
   468                                  ; IN: nothing
   469                                  ; OUT: nothing
   470                                  update_screen:
   471 000003D3 6660                    	pushad
   472                                  	
   473                                  	clr dx
    31 000003D5 31D2                <1>  xor %1, %1
   474 000003D7 E8(0680)                	call os_move_cursor
   475                                  	
   476 000003DA B82009                  	mov ax, 0920h
   477                                  	mov16 bx, 15, 0
    35 000003DD BB0F00              <1>  mov %1, (%2 + %3 * 256)
   478 000003E0 B91400                  	mov cx, 20
   479 000003E3 CD10                    	int 10h							; First, clear the score counter
   480                                  	
   481 000003E5 66A1[E500]              	mov eax, [current_score]
   482 000003E9 E8(2381)                	call os_32int_to_string
   483 000003EC 89C6                    	mov si, ax
   484 000003EE B30F                    	mov bl, 15
   485 000003F0 E8(D280)                	call os_format_string			; Print out the new score
   486                                  	
   487                                  	clr cl							; Counter
    31 000003F3 30C9                <1>  xor %1, %1
   488                                  
   489                                  .loop:
   490 000003F5 BE[2100]                	mov si, character1				; Index into the sprite data
   491                                  	clr ch
    31 000003F8 30ED                <1>  xor %1, %1
   492                                  
   493 000003FA 89CB                    	mov bx, cx
   494 000003FC C1EB02                  	shr bx, 2						; Divide BX by 4 to get the correct VRAM pointer
   495 000003FF D1E3                    	shl bx, 1						; ...and multiply it by 2 (it's a word)
   496 00000401 8BBF[0F00]              	mov di, [screen_mapping + bx]
   497                                  	
   498 00000405 F6C102                  	test cl, 02h					; Does CX & 02h = 02h?
   499 00000408 7407                    	je .no_bottom					; In human-readable words: Is it the bottom half of the sprite?
   500                                  	
   501 0000040A 83C608                  	add si, 8						; Point to the second half of the sprite
   502 0000040D 81C7C003                	add di, 960						; Point to the correct VRAM location
   503                                  	
   504                                  .no_bottom:
   505 00000411 F6C101                  	test cl, 01h					; Does CX & 01h = 01h?
   506 00000414 7405                    	je .no_flip						; Again, in human terms: Is it the right side of the sprite?
   507                                  	
   508 00000416 B501                    	mov ch, 1						; Flip the sprite
   509 00000418 83C703                  	add di, 3						; Render the sprite on the right
   510                                  	
   511                                  .no_flip:
   512 0000041B 0FB6D9                  	movzx bx, cl
   513                                  
   514 0000041E 60                      	pusha
   515 0000041F BE[1900]                	mov si, blanksprite
   516 00000422 B40F                    	mov ah, 15
   517 00000424 E81200                  	call draw_sprite				; First, clear the sprite
   518 00000427 61                      	popa
   519                                  	
   520 00000428 8AA70040                	mov ah, [play_area + bx]		; Get the color
   521                                  
   522 0000042C E80A00                  	call draw_sprite				; Draw the sprite
   523                                  	
   524 0000042F FEC1                    	inc cl
   525 00000431 80F914                  	cmp cl, 20						; Are we done?
   526 00000434 75BF                    	jne .loop
   527                                  	
   528 00000436 6661                    	popad
   529 00000438 C3                      	ret
   530                                  	
   531                                  ; Draws an 8x8 sprite on the screen.
   532                                  ; IN: SI = pointer to the sprite, DI = pointer into the screen memory, CH = 1 to mirror it, AH = color
   533                                  ; OUT: nothing
   534                                  
   535                                  draw_sprite:
   536 00000439 6660                    	pushad
   537 0000043B 06                      	push es
   538                                  	
   539 0000043C BAC403                  	mov dx, 3C4h					; Select an EGA color plane
   540 0000043F B002                    	mov al, 02h
   541 00000441 EF                      	out dx, ax						; Color is in AH already
   542                                  
   543 00000442 B800A0                  	mov ax, 0A000h
   544 00000445 8EC0                    	mov es, ax
   545                                  	
   546 00000447 B108                    	mov cl, 8
   547                                  		
   548                                  .loop:
   549 00000449 AC                      	lodsb							; Get a byte from the sprite data
   550                                  	
   551 0000044A E82D00                  	call extend_byte				; Expand it
   552                                  	
   553 0000044D 51                      	push cx
   554 0000044E B90300                  	mov cx, 3						; Line draw counter
   555                                  	
   556                                  .draw_loop:
   557 00000451 6653                    	push ebx
   558 00000453 66C1CB10                	ror ebx, 16
   559 00000457 26881D                  	mov [es:di], bl					; Draw the 1st byte
   560 0000045A 665B                    	pop ebx
   561                                  	
   562 0000045C 6653                    	push ebx
   563 0000045E 66C1CB08                	ror ebx, 8
   564 00000462 26885D01                	mov [es:di + 1], bl				; Draw the 2nd byte
   565 00000466 665B                    	pop ebx
   566                                  	
   567 00000468 26885D02                	mov [es:di + 2], bl				; Draw the 3rd byte
   568                                  	
   569 0000046C 83C728                  	add di, 40						; Point to the next line
   570 0000046F E2E0                    	loop .draw_loop
   571                                  	
   572 00000471 59                      	pop cx
   573                                  	
   574 00000472 FEC9                    	dec cl							; Are we done with the sprite?
   575 00000474 75D3                    	jnz .loop
   576                                  
   577 00000476 07                      	pop es
   578 00000477 6661                    	popad
   579 00000479 C3                      	ret
   580                                  	
   581                                  ; Extends the byte 3 times (eg. 101b = 111000111b)
   582                                  ; IN: AL = 8-bit byte, CH = 1 to flip the sprite horizontally
   583                                  ; OUT: EBX = 24-bit word
   584                                  extend_byte:
   585 0000047A 6660                    	pushad
   586                                  	clr ah							; We only need the low 8 bits
    31 0000047C 30E4                <1>  xor %1, %1
   587                                  	clr cl							; Counter
    31 0000047E 30C9                <1>  xor %1, %1
   588                                  	clr ebx							; Temporary integer
    31 00000480 6631DB              <1>  xor %1, %1
   589                                  	
   590                                  .decode_loop:
   591 00000483 53                      	push bx
   592                                  	clr dx							; Not to interfere with DIV
    31 00000484 31D2                <1>  xor %1, %1
   593 00000486 BB0200                  	mov bx, 2						; We don't have any registers left...
   594 00000489 F7F3                    	div bx
   595 0000048B 5B                      	pop bx
   596                                  	
   597 0000048C 84ED                    	test ch, ch
   598 0000048E 7411                    	jz .no_flip
   599                                  	
   600 00000490 01D3                    	add bx, dx
   601 00000492 66D1C3                  	rol ebx, 1
   602 00000495 01D3                    	add bx, dx
   603 00000497 66D1C3                  	rol ebx, 1
   604 0000049A 01D3                    	add bx, dx
   605 0000049C 66D1C3                  	rol ebx, 1
   606 0000049F EB0F                    	jmp .flip_end
   607                                  	
   608                                  .no_flip:
   609 000004A1 01D3                    	add bx, dx
   610 000004A3 66D1CB                  	ror ebx, 1
   611 000004A6 01D3                    	add bx, dx
   612 000004A8 66D1CB                  	ror ebx, 1
   613 000004AB 01D3                    	add bx, dx
   614 000004AD 66D1CB                  	ror ebx, 1
   615                                  	
   616                                  .flip_end:
   617 000004B0 FEC1                    	inc cl
   618 000004B2 80F908                  	cmp cl, 8
   619 000004B5 75CC                    	jne .decode_loop
   620                                  	
   621 000004B7 84ED                    	test ch, ch
   622 000004B9 7405                    	jz .big_ror
   623                                  	
   624 000004BB 66D1CB                  	ror ebx, 1
   625 000004BE EB04                    	jmp .routine_end
   626                                  	
   627                                  .big_ror:
   628 000004C0 66C1CB08                	ror ebx, 8
   629                                  	
   630                                  .routine_end:
   631 000004C4 66891E[D104]            	mov [.tmp_word], ebx
   632 000004C9 6661                    	popad
   633 000004CB 668B1E[D104]            	mov ebx, [.tmp_word]
   634 000004D0 C3                      	ret
   635                                  
   636 000004D1 00000000                	.tmp_word		dd 0
